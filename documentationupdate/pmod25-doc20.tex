\documentclass[12pt]{article}
\usepackage[latin1]{inputenc}
\topmargin -1mm
\oddsidemargin -1mm
\evensidemargin -1mm
\textwidth 155mm
\textheight 220mm
\parskip 2mm
\parindent 3mm
%\pagestyle{empty}

\begin{document}

\begin{center}

{\Large \bf General Thermodynamic Package (GTP)}

{\large Basic description and documentation}

Bo Sundman, \today

\end{center}

This is a very preliminary description of the data structure used in
the thermodynamic model package GTP written in Fortran08.

The reason to use Fortran is that it is specially designed for
numerical calculations and there are many numeical libraries
available. It is also inteded for use in massive parallell processing.
Extensive use is made of the datatyping available in Fortran08.

All real numbers are double precision unless specifically noted.

This documententation is neither complete nor up to date with the most
resent version.  The whole structure (and depending subroutines)
should be revised when all major parts have been implemented and
tested.

\vspace{5mm}

{\bf Documentation updating software}

One very difficult thing with software that is alive and changing is
to update the documention.  So my feeling for documentation is that
once a software is documented it is dead as it is almost impossible to
update source code and documentation in parallell.

To avoid this I have now written a simple documentation update
software that uses a basic documentation written as a LaTeX file
together with the source code to extract verbatim sections.  When
running this update software with the current documentation file and a
new source code it compares the existing verbatim sections with those
it can find in the new source code and flaggs all differences.  This
is an easy method to find what has changed in the source code since
last time I worked on the documentation.

The verbatim sections in the source code is enclosed by\\
\verb/!\begin{verbatim}/\\
\verb/extract from source code /\\
\verb/!\end{verbatim} /\\
These can be inserted anywhere.  Normally they enclose important
sections like data structure definitions and declarations of
subroutines and functions.  New verbatim sections are also flagged as
well as verbatim sections that has disappeared.  The update software
writes a new LaTeX documentation file which require some editing but
at least is correct.

With this software I hope to be able to keep the software documented
also during the development stage.

This document is an example of this software.  I assume there are
already many similar software but this one suits my style of
programming.

\newpage

\tableofcontents

\newpage

\section{Basis}

In a thermodynamic system one has elements, species (stoichiometric
combination of elements) and phases.  The thermodynamic properties of
the system are modeled by models for the Gibbs energy which can be
different for each phase.  As the model function is the Gibbs energy
so a system is controlled externally by the temperature, pressure and
amounts of components.  But it can be used to find the equilibrium for
other conditions also.  Some thought has been spent on using another
function than Gibbs energy and additional external variables as stress
or electromagnetic fields.

\subsection{Elements}

The elements have a sequential index arranged alphabetically, a one or
two-letter symbol and a mass.  The symbol must be letters A-Z all in
upper case.  In addition is stored a "name" of the element, like
``iron'' for Fe, the name of a reference phase, the value of H298-H0
for the reference phase and S298 for the reference phase.  The element
symbol must be unique.

The electron and vacancy are entered as element -1 and 0 respectivly
but they are not really treated as elements except that they can be
included in species.  The electron has the symbol /- but one can also
use /+ to denote a positive charge.  Vacancies have no fixed amount
and will always have zero chemical potential at equilibrium.  They
will thus not affect the Gibbs phase rule.

An element can be be suspended, that means it can be hidden from
application programs.  If an element is suspended then all species
that imclude this element are also suspended (implicitly) and also any
phases which cannot exist unless the species is present as
constituent, i.e. the species in the only constituent in a sublattice.

\subsection{Species}

The species are stoichiometric combinations of elements.  They have a
symbol and a stoichiometric formula.  The elements, including the
vacancy, are the simplest species.  The stoichiometry can be
non-integer like a species ALO$_1.5$.  The symbol must start with a
letter A-Z and can contain letters (only upper case), digits, the
period~``.'', the underscore character~``\_'', the slash~``/'', the
minus sign~``-'' and the plus sign~``+''.  No other special character
are allowed, for example parenthesis are not allowed.  The symbol of
the species is often the same as the stoichiometric formula but it is
not necessary.  For example the molecule C$_2$H$_2$Cl$_2$ exists in 2
configurations either with CL on the same side or oposite.  These can
be idetified by giving these the names C2H2CL2\_CIS and
C2H2CL2\_TRANS.

In addition the mass is stored but this is redundant as it is
calculated from the element masses.  The species can have a charge
like Al/+3 or O/-2.  The charge can be non-integer.

Note that a species does not represent a phase, just a stoichiometric
formula.  As constituents of a phase the species is associated with
that phase.  The species H2O can be constituent of ice, liquid water
and gas.  Thus species have no thermodynamic data.  Their only
function is to be constituents of phases where they can be assigned
data.  A species must not be confused with a phase just because many
phases have a fixed stoichiometric formula.  In this package the same
species can be a constituent of many phases, also phases with variable
composition.

When entering the stoichiometric formula for a species one may need to
use stoichiometric numbers to separate one letter elements.  For
example to distinguish CO as cobalt from C1O1 as carbon monoxide the
number 1 must be used after the element letter C.  But otherwise the
stoichiometric number 1 is not needed if the element have a two letter
symbol, for example CAO can be used for a species with one atom of CA
and one atom of O.  One cannot use parenthesis in species names, the
stoichiometry of Ca(OH)$_2$ must be entered as CAO2H2.

\subsection{Phases}

All thermodynamic data that are used in calculations are stored as
part of a phase.  The Gibbs energy of the phase is modelled as a
function of temperature (T), pressure (P) and the constitution of the
phase (Y).  Many different thermodynamic models can be used and each
phase can have a unique model and also several different ``additions''
to this model, like magnetism.  But all phases are accessed from
outside the packange in the same way.  Thus the minimiser used to find
the equilibrium state of a system cannot depend on any particular
model feature.

From ouside the model package one can obtain information of the
constitution of the phase, i.e. which constituents and their fractions
(Y).  The constituents are species (with fixed stoichiometry).  As the
compound energy formalism (CEF) is a very general and flexible model
framework this has been the first implemnted.  In CEF one can define
sublattices with specific species (elements or molecules) as
constituents and the constituent fractions on each sublattice must be
unity.  The constituents are assumed to mix randomly on each
sublattice.  For a general description of CEF please consult the book
by Lukas, Fries and Sundman~\cite{07Luk}.

One may implement models that do not use sublattices and have
non-random entropy in GTP, for example CVM or quasichemical models.
Inside the CEF framework this can be done by treating the phase as
having a single lattice and the probabilities of the different
clusters are fractions and the clusters are species.  Inside the model
package the appropriate non-random configurational entropy is then
evaluated.  The reason to base the model package on the constitution
and not the composition of the component is to avoid a two-level
minimization when calculating the equilibrium.  But there is nothing,
except speed, preventing from using the mole fractions as external
variables for some models and implement an internal minimisation to
determine the configuration which will give the minimum Gibbs energy
for the given external conditions.

There are some models which allow a variable stoichiometry of the
constituents of the phase.  Such models must be implemented as a
two-level minimisation where the model from outside the model package
seem to depend only the mole fractions of the elements or some other
set of components.  It may also be necessary to have some special way
of entering parameters for such a model.

\subsubsection{Phase specification}

A phase has a name and some model information.  If it is a CEF model
it has number of sublattices, the sites in each sublattice (a fixed
real value) and a list of constituents on each sublattice.  One may
have a single consitituent in a sublattice.  An empty sublattice can
have the vacancy as the only constituent.

The term "endmember" refers to a combination of one constituent in
each sublattice.  This defines a compound and is the origin of the
name ``compound energy formalism''. When writing the endmember the
constituents are separated by a colon.

The thermodynamic parameters are entered for the endmembers and
possible interaction parameters.

The ionic liquid model has variable number of sites for cations and
anions to maintain electroneutrality.  This must be taken care of when
calculating the massbalance during with the minimisation.

When entering an endmember parameter the software writes the amount
and reference states of the elements this is referred to.  Care must
be taken that the parameter value correspond to the correct amount of
atoms as this can vary between endmembers of the same phase.  For
example if the FCC phase is defined with 2 sublattices with one site
in each, the endmember G(FCC,TI:VA) is for one mole of atoms whereas
G(FCC,TI:C) is for two moles of atoms.

\subsubsection{Interaction parameters}\label{sec:Redlich-Kister}

For interaction parameters one must add one, two or three additional
constituents in any sublattice separated by a comma from the other
constituents in the same sublattice.  The fractions of the
constituents specified in the parameter should be multipled with the
parameter value.

An interaction parameter may also have a degree specifying that it has
a more complex composition dependence.  The degree is a digit 0 to 9
given after a semicolon.  The default degree is zero.  The meaning of
the degree depend on the model, in CEF it is by default the power in a
Redlich-Kister (RK) series.  Each such RK coefficient is a function of
temperature and pressure.  There can also be differenr extrapolation
models like Muggianu, Kohler and Toop but they are not implemented
yet.

\subsubsection{Model parameters identifiers}\label{sec:paramid}

In addition to calculate the Gibbs energy for a phase the user can
also enter parameters for other properties.  These parameters can
depend on $T, P$ and the constitution of the phase.  In this package
all parameters are identified by

\begin{itemize}
\item a property symbol, listed below
\item the phase name,
\item the constituent array (specifying the constituents in each
sublattice, the fraction of which are multiplied with the parameter), and
\item a degree with a value 0-9
\end{itemize}

for example G(FCC,FE), G(SIGMA,FE:CR:CR), G(LAVES,FE,MO:MO;2),
TC(BCC,FE) or MQ\&FE(FCC;FE), see also \ref{sec:propertydefs}.

The property symbol G is used for the Gibbs energy.  Other properties
symbols like TC is used for the Curie temperature and MQ\&XY for the
mobility of the element XY the the phase.

This means it is possible to include model properties that does not
give any contribution to the Gibbs energy, like the mobility, and thus
the model package can handle the composition dependence of many
properties like resistivity, viscosity etc.  A tentative list of
properties that have been defined is given in Table~\ref{tab:parid}.

\begin{table}[!h]
\caption{Parameter identifiers}\label{tab:parid}
\begin{tabular}{lccll}
Symbol & T & P & Specification             & Meaning\\\hline
 G     & T & P &  & Gibbs Energy\\
 TC    & - & P &  & Mixed Curie/Neel T\\
 BMAG  & - & - &  & Aver Bohr magn number\\
 CTA   & - & P &  & Curie temperatur\\
 NTA   & - & P &  & Neel temperature\\
 IBM   & - & P & \&<constituent\#sublattice> & Individual Bohr magn number\\
 THET  & - & P &  & Debye or Einst temp\\
 MQ    & T & P & \&<constituent\#sublattice> & LN mobility of const\\
 RHO   & T & P &  & Elect resistivity\\
 MAGS  & T & P &  & Magn suseptibili\\
 GTT   & - & P &  & Glas trans temp\\
 VISC  & T & P &  & Viscosity\\
 LPX   & T & P &  & Lattice parameter\\
 EC11  & T & P &  & Elast const C11\\
 EC12  & T & P &  & Elast const C12\\
 EC44  & T & P &  & Elast const C44\\\hline
\end{tabular}
\end{table}

In case the parameters should affect the Gibbs energy, like the Curie
temperature, an ``addition'' subroutine must be written using the
value of this parameter.  See section~\ref{sec:addition}.

The TC and BMAG parameters are included for compatibility with the old
magnetic model, most of the others are just tentative.

\subsubsection{Physical models}

Traditionaly CALPHAD models describes the variation of the Gibbs
energy as a function of $T, P$ and composition without bothering about
the origin of the contributions.  In some cases this is no so good and
for the contribution due to ferromagnetic transitions one has
introduced a more physical contribution that depend on two new
variables, the Curie temperature and the Bohr magnetin number, both of
which depend on the constitution.  Such {\em additions} to the
traditional Gibbs energy expression may become more frequent when also
phonon contributions are modelled down to 0~K as a function of a
constitution dependent Debye temperature.  Hopefully this can lead to
better extrapolations to higher temperatures as well as multicomponent
systems.

\subsubsection{Other properties than the Gibbs energy}\label{sec:propertydefs}

The Gibbs energy parameters has property index 1 (one).  There are a
number of predefined properties in the code, that is the Curie
temperature (index 2), average Bohr magneton number (3) etc.  These
are defined in the subroutine init\_gtp and a tentative list of
predefined identifiers is given in Table~\ref{tab:parid}.  More types
can be added but one must choose a unique symbol for each and each is
assigned a sequential index.  The symbol must not be misstaken for a
state variable symbol either.  In the property records, see
\ref{sec:proprec}, for endmembers and interactions this propery index
is used to identify the property.

The mobility of an element in a phase depends on the constitution and
the temperature but the mobility does not contribute to the Gibbs
energy.  Anyway it is possible to define and enter mobilities in GTP
to handle their composition dependence.  The values of these, and any
other separate property like the Curie temperature, can be obtained
anytime by a special subroutine call.

One must consider that the mobility for each constituent depend
individually on the constitution and a symbol MQ\&X(BCC) is used to
define the mobility of X in the BCC phase as a function of its
constitution.  Thus MQ\&FE(BCC,FE) is the self diffusion of FE in BCC
and MQ\&FE(BCC,CR) is the mobility of FE in pure BCC Cr.  If there are
data one can have interaction parameters like MQ\&FE(BCC,CR,FE).  Each
mobility parameter can depend on T and P.

Other properties that may be described by this model package are
lattice parameters, elastic constants, resistivity, etc.  see
Table~\ref{tab:parid}.

\subsection{Components}

The term "component" has no meaning for the modelling, only for
controlling the system externally.  The species that can dissolve in a
phase are called constituents.  The term component is reserved for an
irreducible set of species that describe the composition space of the
system, sometimes called ``system components''.  In most cases these
components are the elements.  For many simple models the constituents
of the phases are also identical to the elements.

The components are important as they determine the number of
conditions that can be set in order to calculate the equilibrium of
the system because one can only set as many conditions as one has
components and for T and P.  Many conditions, like the amounts or
chemical potentials, can only be specified for the components, not for
an individual species.  This does not mean that the calculation of
equilibria is limited to conditions on the amounts of the components,
only that the number of components determine the number of conditions
that must be set in order to calculate the equilibrium.

In GTP the elements are by default the components but the user may
change this to any orthogonal set of species.  When working with
oxides with no degree of freedom for the oxygen content, like in a
quasibinary CaO-SiO$_2$ system, it may be convenient to select the
oxides CaO and SiO$_2$ as components and then leave the content of the
third element undetermined by setting an arbitrary (positive) value of
its activity.  But in such cases it is necessary to know that the
models used for the phases does not allow the content of this element
to vary independently.  If a gas phase is included in the system it
may be more convenient to set the gas as fixed with zero amount,
although that may increase the calculation time.

\subsection{Fraction sets}\label{sec:partitioning}

In some software like Thermo-Calc (TC) one may have a phase described
by two separate Gibbs energy functions, this is called ``partitioned''
or ``splitted''.  It was originally used for phases with
order/disorder transformations like A1/L1$_2$ or A2/B2 where the phase
can be completely disordered.  All parameters to discribe the
disordered state where collected in a phase that had no sublattices
for ordering (it could have a siblattice for interstitials).  This
made it also easier to include ordering in multicomponent databases
where many subsystems have phases with A1 (fcc) or A2 (bcc) phases
without ordering.

The Gibbs energy of a partitioned phase is written
\begin{equation}
G_m = G_m^{\rm dis}(x) + \left(G_m^{\rm ord}(y) - G_m^{\rm ord}(y=x)\right)
\end{equation}

The mole fractions, $x$, for the disordered part is always calculated
from the constituent fractions, $y$ as
\begin{equation}
x_i = \frac{\sum_s a_s \sum_j b_{ij} y_j}{\sum_s a_s \sum_k \sum_j b_{kj} y_j}
\end{equation}
where $a_s$ are the number of sites on sublattice $s$, $b_{ij}$ are
the stoichiometric factors for the sublattices divided with the total
number of sites.  The fraction of vacancies should not be included in
the summation.

The contribution from the ordered part is thus calculated twice, once
with the original site fractions, once with the site fractions equal
to the substititional mole fractions.  The contribution from the
ordered part would thus always be zero when the phase was disordered
(it that case one can of course skip calculating the ordered part to
save time).

Later a variant of this model have been aplied also to intermetallic
phase that never disorder completely like $\sigma$, $\mu$, Laves phase
and similar.  The equation is then slightly different as there is no
need to describe the completely disordered state
\begin{equation}
G_m=\left(G_m^{\rm dis}(x)-T~^{\rm cfg}S_m^{\rm dis}\right)+G_m^{\rm ord}(y)
\end{equation}
The configurational entropy is only calculated for the ordered part.

This second variant of the disordered model is very interesting
because many intermetallic phases like the $\sigma$ phase have a very
large number of end members in multicomponent systems and they must
all be given a reasonable value, although today most of them are just
equal to the sum of the reference energies of the endmembers.

In the OC software we have taken this into account from the beginning
and due to the parameters in the disordered part it is not necessary
to enter all endmembers of the ordered part, only those which is known
to be stable or close to be stable.  {\em Ab initio} data can be used
for this when experimental data are missing.  The disordered part is
entered as an extra ``fraction set'' of the ordered phase and one
simply specifies how many sublattice that should be added together to
for the disordered part.  For an fcc phase with 5 sublattices, 4 for
ordering and one interstitial, one simply gives 4, assuming the 5th
sublattice is the interstitial one.  For a $\sigma$ phase with 3
sublattices that all disorder together one gives 3.

For a multicomponent $\sigma$ phase one may have some 250 endmembers
which all must be calculated.  With the new software this may be
rediced to less than 25 which will be a significant increase in
calculation speed compared to the case when all endmembers have a
value.  The maintanance of the database will also be simplified as
fewer endmembers are stored.

The new software will create a fraction set record that gives the way
to add fractions (the coefficients $b_{ij}$ are stored there as they
are also needed to calculate the contribution to the partial
derivatives).  A link to this fraction set record is stored in the
phase\_varres record linked from the phase (or rather sublattice)
record.  When setting the constitution of the phase, i.e. the site
fractions, the disordered fractions will be automatically calculated
and saved in another phase\_varres recored linked from this fraction
set record.  In this way it will thus be straightforward to calculate
the ordered and disordered part with the same subroutine, one just
have to organize the calculations of each part separately and then add
all values, including first and second derivatives, together in the
end.

\subsection{Composition sets and miscibility gaps}\label{sec:compsets}

Composition sets is the way OC handles the case when a phase with the
same structure can appear simultaneously with two or more
compositions.  One case this is necessary is when a phase split up
into two or more miscibility gaps like the bcc phase in the Cr-Mo
system.  Less obvious cases is when a phase has an order/disorder
transition like the fcc phase in Au-Cu forms L1$_2$ and L1$_0$
structures.  But also in that case the ordered and disordered phases
are described with the same thermodynamic data.  Finally this is
technique is also used to describe the cubic and hexagonal carbides
where the metallic atoms are the same as fcc and hcp lattices but
interstitial atoms lice C and N can occupy most of the available
interstitial sites.

Outside the OC package, for example in the TQ package, one can obtain
information about the number of composition sets for a phase using the
global integer array phcs.  For each phase ``nph'' the array element
``phcs(nph)'' has the number of composition sets.  Inside the OC
package the phase number and composition set number are usually given
separately.  A phase must have one composition set and the maximum
number is 9.  The composition set larger than 1 is normally suffixed
after the phase name separated by a \# like bcc\#2.  If omitted
composition set 1 is assumed.

If there are several composition sets of a phase there is a separate
phase\_varres record for each composition set.  Normally these have
identical set of constituents but it is possible to suspend
constituents in each composition set separately.  At the time when a
fraction set is added to a phase this must not have any suspended
constituents.

Fraction set records have no array or free list, they exist only
inside the phase\_varres records.  This created some extra trouble
when creating them as a simple assignemnt of a record to another did
not create any new record.

\subsection{State variables}

State variables are, as the name indicate, only dependent on the state
of the system, not how this state was reached.  In principle they have
a well-defined value only at equilibrium but in the modelling they can
be extennded also outside this range.

The state variables recognized by GTP and that can be used are defined
in Table~\ref{tab:statevar}.  Many of them can have several indices
and/or normalizing quantites.  In the box below there are some
examples of using these in conditions and otherwise.

\begin{tabular}{|ll|}\hline
N=1         & means the system has one mole of atoms\\
N(H)=1      & means the system has 1 mole of component H\\
N(GAS,H)=1  & means the gas phase has 1 mole of component H\\
NP(LIQUID)=1 & means the liquid phase has 1 mole of components\\
X(H)=0.3     & means the mole fraction of component H in the system is 0.3\\
X(GAS,H)=0.3 & means the gas phase has a mole fraction of 0.3 of H\\
B=1000      & means the system has a mass of 1000 grams\\
W\%(CR)=18   & means the system has 18 mass percent of component CR\\
W(LIQUID,C)=0.01 & means the liquid has 0.01 mass fraction of carbon\\
H           & is the total enthalpy of the system\\
H(LIQUID)   & is the enthapy of the current amount of liquid (can be zero)\\
HM(LIQUID)  & is the enthalpy of liquid per mole components\\
HV(LIQUID)  & is the enthalpy of liquid per m$^3$\\
HW(LIQUID)  & is the enthalpy of liquid per gram\\
HF(LIQUID)  & is the enthalpy of one formula unit of liquid\\\hline
\end{tabular}

\begin{table}
\caption{A very preliminary table with the state variables and their
internal representation.  Some model parameter properties are also
included.}\label{tab:statevar}
\begin{tabular}{|llccll|}\hline
Symbol & Id & \multicolumn{2}{c}{Index} & Normalizing & Meaning\\
       &    & 1 & 2                     &  suffix     & \\\hline
\multicolumn{6}{|c|}{Intensive properties}\\\hline
T      & 1  & -         & -    & - & Temperature\\
P      & 2  & -         & -    & - & Pressure\\
MU     & 3  & component & -/phase  & - & Chemical potential\\
AC     & 4  & component & -/phase  & - & Activity\\
LNAC   & 5  & component & -/phase  & - & LN(activity)\\\hline
\multicolumn{6}{|c|}{Extensive properties}\\\hline
U      & 10 & -/phase\#set & - & - & Internal energy for system\\
UM     & 11 & -/phase\#set & - & M & Internal energy per mole\\
UW     & 12 & -/phase\#set & - & W & Internal energy per mass\\
UV     & 13 & -/phase\#set & - & V & Internal energy per m$^3$\\
UF     & 14 & phase\#set   & - & F & Internal energy per formula unit\\
Sz     & 2z & -/phase\#set & - & - & entropy\\
Vz     & 3z & -/phase\#set & - & - & volume\\
Hz     & 4z & -/phase\#set & - & - & enthalpy\\
Az     & 5z & -/phase\#set & - & - & Helmholtz energy\\
Gz     & 6z & -/phase\#set & - & - & Gibbs energy\\
NPz    & 7z &  phase\#set & - & - & Moles of phase\\
BPz    & 8z & phase\#set & - & - & Mass of phase\\
Qz     & 9z & phase\#set & - & -  & Stability of phase\\
DGz    & 10z & phase\#set & - & -  & Driving force of phase\\
Nz     & 11z & -/phase\#set/comp & -/comp & -  & Moles of component\\
X      & 111 & phase\#set/comp & -/comp & 0  & Mole fraction\\
X\%    & 111 & phase\#set/comp & -/comp & 100 & Mole per cent\\
Bz     & 12z & -/phase\#set/comp & -/comp & -  & Mass of component\\
W      & 122 & phase\#set/comp & -/comp & 0 & Mass per cent\\
W\%    & 122 & phase\#set/comp & -/comp & 100 & Mass per cent\\
Y      & 130 & phase\#set & const\#subl & -& Constituent fraction\\\hline
\multicolumn{6}{|c|}{Some model parameter identifiers}\\\hline
TC     & - & phase\#set & - & - & Curie temperature\\
BMAG   & - & phase\#set & - & - & Aver. Bohr magneton number\\
MQ\&   & - & phase\#set & constituent & - & Mobility\\
THET   & - & phase\#set & - & - & Debye temperature\\\hline
\end{tabular}
\end{table}

\section{Fortran Data Structures}

A number of arrays must be dimensioned, this is done by defining some
constants (called PARAMETER in Fortran) and then using these to dimension
arrays with fixed size.  It may be possible to set these limits in a
more flexible way by allocating the arrays in a special subroutine for
initiation.

As I am learning Fortran08 by this programming I discover new
possibilities now and again.  It seems possible to allow the
initialization subroutine to do this dimensioning which means one may
tailor the dimensioning of the arrays depending on the kind of
calculation one will make.

\subsection{User defined data types}

The presentation of the data structures defined here follows the way
they are declared in the Fortran source code.  That may sometimes not
be entirely logical but it makes it simpler to update the
documentation.

In Fortran08 the programmer can define specific datatypes and several
such are used to store the model information.  A datatype can contain
many different kinds of variables like characters and numerical
information.  One can also have links between instances (records) of
the same and different kinds of datatypes.

This kind of method to organize data is available in all modern
computing languages and has been severely missed in Fortran.  In
Thermo-Calc it was handled by storing data in the selfdesigned
workspace.

Some datatypes are straightforward to implement like the element.
Thus one defines a datatype which has all the necessary information
for an element and then allocates an array to hold as many elements
that is necessary.

Other datatypes are more involved, like the record to hold information
about an endmember parameter of a phase.  This record must refer to
the constituents that makes up the endmember and also a link to a list
of properties that can be calculated for this end member.  Finally it
must be possible to link the endmember record in a list for a specific
phase and it must be possible to have a link to interaction records
based on this endmember.  Before one can figure out how to store
endmember data it is thus necessary to have a data structure
containing many different kinds of data.  One must also consider which
data that may be different in different parallell processes dealing
with the phase and which data that are ``static''.  Many of these
records may also be of different size for different phases and for
example an endmember record for a phase with 3 sublattices need 3
times as many places for constituent indices than a phase with a
single lattice.  This can be handled with the dynamic allocation
feature in Fortran08.

The TYPE definition feature in Fortran08 may be a little less flexible
than in other programming languages but it also avoids some of the
strange features of these like the "this" operator needed at strange
places in some cases.  There is no "new" operator either, records are
usually declared as single entities or as arrays with fixed (although
allocatable) size. But one can use pointers to allocate new records
which can be found only by these pointers.

Some of the structures are used to define arrays, like the elment,
species and phases.  Some are created dynamically and can only ¨be
accessed by pointers, like endmembers and property records.  Some are
used locally inside subroutines and declared globally only if used in
several.

\subsection{Bits of information}

Many records contain information that is of YES/NO or ON/OFF type and
they are often stored as bits in a status word.  Some of these are set
automatically and there are subroutines and commands to change others.
They are summarized below for all records.

The use of each bit is explained in the text from the source code.

{\small
\begin{verbatim}
!-Bits in global status word (GS) in globaldata record
! level of user: beginner, occational, advanced; NOGLOB: no global gridmin calc
! NOMERGE: no merge of gridmin result, NODATA: not any data,
! NOPHASE: no phase in system, NOACS: no automatic creation of composition set
! NOREMCS: do not remove any redundant unstable composition sets
! NOSAVE: data changed after last save command
! >>>> som of these should be moved to the gtp_equilibrium_data record
  integer, parameter :: &
       GSBEG=0,     GSOCC=1,     GSADV=2,     GSNOGLOB=3, &
       GSNOMERGE=4, GSNODATA=5,  GSNOPHASE=6, GSNOACS=7, &
       GSNOREMCS=8, GSNOSAVE=9
!-Bits in element record
  integer, parameter :: &
       ELSUS=0
!-Bits in species record
! Suspended, implicitly suspended, species is element, species is vacancy
! species have charge, species is component
  integer, parameter :: &
       SPSUS=0, SPIMSUS=1, SPEL=2, SPVA=3, &
       SPION=4, SPSYS=5
\end{verbatim}
}

\subsubsection{Phase record bits}\label{sec:phasebits}

The phase record has many bits specifing various things.  Additionally
the composition set record has other bits, most important if the
composition set is ENTERED, meaning it can be stable, FIX, meaning it
is a condition that it is stable, SUSPENDED, meaning it must not be
stable, and DORMANT meaning it must not be stable but the driving
force is calculated.

A user can change these bits but he/she cannot set the CSSTABLE bit
which is only set if the phase is stable after a full equilibrium
calculation.

{\small
\begin{verbatim}
!-Bits in phase record
! hidden, implictly hidden, ideal, no concentration variation (NOCV),
! Phase has parameters entered (PHHASP),
! F option (FORD), B option (BORD), Sigma ordering (SORD),
! multiple/disordered fraction sets (MFS), gas, liquid, ionic liquid,
! aqueous, dilute config. entropy (DILCE), quasichemical (QCE), CVM,
! FACT,  not create comp. sets (NOCS), Helmholz energy model (HELM),
! Model without 2nd derivatives (PHNODGDY2), Elastic model A,
! explicit charge balance needed (XCB),
  integer, parameter :: &
       PHHID=0,     PHIMHID=1,  PHID=2,    PHNOCV=3, &     ! 1 2 4 8
       PHHASP=4,    PHFORD=5,   PHBORD=6,  PHSORD=7, &
       PHMFS=8,     PHGAS=9,    PHLIQ=10,  PHIONLIQ=11, &
       PHAQ1=12,    PHDILCE=13, PHQCE=14,  PHCVMCE=15,&
       PHFACTCE=16, PHNOCS=17,  PHHELM=18, PHNODGDY2=19,&
       PHELMA=20,   PHEXCB=21
!
!-Bits in constituent fraction (phase_varres) record STATUS2
! CSDFS is set if record is for disordred fraction set, then one must use
!     sublattices from fraction_set record
! CSDLNK: a disordred fraction set in this phase_varres record
! CSSUS: set if comp. set if must not be stable,
! CSFIXDORM: set if fix or dormant,
! CSCONSUS set if one or more constituents suspended (status array constat
!     specify constituent status)
! CSORDER: set if fractions are ordered (only used for BCC/FCC ordering
!     with a disordered fraction set).
! CSSTABLE: set if phase is stable after an equilibrium calculation
! CSAUTO set if composition set created during calculations
! CSDEFCON set if there is a default constitution
! NOTE phase_status ENTERED means both CSSUS and CSFIXDORM are not set
   integer, parameter :: &
        CSDFS=0,    CSDLNK=1,  CSSUS=2,    CSFIXDORM=3, &
        CSCONSUS=4, CSORDER=5, CSSTABLE=6, CSAUTO=7, &
        CSDEFCON=8
\end{verbatim}
}

\subsubsection{Some more bits}

In particular the gtp\_equilibrium\_data record there are some bits
that specifies how the equilibrium calculation can be done, for
example if the software can use global gridminimization to find start
values.

For the parameter property record there are also bits specifying of
the property may depend on $T$ and $P$ or if it has a constituent or
component specifier (like the mobility).

{\small
\begin{verbatim}
!-Bits in constat array for each constituent
! For each constituent: is suspended, is implicitly suspended, is vacancy
   integer, parameter :: &
        CONSUS=0,CONIMSUS=1,CONVA=2
!-Bits in state variable functions (svflista)
! SVFVAL symbol evaluated only explicitly (mode=1 in call)
   integer, parameter :: &
        SVFVAL=0,SVFEXT=1
!-Bits in gtp_equilibrium_data record
! EQNOTHREAD set if equilibrium must be calculated before threading
! (in assessment) for example if a symbol must be evaluated in this
! equilibrium before used in another like H(T)-H298
   integer, parameter :: &
        EQNOTHREAD=0, EQNOGLOB=1, EQNOEQCAL=2, EQINCON=3, &
        EQFAIL=4,     EQNOACS=5,  EQGRIDTEST=6
!-Bits in parameter property type record (gtp_propid)
! constant (no T or P dependence), only P, property has an element suffix
! (like mobility), property has a constituent suffix
   integer, parameter :: &
        IDNOTP=0, IDONLYP=1, IDELSUFFIX=2, IDCONSUFFIX=3
!- Bits in condition status word (some set in onther ways??)
! singlevar means T=, x(el)= etc, singlevalue means value is a number
! phase means the condition is a fix phase
  integer, parameter :: &
       ACTIVE=0,SINGLEVAR=1,SINGLEVALUE=2,PHASE=3
!
! >>> Bits for symbols and TP functions missing ???
\end{verbatim}
}

\subsection{Dimensioning}

Most arrays are dimensioned in the GTP package using constants.  If
one need to change them it is usually only in one place.  Most of
these constants are used in the init\_gtp subroutine but also when
temporary arrays are needed inside some other subroutines.

{\small
\begin{verbatim}
! Parameters defining the size of arrays etc.
! max elements, species, phases, sublattices, constituents (ideal phase)
 integer, parameter :: maxel=20,maxsp=1000,maxph=200,maxsubl=10,maxconst=1000
! maximum number of consitutents in non-ideal phase
 integer, parameter :: maxcons2=100
! maximum number of elsements in a species
 integer, parameter :: maxspel=10
! maximum number of references
 integer, private, parameter :: maxrefs=1000
! maximum number of equilibria
 integer, private, parameter :: maxeq=100
! some dp values, default precision of Y and default minimum value of Y
! zero and one set in tpfun
 double precision, private, parameter :: YPRECD=1.0D-6,YMIND=1.0D-30
! dimension for push/pop in calcg, max composition dependent interaction
 integer, private, parameter :: maxpp=1000,maxinter=3
! max number of symbols
 integer, private, parameter :: maxtpf=10*maxph
! max number of properties (G, TC, BMAG MQ%(...) etc)
 integer, private, parameter :: maxprop=50
! max number of state variable functions
 integer, private, parameter :: maxsvfun=500
! version number
! changes in last 2 digits means no change in SAVE/READ format
 character*8, parameter :: gtpversion='GTP-1.00'
\end{verbatim}
}

\subsubsection{User defined additions}

The additions provided or added by programmers must be uniquely
identified.  This is an attempt to do that with those already available.

{\small
\begin{verbatim}
! The number of additions to the Gibbs energy of a phase is increasing
! This is a way to try to organize them.  Each addtion has a unique
! number identifying it when created, listed or calculated.  These
! numbers are defined here
 integer, public, parameter :: indenmagnetic=1
 integer, public, parameter :: debyecp=2
 integer, public, parameter :: weimagnetic=3
 integer, public, parameter :: einsteincp=4
 integer, public, parameter :: elasticmodela=5
 integer, public, parameter :: glastransmodela=6
! Note that additions often use parameters like Curie or Debye temperatures
! defined by parameter identifiers stored in gtp_propid
\end{verbatim}
}

\section{Data structures declared in GTP}

Below the data types in GTP will be explained and in some cases also
how they are declared as arrays or inside other data types.  Many of
the declared variables are ``private'' which means they cannot be
changed directly from outside the module.  For such data that the user
will manipulate there are subroutines or functions provided.

\subsection{Global data}

Information that is valid for the whole system is stored here.  Note
that T and P may be different in different parallell processes and if
there is a prescribed value that is stored in a condition record.
Maybe this is not really needed.

{\small
\begin{verbatim}
 TYPE gtp_global_data
! status should contain bits how advanced the user is and other defaults
! it also contain bits if new data can be entered (if more than one equilib)
    integer status
    character name*24
    double precision rgas,rgasuser,pnorm
 END TYPE gtp_global_data
 TYPE(gtp_global_data) :: globaldata
\end{verbatim}
}

\subsection{The ELEMENT data type}

Elements are the building blocks of other data.  They have a symbol,
mass, reference state and some other values defined.

The elements in a system are stored in an array ELLISTA of these
records in the order they are entered.  Another integer array ELEMENTS
have the elements in alphabetical order.  These arrays are allocated
in the subroutine init\_gtp.

There are two predefined elements, the electron with symbol ``/-'' and
the vacancy with symbol ``Va''.  They have the indices -1 and 0.  All
real elements have numbers from 1 and higher.

The advantage with ELLISTA is that the element is stored at an index
which never change, it does not change when other elements are entered
which would change the alphabetical order.  Note that there is a
crossindex stored in ellista so it is possible to know the
alphabetical order of the element.

It also means there are 3 ways to specify an element, its symbol, its
alphabetical index (its index in ELEMENTS) and its index in ELLISTA.
The ELLISTA index is most important and it will never change whereas
the ELEMENTS index may change when new elements are entered that may
change the alphabetical order.  The link to an element from a species
are always the ELLISTA.

In the species record the stoichiometric formula is stored by giving
the index of the element in ellista.  As this never change no
rearrangement is needed if new elements are added.

The elements array is useful to make alphabetically ordered listing of
data.  Elements are normally never deleted but may be suspended
i.e. hidden from application programs (this cannot be allowed during
parallell processing).

{\small
\begin{verbatim}
 TYPE gtp_element
! data for each element: symbol, name, reference state, mass, h298-h0, s298
    character :: symbol*2,name*12,ref_state*24
    double precision :: mass,h298_h0,s298
! splink: index of corresponing species in array splink
! Status bits are stored in the integer status
! alphaindex: the alphabetical order of this elements
! refstatesymbol: indicates H0 (1), H298 (0, default) or G (2) for endmembers
    integer :: splink,status,alphaindex,refstatesymbol
 END TYPE gtp_element
! allocated in init_gtp
 TYPE(gtp_element), private, allocatable :: ellista(:)
 INTEGER, private, allocatable :: ELEMENTS(:)
\end{verbatim}
}

\subsection{Species}

Here some of the interesting features of Fortran08 data structuring
appears and can be explained.  The species have a name, mass and
charge as fixed attributes.  It also has a status word and a link back
to the array where the species are arranged in alphabetical order.  It
has an integer giving the number of elements in the species (must be
larger than zero).  Finally there are two arrays which have no size
specified in the declaration, these must be allocated when the species
is entered.  The reason to have arrays that can be allocated is that
some species has just one element, other may have two, three or more.
The dimension of these arrays are stored in noofel (It can actually
also be obtained by the Fortran08 build-in function SIZE).  The
indices stored in ellinks are the location, i.e. index to ellista.
This does not change even if the alphabetical order of elements is
changed.

For saving and reading a stored datastructure from a file it is
necessary to have the number of elements as a stored integer because
this is needed to allocate space for these arrays before reading the
content of these arrays from the file.  The SIZE function is useless
in that case.

One can declare arrays that should be allocated dynamically either as
ALLOCATABLE or POINTER.  I do not really understand the difference.

The species record is an interesting example of an array of structures
that in itself contains allocatable arrays that can vary in size
depending on the data stored there.  This feature will be utilized
extensivly when storing data for phases.

It is also a very interesting feature to use indices to other arrays
as links rather than pointers which is necessary in most other
languages with data structures.  There are pointers also in Fortran08
but pointers have a bad habit of being confusing and complicated to
use, one is never sure if one has the address of a pointer or the
content (which is also a memory address).

The integer array ``species'' has the species in alphabetical order by
providing the correct index to the SPLISTA.

{\small
\begin{verbatim}
 TYPE gtp_species
! data for each species: symnol, mass, charge, status
! mass is in principle redundant as calculated from element mass
    character :: symbol*24
    double precision :: mass,charge
! alphaindex: the alphabetical order of this species
! noofel: number of elements
    integer :: noofel,status,alphaindex
! Use an integer array ellinks to indicate the elements in the species
! The corresponing stoichiometry is in the array stochiometry
! ???? these should not be pointers, changed to allocatable ????
    integer, dimension(:), allocatable :: ellinks
    double precision, dimension(:), allocatable :: stoichiometry
 END TYPE gtp_species
! allocated in init_gtp
 TYPE(gtp_species), private, allocatable :: splista(:)
 INTEGER, private, allocatable :: SPECIES(:)
\end{verbatim}
}

\subsection{Components}

It will be possible to define different components for each
equilibrium.  A component must be a species.  Initially the species
identical to the elements are the components.  The components are part
of the ``gtp\_equilibrium\_data'' record and after a calculation the
chemimcal potentials are stored in these records.

{\small
\begin{verbatim}
 TYPE gtp_components
! The components are simply an array of indices to species records
! the components must be "orthogonal".  There is always a "systems components"
! that by default is the elements.
! Later one may implement that the user can define a different "system set"
! and also specific sets for each phase.
! The reference state is set as a phase and value of T and P.
! The name of the phase and its link and the link to the constituent is stored
! the endmember array is for the reference phase to calculate GREF
! The last calculated values of the chemical potentials (for user defined
! and default reference states) should be stored here.
    integer :: splink,phlink,status
    character*16 :: refstate
    integer, dimension(:), allocatable :: endmember
    double precision, dimension(2) :: tpref
    double precision, dimension(2) :: chempot
    double precision mass
 END TYPE gtp_components
! allocated in gtp_equilibrium_data
\end{verbatim}
}

\subsection{Phase datatypes}

The data stored for a phase is very complex.  The data are all
accessed from a phase root record (except when save/read from a file).
The phase has a phase\_varres record which is stored in the
gtp\_equilibrium\_data record that keeps the last calculated results
as this must be different in each different parallell process.  In
this record with all fraction variables (and some additional
information) that can be different for each parallell process is also
stored.  If the phase has two or more composition sets each of these
has its own phase\_varres record.  The phase\_varres records are an
array inside the gtp\_equilibrium\_data record and each phase store
the links to its composition sets by indices to this array.  This is
necessary as one can have several gtp\_equilibrium\_data records and
one must have the same number of composition sets for a phase in all.
In parallell computing new composition sets may be created and it must
be done for all threads at the same time.

The root record of a phase has data and links to all necessary
information listed here:

\begin{itemize}

\item The endmember record list.  There can be two endmember lists,
one for each fraction types.

\item The phase\_varres record representing a composition set.  Each
each phase kan have up to 9 composition sets.  The phase\_varres
records are declared as an array in the gtp\_equilibrium\_data record
because ech equilibrium must have a unique set of fractions and
results.  In this record there are also some status bits that may be
different in different parallell processes like if the phase
(composition set) is FIXED/ENTERED/etc.

A phase may exist simultaneously with different constituent fractions
like in a miscibility gap or when a phase can order. To identify a
composition set one can use the number symbol ``\#'' follwed by a
digit.  When the composition set is created one can also add a pre-
and suffix.

In the phase\_varres record thare are also arrays to store all
calculated G and its forst and second derivatives (also derivatives
with respect to fractions).  Calculated values of other properties
like TC, V, MQ etc (and their derivatives) are also stored if there
are parameters for these properties.

For the ionic liquid model the number of sites depend on the
constitution and thus there are also provisions to have the number of
sites on each sublattice in this record.

\item The addition list.  This is a pointer to an addition record
(there can be several linked sequentially).  The only current addition
record is used to specify the magnetic magnetic contribution and for
other additions new subroutines must be written to enter, list and
calculate the addtions.  See section~\ref{sec:addition}.
\end{itemize}

These records may in turn point to other records, as already mentioned
the endmember record has links to another endmember records and to an
interaction records and both of these records has a link to a list of
property records where there are links to TP functions.  Some of these
links are indexes to arrays of these records but for example the
parameters stored in endmember, interactions and property records are
created dynamically and can only be accessed by pointers.  The
property records have links to TP functions but these links are
indices to the array of TP function structure.  The reason to have an
array for these is that there are separate arrays with the calculated
results of the TP functions in the gtp\_equilibrium\_data record as
these must be local to each equilibrium, whereas the function
expressions are the same for all equilibria.

\subsubsection{Permutations of constituents}\label{sec:permutations}

A complication for endmembers and interaction records is to handle
permutations of constituents when one has ordering.  It is clumsy to
store identical permutation of constituents (like A:A:A:B, A:A:B:A,
A:B:A:A, B:A:A:A for a 4 sublattice FCC ordering) in separate
endmembers but one should have a single endmember for all
permutations.  It is necessary that the software can handle such
permutations for multicomponent systems, otherwise the databases must
contain several 1000 permutations of identical values of the same
perameter.  A 4 component FCC ordered system with 4 sublattices have
totally 256 endmembers but only 35 unique ones.

The permutations create complications also for the interaction records
which depend on the order of constituents in the endmember.  An
interaction records for an interaction between A and B belonging to an
end member A:A:A:A (which has no permutations) but there are 4
permutations of the interaction record (B can be in any of the 4
sublattices).  So each combination must be considered.

The second order interaction A,B:A,C:A:A this has 3 additional
permutations compared to the first order as the interaction with C can
be placed in any of the 3 remaining sublattices.  But the second order
interaction A,B:A,B:A:A has a more complicated permutations.  If the
first interaction with B is in the first sublattice, the second
interaction with B can be placed in any or the remaining 3 but if the
first level interaction in B is in the second sublattice the second
level interaction can only be in the third or forth.  In
Table~\ref{tab:perms} some permuations are shown.

\begin{center}
\begin{table}[!h]
\caption{Possible permutations of some endmembers and interaction
records.}\label{tab:perms}
\begin{tabular}{|lll|}\hline
endmember & 1st level interaction & 2nd level interaction\\\hline
A: A: A: A   & A,B: A: A: A             & A,B: A,B: A: A\\
             &                          & A,B: A: A,B: A\\
             &                          & A,B: A: A: A,B\\
             & A: A,B: A: A             & A: A,B: A,B: A\\
             &                          & A: A.B: A: A,B\\
             & A: A: A,B: A             & A: A: A,B: A,B\\
             & A: A: A: A,B             & no permutation\\\hline
A: A: A: B   & A,B: A: A: B             & A,B: A,B: A: B\\
             &                          & A,B: A: A,B: B\\
             & A: A,B: A: B             & A: A,B: A,B: B\\
             & A: A: A,B: B             & no permutation\\
A: A: B: A   & A,B: A: B: A             & A,B: A,B: B: A\\
             &                          & A,B: A: B: A,B\\
             & A: A,B: B: A             & A: A,B: B: A,B\\
             & A: A: B: A,B             & no permutation\\
etc. &&\\\hline
\end{tabular}
\end{table}
\end{center}

Reciprocal parameters like L(fcc,A,B:A,B:A:A) are important to
approximate the short range order contibutions to the Gibbs energy.

The permutations means some complications when entering parameters as
links to the fractions of all permutations are created at that stage.
It also means that all constituents must be ordered, always in
alphabetical order, so it is possible to find a parameter if its value
should be changed.  When calculating with the permutations the data
structure created when entering the parameter must contain information
on the number of permutations inherited from the endmember up to the
second level interaction.  For permutations no interactions higher
than the 2nd order are allowed.

In the first release of OC most of the permutations for the
tetrahedron 4 sublattice fcc (and hcp) ordering has been implemented.
The 4 sublattice bcc permutations are more complex and will be
implemented later.  All endmember permutations and all first level
level have been implemented but only a limted set of 2nd order
interactions, i.e. all for binary and ternary system.

An ordered phase will in many cases have a disordered fraction set for
the disordered state and there will be parameters which depend on
these fractions.  There can be endmembers and interaction parameters
for each fraction set.  The parameters for each fraction set will be
evaluated separately and added together at the end, taking into
account the chain rule for the derivatives.

\subsubsection{Property types for different fraction sets}\label{sec:fracsets}

An endmember or interaction can have several property records,
normally one for the Gibbs energy but also for Curie temperature,
mobilities etc.  But there can be endmembers and interaction records
without property records just because some higher interaction record
have a property record.

For mobilities one can use a special type of property that is specific
to a constituent like MQ\&FE.  In a property record one must have an
adjustable array for function links, for example when there are
several RK terms, see \ref{sec:Redlich-Kister}.  These links can be
allocated dynamically and if there are new RK terms added or deleted
this array can be extended or decreased dynamically.  For each
property record one can store a reference to the origin of the data.

I am not sure exactly how one should in listings identify parameters
belonging to different fraction sets.  In a SIGMA phase with 3
sublattices one will have endmember parameters for some like
G(SIGMA,FE:CR:FE), which are multiplied with the site fractions of
these constituents, $y^{(1)}_{\rm Fe}y^{(2)}_{\rm Cr}y^{(3)}_{\rm
Fe}$.  But we will also have a fraction set which in this case will be
identical to the mole fractions of Fe and Cr,

$x_{\rm Fe} = (10 y^{(1)}_{\rm Fe}+4y^{(2)}_{\rm Fe}+16y^{(3)}_{\rm Fe})/30$

An endmember parameter for this fraction set is currently specified as
GD(SIGMA,FE) and an interaction as GD(SIGMA,CR,FE).  If one considers
extending to several levels of fraction sets one should maybe use an
integer specification like G\#2(SIGMA,FE) etc.  In any cases a
property without specification will belong to the primary site
fraction set which is the major one, all other fractions are
calculated from these fractions.

For FCC ordering with interstitials the second fraction set will not be
mole fractions but the sum of the site fractions of the substitutional
sublattices

$z_{Fe} = 0.25 \sum_{s=1,4} y^{(s)}_{\rm Fe}$

\subsubsection{Selected\_element\_reference}

With Thermo-Calc it is has been a little awkward that one may not read
the normal reference phase for an element from the database.  For
example the gas phase may not be included for calculations with
nitrogen present but one would like to have partial pressures or
activities of nitrogen referenced to the gas.

An attempt to handle this has been made by entering by default a phase
called ``SELECT\_ELEMENT\_REFERENCE''.  This phase is always hidden
and cannot be included in any calculation.  Its location and index is
0 (zero) so it does not show up in the number of phases.  But the user
can list the data of this phase and also amend them.  The idea is that
a database will automatically enter the appropriate data for each
element in this phase and in calculations this phase will be the
default reference state for activities or enthalpies (at current
temperature).  One must have a phase and not just a TP function to
handle elements with magnetic transitions.  This reference phase is in
fact a different phase for each element, one must be able to use
different magnetic functions for different elements.  All details for
this are not worked out and it may not even be a very good idea.

\subsubsection{The endmember record}

As already described the phase record is a root of two lists of
endmembers, one for each of the two possible fraction sets.  The
endmember records are allocated by pointers when needed and contains
several links to other records:

\begin{itemize}
\item one link to the next endmember record,
\item one link to an interaction record, the root of a binary tree,
\item one link to a list of property records and
\item links to one constituent in each sublattice
\end{itemize}

All the links except those to the constituents may be empty.  The
links to the constituents are not real links but an integer index of
the array of constituents stored in the phase record (described
later).  The endmembers are always arranged in increasing value of
these indices, in the order of the sublattices.  The endmember
properties are multiplied with the fractions of these constituents
when a calculation is performed.

When the ordering options has been implemented, see
\ref{sec:permutations}, an endmember may have several permutations of
the constituent indices.  That is the reason to have two-dimensional
arrays for the constituent indices.

One may have endmembers that does not depend on the constituent in a
specific sublattice and this is represented by the fraction index for
this sublattice is negative, usually -99.  This is called a
``wildcard'' and represented by an asterix ``*'' when entering or
listing the parameter.

{\small
\begin{verbatim}
 TYPE gtp_endmember
! end member parameter record, note ordered phases can have
! several permutations of fraction pointers like for B2: (Al:Fe) and (Fe:Al).
! There are links (i.e. indices) to next end member and to the interactio tree
! and to a list of property record
! The phase link is needed for SAVE/READ as one cannot know the number of
! sublattices otherwise.  One could just store nsl but a link back to the
! phase record might be useful in other cases.
! noofpermut: number of permutations (for ordered phases: (Al:Fe) and (Fe:Al)
! phaselink: index of phase record
! antalem: sequenial order of creation, useful to keep track of structure
! propointer: link to properties for this endmember
! nextem: link to next endmember
! intponter: root of interaction tree of parameters
! fraclinks: indices of fractions to be multiplied with the parameter
    integer :: noofpermut,phaselink,antalem
    TYPE(gtp_property), pointer :: propointer
    TYPE(gtp_endmember), pointer :: nextem
    TYPE(gtp_interaction), pointer :: intpointer
! there is at least one fraclinks per sublattice
! the second index of fraclinks is the permutation (normally only one)
! the first indec of fraclinks points to a fraction for each sublattice.
! The fractions are numbered sequentially independent of sublattices, a
! sigma phase with (FE:CR,MO:CR,FE,MO) has 6 fractions (incl one for FE in
! first sublattice) and the end member (FE:MO:CR) has the fraclinks 1,3,4
! This means these values can be used as index to the array with fractions.
! The actual species can be found via the sublattice record
!    integer, dimension(:,:), pointer :: fraclinks
    integer, dimension(:,:), allocatable :: fraclinks
 END TYPE gtp_endmember
! dynamically allocated when entering a parameter
\end{verbatim}
}

\subsubsection{The interaction record}

The interaction records forms a binary tree starting from an endmember
record.  It thus has two pointers to other interaction records, one
which is the {\em next} on the same interaction level, excluding the
interacting constituent in the current record, and one to a {\em
higher} level, including the current interacting constituent.  In this
way any level of interaction parameter can be defined.  However, only
the first two levels (binary and ternary) can be composition
dependent, see \ref{sec:Redlich-Kister}.

There is also a link to a list of property records.  This link can be
empty if there is a link to a higher order interaction.

The interaction record specifies one additional constituent in a
sublattice.  The remaining constituents are given by the endmember
record and any lower interaction records with a higher link to this
one.  Again one can have permutations of this interacting constituent
in the different sublattices, see section~\ref{sec:permutations}.

The interaction records are always linked from the first possible
endmember, i.e. that with the lowest set of constituent indices in all
sublattices.  If there are several levels of interactions the lowest
interaction has the lowest constituent index.  There is no ordering of
interacting constituents on the same level.

{\small
\begin{verbatim}
 TYPE gtp_interaction
! this record constitutes the parameter tree. There are links to NEXT
! interaction on the same level (i.e. replace current fraction) and
! to HIGHER interactions (i.e. includes current interaction)
! There can be several permutations of the interactions (both sublattice
! and fraction permuted, like interaction in B2 (Al:Al,Fe) and (Al,Fe:Al))
! The number of permutations of interactions can be the same, more or fewer
! comparaed to the lower order parameter (endmember or other interaction).
! The necessary information is stored in noofip.  It is not easy to keep
! track of permutations during calculations, the smart way to store the last
! permutation calculated is in this record ... but that will not work for
! parallell calsulations ...
! status: may be useful eventually
! antalint: sequential number of interaction record, to follow the structure
! order: for permutations one must have a sequential number in each node
! propointer: link to properties for this parameter
! nextlink: link to interaction on same level (replace interaction)
! highlink: link to interaction on higher level (include this interaction)
! sublattice: (array of) sublattices with interaction fraction
! fraclink: (array of) index of fraction to be multiplied with this parameter
! noofip: (array of) number of permutations, see above.
    integer status,antalint,order
    TYPE(gtp_property), pointer :: propointer
    TYPE(gtp_interaction), pointer :: nextlink,highlink
    integer, dimension(:), allocatable :: sublattice,fraclink,noofip
 END TYPE gtp_interaction
! allocated dynamically and linked from endmember records
\end{verbatim}
}

\subsubsection{The property record}\label{sec:proprec}

The endmembers and interaction records is the start of a list of
property records.  A property list can be empty if an endmember or
interaction record is needed to specify some higher interaction.

There is a property index, see \ref{sec:propertydefs} and a {\em
nextpr} link to another property record.  One can have a link to a
reference for the parameter (published paper or similar), see
\ref{sec:dataref}.

The actual value of the property is stored as an index to a TP
function.  These functions are stored in array and cannot be deleted
(but they can be changed) so the index is a stable link.  The
calculated values of a property is stored in another array, local to
the equilibrium record, see \ref{sec:equilibriumrec}, as one may have
different values in each thread in parallel processing or when running
assessments, as these use different equilibrium records.

For binary and ternary interactions one can have a degree larger than
zero which means there are several TP functions linked to this
property.  See \ref{sec:Redlich-Kister}.

{\small
\begin{verbatim}
 TYPE gtp_property
! This is the property record.  The end member and interaction records
! have pointer to this.  Severall different properties can be linked
! from a parameter record like G, TC, BMAGN, VA, MQ etc.
! Some properties are connected to a constituent (or component?) like the
! mobility and also the Bohr mangneton number.
! Allocated as linked from endmembers and interaction records
! reference: can be used to indicate the source of the data
! refix: can be used to indicate the source of the data
! nextpr: link to next property record
! extra: TOOP and KOHLER can be implemented inside the property record
! proptype: type of propery, 1 is G, other see parameter property
! degree: if parameter has Redlich-Kister or similar degrees (powers)
! degreelink: indices of TP functions for different degrees (0-9)
! protect: can be used to prevent listing of the parameter
! antalprop: probably redundant (from the time of arrays of propery records)
    character*16 reference
    TYPE(gtp_property), pointer :: nextpr
    integer proptype,degree,extra,protect,refix,antalprop
    integer, dimension(:), allocatable :: degreelink
 END TYPE gtp_property
! property records, linked from endmember and interaction records, allocated
! when needed.  Each propery like G, TC, has a property record linking
! a TPFUN record (by index to tpfun_parres)
\end{verbatim}
}

\subsubsection{Data reference}\label{sec:dataref}

It is important to document the source of the data and each property
can have a unique reference stored in this record.  It would typcally
be a published paper or some internal documentation.

{\small
\begin{verbatim}
 TYPE gtp_datareference
! store data references
! reference: can be used for search of reference
! refspec: free text
    character*16 reference
    character*64, dimension(:), allocatable :: refspec
 END TYPE gtp_datareference
! allocated in init_gtp
 TYPE(gtp_datareference), private, allocatable :: reflista(:)
\end{verbatim}
}

\subsubsection{Parameter property identification}\label{sec:propid}

The propery list has an index and the meaning of this index is given
the gtp\_propid record.  A few of these are predefined but a
programmer can add more, see section~\ref{sec:paramid}.  For any added
property software must also be written to handle such properties
during calculations.  The implemented properties can be listed, see
\ref{sec:listavailprop} and the values of these properties can be
listed similarly like for state variables, see \ref{sec:listpropval}.

{\small
\begin{verbatim}
 TYPE gtp_propid
! this identifies different properties that can depend on composition
! Property 1 is the Gibbs energy and the others are usually used in
! some function to contribute to the Gibbs energy like TC or BMAGN
! But one can also have properties used for other things like mobilities
! with additional especification like MQ&FE
! symbol: property identifier like G for Gibbs energy
! note: short description for listings
! prop_elsymb: additional for element dependent properties like mobilities
    character symbol*4,note*16,prop_elsymb*2
! Each property has a unique value of idprop.  Status can state if a property
! has a constituent specifier or if it can depend on T or P
    integer status
! this can be a constituent specification for Bohr mangetons or mobilities
! such specification is stored in the property record, not here
!    integer prop_spec,listid
! >>> added "listid" as a conection to the "state variable" listing here.
! This replaces TC, BMAG, MQ etc included as "state variables" in order to
! list their values.  In this way all propids become available
 end TYPE gtp_propid
! the value TYPTY stored in property records is "idprop" or
! if IDELSUFFIX set then 100*"idprop"+ellista index of element
! if IDCONSUFFIX set then 100*"idprop"+constituent index
! When the parameter is read the suffix symbol is translated to the
! current element or constituent index
 TYPE(gtp_propid), dimension(:), private, allocatable :: propid
\end{verbatim}
}

\subsubsection{Additions to the Gibbs energy}\label{sec:addition}

Different contributions to the Gibbs energy can be specified in the
software using the data structure below.  Such additions normally
depend on a number of composition dependent properties like the Curie
temperature, the Bohr magneton number, the Debye temperature etc.
These can be added as properties and entered as endmember and
interaction parameters with a unique index and symbol see
\ref{sec:propid}.

When implementing a new addition subroutines must be written for
entering, listing and calculating the property, including analythical
first and second derivatives with respect to $T, P$ and the
constitution.

One may also add properties that does not contributre to the Gibbs
energy but depend on the constitution of the phase, like mobilities,
viscosities, resistivity etc.  Such properties are calculated together
with the Gibbs energy and their values can be extracted by appropriate
subroutines.

{\small
\begin{verbatim}
 TYPE gtp_phase_add
! record for additions to the Gibbs energy for a phase like magnetism
! addrecno: ?
! aff: antiferomagnetic factor (Inden model)
! need_property: depend on these properties (like Curie T)
! explink: function to calculate with the properties it need
! nextadd: link to another addition
    integer type,addrecno,aff
    integer, dimension(:), allocatable :: need_property
    TYPE(tpfun_expression), dimension(:), pointer :: explink
    TYPE(gtp_phase_add), pointer :: nextadd
    type(gtp_elastic_modela), pointer :: elastica
 END TYPE gtp_phase_add
! allocated when needed and linked from phase record
\end{verbatim}
}

\subsubsection{The elastic model}

This is a tentative record to model elastic contributions.

{\small
\begin{verbatim}
! addition record to calculate the elastic energy contribution
! declared as allocatable in gtp_phase_add
 TYPE gtp_elastic_modela
! lattice parameters (configuration) in 3 dimensions
    double precision, dimension(3,3) :: latticepar
! epsilon in Voigt notation
    double precision, dimension(6) :: epsa
! elastic constant matrix in Voigt notation
    double precision, dimension(6,6) :: cmat
! calculated elastic energy addition (with derivative to T and P?)
    double precision, dimension(6) :: eeadd
! maybe more
 end TYPE gtp_elastic_modela
\end{verbatim}
}

\subsubsection{The phase record}

We have finally reached the phase record itself.  As this refers to
many of the structures above it is declared in the source code after
all of them and to simplify the updating of this documenation we
follow the order of the declarations in the source code.  It is
complicated enough already~...

The phase record had originally two parts but these have been merged
to a single record.  The link to the composition set data (the
phase\_varres record) has also recently been changed so the link to
all of them are stored in the phase record as an array of indices to
array of phase\_varres records in the equilibrium record.  The
phase\_varres record contains all {\em dynamic} data that change
during iterations and has also all calculated results.  The endmember
and interaction records contain the {\em static} data that does not
change (except the calculated values of all TP functions9 but this is
also stored the equilibrium record in the tp\_res array.

When a phase is created a link to a record in the phase\_varres array,
i.e. an integer index, is stored in the array linktocs(1).  If
additional composition sets are created they are stored sequentially
in the same array.  A phase cannot have more than 9 composition sets.

{\small
\begin{verbatim}
! a smart way to have an array of pointers used in gtp_phase
 TYPE endmemrecarray
    type(gtp_endmember), pointer :: p1
 end TYPE endmemrecarray
!
 TYPE gtp_phase
! this is the record for phase model data. It points to many other records.
! Phases are stored in order of creation in phlista(i) and can be found
! in alphabetical order through the array phases(i)
! For TC freaks: Treat index to phlista(i) as LOKPH in iws
! sublista is now removed and all data included in phlista
! sublattice and constituent data (they should be merged)
! The constitent link is the index to the splista(i), same function
! as LOKSP in iws.  Species in alphabetcal order is in species(i)
! One can allocate a dynamic array for the constituent list, done
! by subroutine create_constitlist.
! Note that the phase has a dynamic status word status2 in gtp_phase_varres
! which can be differnt in different parallell calculations.
! This status word has the FIX/ENT/SUS/DORM status bits for example
! name: phase name, note composition sets can have pre and suffixes
! model: free text
! phletter: G for gas, L for liquid
! alphaindex: the alphabetcal order of the phase (excluding gas and liquids)
    character name*24,models*72,phletter*1
    integer status1,alphaindex
! noofcs: number of composition sets,
! nooffs: number of fraction sets (replaces partitioned phases in TC)
    integer noofcs,nooffs
! additions: link to addition record list
! ordered: link to endmember record list
! disordered: link to endmember list for disordered fractions (if any)
    TYPE(gtp_phase_add), pointer :: additions
    TYPE(gtp_endmember), pointer :: ordered,disordered
! To allow parallel processing of endmembers, store a pointer to each here
    integer noemr,ndemr
    TYPE(endmemrecarray), dimension(:), allocatable :: oendmemarr,dendmemarr
!-----------------------------------------------------------------
! this used to be sublista but is now incorporated in gtp_phase !!!
! static data, contains pointers to constituent record and sites
! noofsubl: number if sublattices
! cslink: is index to first composition set (deleted)
! linktocs: array with indices to phase_varres records (to replace clink)
! tnooffr: total number of fractions (constituents)
! nooffr: array with number of constituents in each sublattice
! sites: array with site rations (? dynamic for ionic liquid)
! constitlist: indices of species that are constituents (in all soblattices)
    integer noofsubl,tnooffr
    integer, dimension(9) :: linktocs
    integer, dimension(:), allocatable :: nooffr
    double precision, dimension(:), allocatable :: sites
    integer, dimension(:), allocatable :: constitlist
! allocated in init_gtp.
 END TYPE gtp_phase
! NOTE phase with index 0 is the reference phase for the elements
! The array sublista is now merged into phlista
! allocated in init_gtp
 TYPE(gtp_phase), private, allocatable :: phlista(:)
 INTEGER, private, allocatable :: PHASES(:)
\end{verbatim}
}

\section{Error handling}

There is a global error code defined as part of the tpfunlib module.
It is accessed as gx\%bmperr.

There are error messages defined for the errors generated by GTP.

One should revise the error handling so each equilibrium has its own
error variable as different threads should not be interrupted by
an error in another thread.

An alternative method would be if one can define the error code as a
``local variable'' for each thread when starting a parallell process.
I think OMP has such a facility.  If it is a single global variable it
may not cost so much in time.  It would be very difficult to have an
error code belonging to the gtp\_equilibrium\_data record as the error
code can be set in subroutines that are declared before this record is
defined.

\section{Calculations}

So far we have decribed how to handle the data describing the
properties of a phase.  In order to calculate an equilibrium many
values, like the constituent fractions, amounts of phase, temperature
etc may change.  As mentioned several times we must also be able to
handle several separate equilibria, either as threads in parallell
computing or as experimental data in assessments.  Each of these
separate datasets are stored in a gtp\_equilibrium\_data record.

\subsection{Conditions}

We must also handle conditions set by the user.  Typically a condition
is a state variable equal to a value like T=1273 or w(c)=0.01.  At
present these are the only types of condition that are implemented but
the condition record has been designed to handle also expressions of
state variable like x(liq,fe)-x(bcc,fe)=0 to find a congruent
transformation and state variables equal to a symbolic value like
w(liq,b)=waver.

{\small
\begin{verbatim}
 TYPE gtp_condition
! these records form a circular list linked from gtp_equilibrium_data records
! each record contains a condition to be used for calculation
! it is a state variable equation or a phase to be fixed
! The state variable is stored as an integer with indices
! NOTE: some state variables cannot be used as conditions: Q=18, DG=19, 25, 26
! There can be several terms in a condition (like x(liq,c)-x(fcc,c)=0)
! noofterms: number of terms in condition expression
! statev: the type of state variable (must be the same in all terms)
!           negative value of statev means phase index for fix phase
! active: zero if condition is active, nonzero for other cases
! unit: is 100 if value in percent, can also be used for temperature unit etc.
! nid: identification sequential number (in order of creation), redundant
! iref: part of the state variable (iref can be comp.set number)
! iunit: ? confused with unit?
! symlink: index of symbol for prescribed value (1) and uncertainity (2)
! condcoeff: there is a coefficient and set of indices for each term
! prescribed: the prescribed value
! NOTE: if there is a symlink value that is the prescribed value
! current: the current value (not used?)
! uncertainity: the uncertainity (for experiments)
    integer :: noofterms,statev,active,unit,nid,iref,iunit
!    TYPE(putfun_node), pointer :: symlink1,symlink2
! better to let condition symbol be index in svflista array
    integer symlink1,symlink2
    integer, dimension(:,:), allocatable :: indices
    double precision, dimension(:), allocatable :: condcoeff
    double precision prescribed, current, uncertainity
    TYPE(gtp_condition), pointer :: next, previous
 end TYPE gtp_condition
! declared inside the gtp_equilibrium_data record
\end{verbatim}
}

\subsection{State variables}

Conditions and results are obtained as values of state variables.
There are many of these like $G, H, T, x(<{\rm component}>)$ etc.
They are stored in the software as a record of the type below where
istv is an integer giving the basic type and indices can give
additional specification.  Some properties like chemical potentials
can have a reference state and one can also define a unit like Kelvin
or calories.  At present this is used only to specify if a composition
variable is a fraction or a percent.

{\small
\begin{verbatim}
 TYPE gtp_state_variable
! this is to specify a formal or real argument to a function of state variables
! istv: state variable index
! indices: additional specifiers like phase, component, etc.
! iref: if a specified reference state (for chemical potentials)
! iunit: 100 for percent
    integer istv,indices(4),iref,iunit
 end TYPE gtp_state_variable
! declared inside gtp_function
\end{verbatim}
}

\subsection{State variable functions}

In this record the description of a state variable funtion is stored.
The actual expression is stored using the PUTFUN subroutine in the
metlib package.  The calculated results of a state variable function
is stored as a double precision array svfunres in the equilibrium data
record.  State variable function values are a single value, not 6 as
for the TPfuns, as they cannot be derivated with respect to anything.

The ``dot'' expression available in Thermo-Calc has not yet been
implemented.

{\small
\begin{verbatim}
  TYPE gtp_putfun_lista
! these are records for state variable functions.  The function itself
! is handelled by the putfun package.
! linkpnode: pointer to start node of putfun expression
! narg: number of symbols in the function
! nactarg: number of actual parameter specifications needed in call
!   (like @P, @C and @S
! status: can be used for various things
! status bit SVFVAL=0 means value evaluated only when called with mode=1
! eqnoval: used to specify the equilibrium the value should be taken from
!    (for handling what is called "variables" in TC)
! name: name of symbol
     integer narg,nactarg,status,eqnoval
     type(putfun_node), pointer :: linkpnode
     character name*16
! this array has identification of state variable (and other function) symbols
     integer, dimension(:,:), pointer :: formal_arguments
  end TYPE gtp_putfun_lista
! this is the global array with state variable functions
  TYPE(gtp_putfun_lista), dimension(:), allocatable :: svflista
! NOTE the value of a function is stored locally in each equilibrium record
! in array svfunres.
! The number of entered state variable functions. Used to store a new one
  integer, private :: nsvfun
\end{verbatim}
}

\subsection{Fraction sets}

A phase can have several composition sets, meaning that it can be
stable with two or more different compositions.  A phase can also have
two fraction sets, explained in more detail in \ref{sec:fracsets}.

\small{
\begin{verbatim}
 TYPE gtp_fraction_set
! info about disordred fractions for some phases like ordered fcc, sigma etc
! latd: the number of sublattices added to first disordred sublattice
! ndd: sublattices for this fraction set,
! tnoofxfr: number of disordered fractions
! tnoofyfr: same for ordered fractions (=same as in phlista).
! varreslink: index of disordered phase_varres,
! phdapointer: pointer to the same phase_varres record as varreslink
!    (Note that there is a bit set indicating that the sublattices should
!    be taken from this record)
! totdis: 0 indicates no total disorder (sigma), 1=fcc, bcc or hcp
! id: parameter suffix, D for disordered
! dsites: number of sites in sublattices, disordred fractions stored in
!    another phase_varres record linked from phdapointer
! splink: pointers to species record for the constituents
! nooffr: the number of fractions in each sublattice
! y2x: the conversion from sublattice constituents to disordered and
! dxidyj: are the the coeff to multiply the y fractions to get the disordered
!        xfra(y2x(i))=xfra(y2x(i))+dxidyj(i)*yfra(i)
! disordered fractions stored in the phase_varres record with index varreslink
!    (also pointed to by phdapointer).  Maybe phdapointer is redundant??
! arrays originally declared as pointers now changed to allocatable
    integer latd,ndd,tnoofxfr,tnoofyfr,varreslink,totdis
    character*1 id
    double precision, dimension(:), allocatable :: dsites
    integer, dimension(:), allocatable :: nooffr
    integer, dimension(:), allocatable :: splink
    integer, dimension(:), allocatable :: y2x
    double precision, dimension(:), allocatable :: dxidyj
! in parallel processing the disordered phase_varres record is linked
! by this pointer,  used in parcalcg and calcg_internal
    TYPE(gtp_phase_varres), pointer :: phdapointer
 END TYPE gtp_fraction_set
! these records are declared in the phase_varres record as DISFRA for
! each composition set and linked from the phase_varres record
\end{verbatim}
}

\subsection{The phase\_varres record for composition sets}

Each composition set of a phase has a record as described below.  It
contains all data that can vary during calculations like the
constituent fractions, the amount of the phase, etc.  It also contains
all results from a calculation.  An array phase\_varres is allocated
in the gtp\_equilibrium\_record for this purpose and in the phase
record there are indices to the phase\_varres records for its
composition sets.

As composition sets can be created and deleted there is a free list
maintained using the integer {\em nextfree}.  The first free
phase\_varres record is given by the global variable csfree.  This
list is maintained in the first equilibrium record, which is pointed
to by the global variable FIRSTEQ.

\small{
\begin{verbatim}
 TYPE gtp_phase_varres
! Data here must be different in equilibria representing different experiments
! or calculated in parallel or results saved from step or map.
! nextfree: In unused phase_varres record it is the index to next free record
!    The global integer csfree is the index of the first free record
! phlink: is index of phase record for this phase_varres record
! status2: has phase status bits like ENT/FIX/SUS/DORM
! constat: array with status word for each constituent, any can be suspended
! yfr: the site fraction array
! mmyfr: min/max fractions
! abnorm(1): amount moles of atoms for a formula unit of the composition set
! abnorm(2): amount in mass of the formula unit (both set by set_constitution)
! sites: site ratios (which can vary for ionic liquids)
! prefix and suffix are added to the name for composition sets 2 and higher
! disfra: a structure describing the disordered fraction set (if any)
    integer nextfree,phlink,status2
    double precision, dimension(2) :: abnorm
    character*4 prefix,suffix
! for ionic liquid derivatives of sites wrt fractions
!    double precision, dimension(:,:), pointer :: dsitesdy
!    double precision, dimension(:,:), pointer :: d2sitesdy2
! changed to allocatable
    integer, dimension(:), allocatable :: constat
    double precision, dimension(:), allocatable :: yfr
    real, dimension(:), allocatable :: mmyfr
    double precision, dimension(:), allocatable :: sites
! for ionic liquid derivatives of sites wrt fractions
    double precision, dimension(:,:), allocatable :: dsitesdy
    double precision, dimension(:,:), allocatable :: d2sitesdy2
! for extra fraction sets, better to go via phase record index above
! this TYPE(gtp_fraction_set) variable is a bit messy.  Declaring it in this
! way means the record is stored inside this record.
    type(gtp_fraction_set) :: disfra
! It seems difficult to get the phdapointer in disfra record to work
! ---
! arrays for storing calculated results for each phase (composition set)
! amount(1): is amount formula units of the composition set (calculated result)
! amount(2): is net charge of phase
! dgm: driving force (calculated result)
! amcom: not used
! damount: set to last change of phase amount in equilibrium calculations
! qqsave: values of qq calculated in set_constitution
    double precision amount(2),dgm,amcom,damount,qqsave(3)
! Other properties may be that: gval(*,2) is TC, (*,3) is BMAG, see listprop
! nprop: the number of different properties (set in allocate)
! ncc: total number of site fractions (redundant but used in some subroutines)
! listprop(1): is number of calculated properties
! listprop(2:listprop(1)): identifies the property stored in gval(1,ipy) etc
!   2=TC, 3=BMAG. Properties defined in the gtp_propid record
    integer nprop,ncc
    integer, dimension(:), allocatable :: listprop
! gval etc are for all composition dependent properties, gval(*,1) for G
! gval(*,1): is G, G.T, G.P, G.T.T, G.T.P and G.P.P
! dgval(1,j,1): is first derivatives of G wrt fractions j
! dgval(2,j,1): is second derivatives of G wrt fractions j and T
! dgval(3,j,1): is second derivatives of G wrt fractions j and P
! d2gval(ixsym(i,j),1): is second derivatives of G wrt fractions i and j
    double precision, dimension(:,:), allocatable :: gval
    double precision, dimension(:,:,:), allocatable :: dgval
    double precision, dimension(:,:), allocatable :: d2gval
! added for strain/stress, current values of lattice parameters
    double precision, dimension(3,3) :: curlat
! saved values from last equilibrium calculation
!    double precision, dimension(:), allocatable :: dsf
    double precision, dimension(:,:), allocatable :: cinvy
    double precision, dimension(:), allocatable :: cxmol
    double precision, dimension(:,:), allocatable :: cdxmol
 END TYPE gtp_phase_varres
! this record is created inside the gtp_equilibrium record
\end{verbatim}
}

\subsection{The equilibrium record}\label{sec:equilibriumrec}

The equilibrium record has all data that may change dynamically during
a calculation.  One may have several equilibrium records and during
parallell computing each thread must have one.  Also during
assessments each experimental data is stored in a separate equilibrium
record as it has its unique set of conditions.

{\small
\begin{verbatim}
 TYPE gtp_equilibrium_data
! this contains all data specific to an equilibrium like conditions,
! status, constitution and calculated values of all phases etc
! Several equilibria may be calculated simultaneously in parallell threads
! so each equilibrium must be independent
! NOTE: the error code must be local to each equilibria!!!!
! During step and map thses records with results are saved
! values of T and P, conditions etc.
! Values here are normally set by external conditions or calculated from model
! local list of components, phase_varres with amounts and constitution
! lists of element, species, phases and thermodynamic parameters are global
! tpval(1) is T, tpval(2) is P, rgas is R, rtn is R*T
! status: not used yet?
! gtperr: local errr code (not used yet)
! eqno: sequential number assigned when created
! next: ?
! eqname: name of equilibrium
! tpval: value of T and P
! rtn: value of R*T
    integer status,gtperr,eqno,next
    character eqname*24
    double precision tpval(2),rtn
! this array has the local results of the state variable functions
! svfunres: the values of state variable functions for this equilibrium
    double precision, dimension(:), allocatable :: svfunres
! the experiments are used in assessments and stored like conditions
! lastcondition: link to condition list
! lastexperiment: link to experiment list
    TYPE(gtp_condition), pointer :: lastcondition,lastexperiment
! components and conversion matrix from components to elements
! complist: array with components
! compstoi: stoichiometric matrix of compoents relative to elements
! invcompstoi: inverted stoichiometric matrix
    TYPE(gtp_components), dimension(:), allocatable :: complist
    double precision, dimension(:,:), allocatable :: compstoi
    double precision, dimension(:,:), allocatable :: invcompstoi
! one record for each phase that can be calculated
! index in this array is the same as in sublat record
! phase_varres: here all data for the phase is stored
    TYPE(gtp_phase_varres), dimension(:), allocatable :: phase_varres
! index to the tpfun_parres array is the same as in the global array tpres
! eq_tpres: here calculated values of TP functions are stored
    TYPE(tpfun_parres), dimension(:), pointer :: eq_tpres
! current values of chemical potentials stored in component record
! xconc: convergence criteria for constituent fractions and other things
    double precision xconv
! delta-G value for merging gridpoints in grid minimizer
! smaller value creates problem for test step3.BMM, MC and austenite merged
    double precision :: gmindif=-5.0D-2
! maxiter: maximum mnumber of iterations allowed
    integer maxiter
 END TYPE gtp_equilibrium_data
! The primary copy of this structures is declared globally as FIRSTEQ here
! Others may be created when needed for storing experimental data or
! for parallel processing. A global array of these are
! TYPE(gtp_equilibrium_data), dimension(:), allocatable, target :: eqlista
 TYPE(gtp_equilibrium_data), dimension(:), allocatable, target :: eqlista
 TYPE(gtp_equilibrium_data), pointer :: firsteq
\end{verbatim}
}

\section{Records with data shared by several subroutines}

The records below have no global variables but are used in some of the
calculating subroutines to store complex temporary data, almost like
an oldfashioned COMMON area but it is declared inside a subroutine and
passed as an argument to the different subroutines.

\subsection{Parsing data}

The data in this record is used parsing the endmember lista and the
binary interaction tree.

{\small
\begin{verbatim}
! for each permutation in the binary interaction tree of an endmember one must
! keep track of the permutation and the permutation limit.
! It is not possible to push the value on pystack as one must remember
! them when changing the endmember permutation
! integer, parameter :: permstacklimit=150
 TYPE gtp_parcalc
! This record contains temporary data that must be separate in different
! parallell processes when calculating G and derivatives for any phase.
! There is nothing here that need to be saved after the calculation is finished
! global variables used when calculating G and derivaties
! sublattice with interaction, interacting constituent, endmember constituents
! PRIVATE inside this structure not liked by some compilers....
! endcon must have maxsubl dimension as it is used for all phases
    integer :: intlat(maxinter),intcon(maxinter),endcon(maxsubl)
! interaction level and number of fraction variables
    integer :: intlevel,nofc
! explained above, used for FCC and BCC permutations
!    integer, dimension(permstacklimit) :: lastperm,permlimit
! interacting constituents (max 4) for composition dependent interaction
! iq(j) indicate interacting constituents
! for binary RK+Muggianu iq(3)=iq(4)=iq(5)=0
! for ternary Muggianu in same sublattice iq(4)=iq(5)=0
! for reciprocal composition dependent iq(5)=0
! for Toop, Kohler and simular iq(5) non-zero (not implemented)
    integer :: iq(5)
! fraction variables in endmember (why +2?) and interaction
    double precision :: yfrem(maxsubl+2),yfrint(maxinter)
! local copy of T, P and RT for this equilibrium
    double precision :: tpv(2),rgast
!    double precision :: ymin=1.0D-30
 end TYPE gtp_parcalc
! this record is declared locally in subroutine calcg_nocheck
\end{verbatim}
}

\subsection{Fraction product stack}

The product of the constituent fractions and their derivatives must be
saved now and again during the parsing.  The record below is used for
that.

{\small
\begin{verbatim}
   TYPE gtp_pystack
! records created inside the subroutine push/pop_pystack
! data stored during calculations when entering an interaction record
! previous: link to previous record in stack
! ipermutsave: permutation must be saved
! intrecsave: link to interaction record
! pysave: saved value of product of all constituent fractions
! dpysave: saved value of product of all derivatives of constituent fractions
! d2pysave: saved value of product of all 2nd derivatives of constit fractions
      TYPE(gtp_pystack), pointer :: previous
      integer :: pmqsave
      TYPE(gtp_interaction), pointer :: intrecsave
      double precision :: pysave
      double precision, dimension(:), allocatable :: dpysave
      double precision, dimension(:), allocatable :: d2pysave
   end TYPE gtp_pystack
! declared inside the calcg_internal subroutine
\end{verbatim}
}

\section{Global variables}

The variables below contain some information used in several
subroutines.  Additionally many of the record types described earlier
are declared as privste arrays to protect them somewhat.

{\small
\begin{verbatim}
! counters for elements, species and phases initiated to zero
 integer, private :: noofel=0,noofsp=0,noofph=0
! counters for property and interaction records, just for fun
 integer, private :: noofprop,noofint,noofem
! free lists in phase_varres records and addition records
 integer, private :: csfree,addrecs
! free list of references and equilibria
 integer, private :: reffree,eqfree
! maximum number of properties calculated for a phase
 integer, private :: maxcalcprop=20
! highest used phase_varres record (for saving on file)
 integer, private :: highcs
! Trace for debugging (not used)
 logical, private :: ttrace
! minimum constituent fraction
 double precision :: bmpymin
! number of defined property types like TC, BMAG etc
 integer, private :: ndefprop
\end{verbatim}
}

%%%%%%%%%%%%%%%%%% here starts pmod25A.F90

\section{Subroutines and functions}

It is not self evident how to organise the description of the
subroutines in GTP.  One can base it on the type of service the
subroutine provies like entering data, listing data, calculating or on
the type of object the action is performed on like on elements,
phases, additions etc.  A mixed approach is made here where `''find'',
`enter'' and ``list'' subroutines operating on general objects are
grouped together whereas subroutines specific for ``state variables'',
``additions'' and simlar things are grouped together for all services
like enterring, listing and calculations.  One reason is that when a
new addition is implemented all of these services must be provided
together so it is natural to keep them together also in the
documentation as a programmer has to provide new subroutines for all
of them.

\subsection{Variable names}

The arguments for the subroutines and functions are normally explained but
some standards have been used

\begin{tabular}{lll}
Symbol & Type & Meaning\\\hline
iph    & integer & Phase index in PHASES\\
ics    & integer & Composition set number\\
lokph  & integer & Phase location (index to PHLISTA)\\
lokcs  & integer & Index of PHASE\_VARRES array for a composition set\\
ceq    & pointer & Pointer to current gtp\_equilibrium\_data  record\\
\end{tabular}

\subsection{Initiallization}

This subroutine must be called before any other in the GTP pacjage.
It dimensions arrays and creates some initial data structures.

{\small
\begin{verbatim}
 subroutine init_gtp
! initiate the data structure
! create element and species record for electrons and vacancies
! the allocation of many arrays should be provided calling this routne
\end{verbatim}
}

\subsection{Functions to know how many}

The counters for elements etc are private so external software
must call functions to find out how many elements etc that the
system has.  They are all given here.

{\small
\begin{verbatim}
 integer function noel()
! number of elements because noofel is private
! should take care if elements are suspended
 integer function nosp()
! number of species because noofsp is private
! should take care if species are suspended
 integer function noph()
! number of phases because noofph is private
! should take care if phases are hidden
 integer function noofcs(iph)
! returns the number of compositions sets for phase iph
   implicit none
   integer iph
 integer function noconst(iph,ics,ceq)
! number of constituents for iph (include single constituents on a sublattice)
! It tests if a constituent is suspended which can be different in each ics.
   implicit none
   integer iph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{How many state variable functions}

The number of state variable functions entered is given by this.

{\small
\begin{verbatim}
 integer function nosvf()
! number of state variable functions
\end{verbatim}
}

\subsubsection{How many equilibria}

There is a global array with equilibria records but only a few of them
may be allocated with data.  This routine returnes the number of
allocated equilibrium records.

{\small
\begin{verbatim}
 integer function noeq()
! returns the number of equilibria entered
\end{verbatim}
}

\subsection{Find things}

These subroutines translate from name to index or location of data or
vice versa.  There are other some ``find'' subroutines for special
things like find\_gridmin described in \ref{sec:findgridmin}.

{\small
\begin{verbatim}
 subroutine find_element_by_name(name,iel)
! find an element index by its name
   implicit none
   character name*(*)
   integer iel
 subroutine find_component_by_name(name,icomp,ceq)
! BEWARE: one may in the future have different components in different
! equilibria. components are a subset of the species
   implicit none
   character*(*) name
   integer icomp
   TYPE(gtp_equilibrium_data), pointer :: ceq
 subroutine find_species_by_name(name,isp)
! locates a species index from its name
   implicit none
   character name*(*)
   integer isp
 subroutine find_species_record(name,loksp)
! locates a species record allowing abbreviations
   implicit none
   character name*(*)
   integer loksp
 subroutine find_species_record_noabbr(name,loksp)
! locates a species record no abbreviations allowed
   implicit none
   character name*(*)
   integer loksp
 subroutine find_species_record_exact(name,loksp)
! locates a species record, exact match needed
! for parameters, V must not be accepted as abbreviation of VA or C for CR
   implicit none
   integer loksp
   character name*(*)
 subroutine find_phase_by_name(name,iph,ics)
! finds a phase with name "name", returns address of phase, first fit accepted
! handles composition sets either with prefix/suffix or #digit
! no pre/suffix nor # gives first composition set
   implicit none
   character name*(*)
   integer iph,ics
 subroutine find_phase_by_name_exact(name,iph,ics)
! finds a phase with name "name", returns address of phase. exact match req.
! handles composition sets either with prefix/suffix or #digit
! no pre/suffix nor # gives first composition set
   implicit none
   character name*(*)
   integer iph,ics
\end{verbatim}
}

\subsubsection{Find constituent name}

This subroutine returns the index and mass of a constituent in a
specific phase.  If the same constituent can occur on several
sublattices the sublattice must be specified by a \# followed by a
digit 1 to 9.

{\small
\begin{verbatim}
 subroutine find_constituent(iph,spname,mass,icon)
! find the constituent "spname" of a phase. spname can have a sublattice #digit
! Return the index of the constituent in icon.  Additionally the mass
! of the species is returned.
   implicit none
   character*(*) spname
   double precision mass
   integer iph,icon
\end{verbatim}
}

\subsubsection{Find and select equilibrium}

{\small
\begin{verbatim}
 subroutine findeq(name,ieq)
! finds the equilibrium with name "name" and returns its index
   implicit none
   character name*(*)
   integer ieq
 subroutine selecteq(ieq,ceq)
! checks if equilibrium ieq exists and if so set it as current
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer ieq
\end{verbatim}
}

\subsection{Get things}

The difference between find and get is not very distinct.  Normally
the ``find'' routines requires a name or symbol to return an index or
location whereas the ``get'' routines require an index or location to
get more data.  Some of the ``get'' routines are very specific and
described together with the type of data you want to get.

{\small
\begin{verbatim}
 subroutine get_phase_record(iph,lokph)
! given phase index iph this returns the phase location lokph
   implicit none
   integer iph,lokph
 subroutine get_phase_variance(iph,nv)
! returns the number of independent variable fractions in phase iph
   implicit none
   integer iph,nv
 subroutine get_phase_compset(iph,ics,lokph,lokcs)
! Given iph and ics the phase and composition set locations are returned
! Checks that ics and ics are not outside bounds.
   implicit none
   integer iph,ics,lokph,lokcs
 subroutine get_constituent_name(iph,iseq,spname,mass)
! find the constituent with sequential index iseq in phase iph
! return name in "spname" and mass in mass
   implicit none
   character*(*) spname
   integer iph,iseq
   double precision mass
\end{verbatim}
}

\subsubsection{Get phase constituent name}

This subroutine is redundant, the get\_constituent\_name should be
used instead.

{\small
\begin{verbatim}
 subroutine get_phase_constituent_name(iph,icon,name)
! return the name of constituent icon of phase iph
! redundant?
   implicit none
   character*(*) name
   integer iph,icon
\end{verbatim}
}

\subsubsection{Get element data}

The data for an element is returned.

{\small
\begin{verbatim}
 subroutine get_element_data(iel,elsym,elname,refstat,mass,h298,s298)
! return element data as that is stored as private in GTP
   implicit none
   character elsym*2, elname*(*),refstat*(*)
   double precision mass,h298,s298
   integer iel
\end{verbatim}
}

\subsubsection{Get component or species name}

Components are by default the elements but the user can (sometimes in
the future) change this to any set of species (that are orthogonal).
Each equilibrium will be able to have a different set of components.

The set of components are important because one can only use
components to set amounts of fractions with conditions like $N(<{\rm
components}>)$.  There is an alternative method to set amounts using
the subroutine set\_input\_amounts where amounts or mass of different
species can be used to give amounts of components.

{\small
\begin{verbatim}
 subroutine get_component_name(icomp,name,ceq)
! return the name of component icomp
   implicit none
   character*(*) name
   integer icomp
   TYPE(gtp_equilibrium_data), pointer :: ceq
 subroutine get_species_name(isp,spsym)
! return species name, isp is species number
   implicit none
   character spsym*(*)
   integer isp
\end{verbatim}
}

\subsubsection{Get species data}

A species is just a stoichiometric arrangement of elements like a
molecule.  It has no thermodynamic data as they are stored together
with the phase.  The stoichiometry of a species is fized.  The
composition of a phase can vary if there are two ore more species as
constituents in one or more sublattices.

{\small
\begin{verbatim}
 subroutine get_species_data(loksp,nspel,ielno,stoi,smass,qsp)
! return species data, loksp is from a call to find_species_record
! nspel: integer, number of elements in species
! ielno: integer array, element indices
! stoi: double array, stocichiometric factors
! smass: double, mass of species
! qsp: double, charge of the species
   implicit none
   integer, dimension(*) :: ielno
   double precision, dimension(*) :: stoi(*)
   integer loksp,nspel
   double precision smass,qsp
\end{verbatim}
}

\subsubsection{Mass of component}

For the mass balance calculations during equilibrium calculations
the mass of a component is needed frequently.  This subroutine
just returns the mass of a component.

{\small
\begin{verbatim}
 double precision function mass_of(component,ceq)
! return mass of component
! smass: double, mass of species
   implicit none
   integer :: component
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Get phase name}

The title says all.

{\small
\begin{verbatim}
 subroutine get_phase_name(iph,ics,name)
! Given the phase index and composition set number this subroutine returns
! the name with pre- and suffix for composition sets added and also
! a \# followed by a digit 2-9 for composition sets higher than 1.
   implicit none
   character name*(*)
   integer iph,ics
\end{verbatim}
}

\subsubsection{Get phase data}\label{sec:getphasedata}

This is a very important sibroutine used at each iteration during
calculations to obtain information about a phase.  In the knr array
the constitunents are given the integer value of the location of the
species in the array SPLISTA.  These are stored sequentially and the
first nkl(1) positions in knr belong to sublattice 1, the next nkl(2)
to sublattice 2 etc.  In yarr the fractions of the constituents are
given sequentially in the same order.

In the array qq the current number of components per formula unit is
returned in the first index and the current charge (valence) in the
second.

{\small
\begin{verbatim}
 subroutine get_phase_data(iph,ics,nsl,nkl,knr,yarr,sites,qq,ceq)
! return the structure of phase iph and constituntion of comp.set ics
! nsl: integer, number of sublattices
! nkl: integer array, number of constituents in each sublattice
! knr: integer array, species location (not index) of constituents (all subl)
! yarr: double array, fraction of constituents (in all sublattices)
! qq: double array, (must be dimensioned at least 5) although only 2 used:
! qq(1) is number of real atoms per formula unit for current constitution
! qq(2) is net charge of phase for current constitution
! ceq: pointer, to current gtp_equilibrium_data record
   implicit none
   integer, dimension(*) :: nkl,knr
   double precision, dimension(*) :: yarr,sites,qq
   integer iph,ics,nsl
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Get condition record}

A condition is typically a state variable assigned a value like
$T=1273$ but it can be much more complicated.  One can have conditions
like $x({\rm liquid,S})-x({\rm pyrrhotite,S})=0$ to specify the
congruent melting point of pyrrhotite.  A condition can also be that a
phase is fixed, i.e. prescribed to be stable.

A condition is specified by the number of terms, the state variable
with possible indices (to specify phase, component or constituent
etc), reference state (for chemical potentials) and unit (Joule or
calorie or per~cent or fraction)

The subroutine return a pointer to the condition record, see
gtp\_condition for that structure, or an error code if no such
condition.

The subroutine to set conditions is decribed in
\ref{sec:setcondition}.

{\small
\begin{verbatim}
 subroutine get_condition(nterm,istv,indices,iref,iunit,pcond)
! finds a condition record with the given state variable expression
! nterm: integer, number of terms in the condition expression
! istv: integer, state variable used in the condition
! indices: 2D integer array, state variable indices used in the condition
! iref: integer, reference state of the condition (if applicable)
! iunit: integer, unit of the condition value
! pcond: pointer, to a gtp_condition record
   implicit none
   TYPE(gtp_condition), pointer :: pcond
   integer, dimension(4,*) :: indices
   integer nterm,istv,iref,iunit
\end{verbatim}
}

\subsection{Set things}

Many things can be set but most of the ways to set them are described
together with the object to set.  How to set conditions is decribed in
\ref{sec:setcondition}.

\subsubsection{Set start constitution}

This was used for testing only and is now redundant.

{\small
\begin{verbatim}
 subroutine set_start_constitution(iph,ics,ceq)
! sets a start constitution 1/ns in all sublattices where ns is the number
! of constituents in the sublattice.  Redundant?
   implicit none
   integer iph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Set constitution}\label{sec:setconst}

This is a subroutine used frequently when iterating to find the
equilibrium.  At each iteration the new constitions of the phases must
be set uing this subroutine.  Some internal quantities are also
calculated like the number of atoms per mole formula unit of the phase
and the charge of the phase.  These are returned in the call.

The array yfr in the phase\_varres record belonging to the composition
set (iph,ics) is not private and a programmer may thus change the
values externally without calling set\_constitution.  But this is
strongly discouraged as the internal variables qq(1) and qq(2) must be
updated for each set of fractions to ensure that the massbalance is
correct.

The order of the fractions in yfra must be the same as in
get\_phase\_data, see \ref{sec:getphasedata}.

{\small
\begin{verbatim}
 subroutine set_constitution(iph,ics,yfra,qq,ceq)
! set the constituent fractions of a phase and composition set and the
! number of real moles and mass per formula unit of phase
! returns number of real atoms in qq(1), charge in qq(2) and mass in qq(3)
   implicit none
   double precision, dimension(*) :: yfra,qq
   integer iph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Set condition}

See section~\ref{sec:setcondition}.

\subsection{Calculation}

There are many subroutines involved in calculating the Gibbs energy
for a system and to retrieve values afterwards.  Some are explained in
connection with what they calculate, for example the magnetic
contribution in \ref{sec:calculateinden}.

%%%%%%%%%%%%%%%%%%%%%%% here starts pmod25b.F90

\subsubsection{Calculate for one phase}\label{sec:calcg}

This subroutine calculates the Gibbs energy and all first and second
derivaties with respect to $T, P$ and constituents for the specified
phase and composition set using the current values of $T, P$ and
constitution of the phase (set by set\_constitution,
see~\ref{sec:setconst}).  It also calculates all other properties
stored in the property records.

It is possible to calculate only G my setting moded=0, only G and
first derivatives if moded=1 and also second derivatives with moded=2.
This routine calls calcg\_internal to do the calculations after some
checks.

{\small
\begin{verbatim}
 subroutine calcg(iph,ics,moded,lokres,ceq)
! calculates G for phase iph and composition set ics in equilibrium ceq
! checks first that phase and composition set exists
! Data taken and stored in equilibrium record ceq
! lokres is set to the phase_varres record with all fractions and results
! moded is 0, 1 or 2 depending on calculating no, first or 2nd derivarives
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer iph,ics,moded,lokres
\end{verbatim}
}

\subsubsection{Model independent routine for one phase calculation}

This is the central subroutine to calculate G and derivatives for all
kinds of phases.  At present only the CEF model is implemented.  It
calls many other calculating subroutines, some are described in
connection with the property they calculate, like magnetic
contribution.

{\small
\begin{verbatim}
 subroutine calcg_internal(lokph,moded,cps,ceq)
! Central calculating routine calculating G and everyting else for a phase
! ceq is the equilibrium record, cps is the phase_varres record for lokph
! moded is type of calculation, 0=only G, 1 G and first derivatives
!    2=G and all second derivatives
   implicit none
   integer lokph,moded
   TYPE(gtp_equilibrium_data), pointer :: ceq
   TYPE(gtp_phase_varres), target :: cps
\end{verbatim}
}

\subsubsection{A utility routine}

This is used when a phase has permutations, see~\ref{sec:permutations}

{\small
\begin{verbatim}
 subroutine setendmemarr(lokph,ceq)
! stores the pointers to all ordered and disordered endmemners in arrays
   implicit none
   integer lokph
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Calculate and list results for one phase}

This is mainly a debugging rotine that calculates and lists for a
specific phase the Gibbs energy and all first and second derivatives
by calling calcg using the current values of $T, P$ and constitution.
It does not iterate and can thus not calculate an equilibrium.

{\small
\begin{verbatim}
 subroutine tabder(iph,ics,ceq)
! tabulate derivatives of phase iph with current constitution and T and P
   implicit none
   integer iph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Calculate an interaction parameter}

This is called by calcg\_internal to calculate the value of an
interaction parameter and its derivatives and add this to all property
arrays.

{\small
\begin{verbatim}
 subroutine cgint(lokpty,moded,vals,dvals,d2vals,gz,ceq)
! calculates an excess parameter that can be composition dependent
! gz%yfrem are the site fractions in the end member record
! gz%yfrint are the site fractions in the interaction record(s)
! lokpty is the property index
! moded=0 means only G, =1 G and dG/dy, =2 all
   implicit none
   integer moded
   TYPE(gtp_property), pointer :: lokpty
   TYPE(gtp_parcalc) :: gz
   double precision vals(6),dvals(3,gz%nofc)
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Calculate configurational entropy}

This calculates the ideal configurational entropy for all sublattices.

{\small
\begin{verbatim}
 subroutine config_entropy(moded,nsl,nkl,phvar,tval)
! calculates configurational entropy/R for phase lokph
! uses information about sublattices etc in phlista(lokph)
   implicit none
   integer moded,nsl
   integer, dimension(nsl) :: nkl
   TYPE(gtp_phase_varres), pointer :: phvar
\end{verbatim}
}

\subsubsection{Push/pop constituent fraction product on stack}

These subroutines are used to push/pop current values of the product
of constituent fractions and its derivatives before calculating an
interaction parameter.

{\small
\begin{verbatim}
 subroutine push_pyval(pystack,intrec,pmq,pyq,dpyq,d2pyq,moded,iz)
! push data when entering an interaction record
   implicit none
   integer pmq,moded,iz
   double precision pyq,dpyq(iz),d2pyq(iz*(iz+1)/2)
   type(gtp_pystack), pointer :: pystack
   type(gtp_interaction), pointer :: intrec
 subroutine pop_pyval(pystack,intrec,pmq,pyq,dpyq,d2pyq,moded,iz)
! pop data when entering an interaction record
   implicit none
   integer iz,pmq,moded
   double precision pyq,dpyq(iz),d2pyq(iz*(iz+1)/2)
   type(gtp_pystack), pointer :: pystack
   type(gtp_interaction), pointer :: intrec
\end{verbatim}
}

\subsubsection{Calculate disordered fractions from constituent fractions}

This is used when there are several fraction sets of a phase.  The
values of the second fraction set (also called the disordered fraction
set) is calculated by this subroutine.  These disordered fractions can
be used to calculate a ``disordered'' part of the Gibbs energy with
its own set of parameters.

{\small
\begin{verbatim}
 subroutine calc_disfrac(lokph,lokcs,ceq)
! calculate and set disordered set of fractions from sitefractions
! The first derivatives are dxidyj.  There are no second derivatives
!   TYPE(gtp_fraction_set), pointer :: disrec
   implicit none
   integer lokph,lokcs
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Disorder constituent fractions}

For the ``partitioned'' expression of the Gibbs energy for phases,
like FCC and BCC which can have order/disorder transformations, see
\ref{sec:partitioning}, one must calculate the ``ordered part'' twice,
once with the original constituent fractions and once with these set
equal to their disordered value.  This subroutne sets the fractions to
their disordered values.

{\small
\begin{verbatim}
 subroutine disordery(phvar,ceq)
! sets the ordered site fractions in FCC and other order/disordered phases
! equal to their disordered value in order to calculate and subtract this part
! phvar is index to phase_varres for ordered fractions
   implicit none
   TYPE(gtp_phase_varres), pointer :: phvar
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Scale phase amounts}

From a failed attempt to handle convergence problems.

{\small
\begin{verbatim}
 subroutine scale_phase_amounts(antot,ceq)
! multiply all phase amounts in moles by antot.  Probably redundant
! NOTE: MASS updated with same factor, is that correct?
! is this routine used? needed?
   implicit none
   double precision antot
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Set driving force for a phase explicitly}

Another failed attempt to handle convergence problems.

{\small
\begin{verbatim}
 subroutine set_driving_force(iph,ics,dgm,ceq)
! set the driving force of a phase explicitly
   implicit none
   type(gtp_equilibrium_data), pointer :: ceq
   integer iph,ics
   double precision dgm
\end{verbatim}
}

\subsubsection{Extract massbalance conditions}

This is used in global grid minimization to extract the set of mass
balance conditions.  If the current conditions are not all mass
balance there is an error return, otherwise the conditions of T and P,
the total number of moles and the mole fractions of all components are
returned.

{\small
\begin{verbatim}
 subroutine extract_massbalcond(tpval,xknown,antot,ceq)
! extract T, P,  mol fractions of all components and total number of moles
! for use when minimizing G for a closed system.  Probably redundant
   implicit none
   double precision, dimension(*) :: tpval,xknown
   double precision antot
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

%%%%%%%%%%%% here starts pmod25C.F90

\subsection{State variable stuff}

State variables are important for the setting and extracting results
of a calculation.  State variables are treated very similarly to
Thermo-Calc using symbols like $T, ~P, ~N,$ $x({\rm <component}>)$
etc.

The internal syntax of state variables is rather complicated, perhaps
it should be revised and defined as a structure?  If there are errors
or one wants to make modifications it is not easy.

Things like Curie temperature, Debye temperature, mobilities etc are
alse defined as ``state variables'' altough one cannot use them in
conditions.  Adding more things like elastic constants will be a
bit complicated.

The subroutines for manipulations is also a bit complicated and could
do with a clean up and renaming.

\subsubsection{Get state variable value given its symbol}

By providing a state variable as a character variable like $T$ or
$x({\rm liquid,cr})$ this routine returns its current value.
Wildcards, ``*'', are not allowed, see \ref{sec:getmany}.

{\small
\begin{verbatim}
 subroutine get_state_var_value(statevar,value,encoded,ceq)
! called with a state varaiable character
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   character statevar*(*),encoded*(*)
   double precision value
\end{verbatim}
}

\subsubsection{Get many state variable values}\label{sec:getmany}

This routine can be called with wildcard, ``*'', as argument in state
variables like $NP(*), ~x(*,CR)$ etc.  It is fragile and currently
only available when defining plot axis.

{\small
\begin{verbatim}
 subroutine get_many_svar(statevar,values,mjj,kjj,encoded,ceq)
! called with a state varaiable name with woldcards allowed like X(*,CR)
! mjj is dimension of values, kjj is number of values returned
! encoded not used yet
! >>>> BIG problem: How to do with phases that are note stable?
! If I ask for w(*,Cr) I only want the fraction in stable phases
! but whenthis is used for GNUPLOT the values are written in a matix
! and the same column in that phase must be the same phase ...
! so I have to have the same number of phases from each equilibria.
!
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   character statevar*(*),encoded*(*)
   double precision values(*)
   integer mjj,kjj
\end{verbatim}
}

\subsubsection{Decode a state variable symbol}\label{sec:svdecode}

This subroutine takes as input a character with a state variable and
returns its internal coding.  If there are any changes in the state
variables this one, \ref{sec:svencode} and \ref{sec:svcalculate} must
be changed also.

The subroutine also handle property symbols used in the parameters,
see \ref{sec:paramid}, to make it possible to obtain the value of
such a propery after an equilibrium calculation.  The value returned
in istv for such properties is the negative of the property index.

{\small
\begin{verbatim}
 subroutine decode_state_variable(statevar,istv,indices,iref,iunit,ceq)
! converts a state variable character to indices
! Typically: T, x(fe), x(fcc,fe), np(fcc), y(fcc,c#2), ac(h2,bcc), ac(fe)
! NOTE! model properties like TC(FCC),MQ&FE(FCC,CR) must be detected
!
! this routine became as messy as I tried to avoid
! but I leave it to someone else to clean it up ...
!
! state variable and indices
! Symbol  no   index1 index2 index3 index4
! T       1    -
! P       2    -
! MU      3    component or phase,constituent
! AC      4    component or phase,constituent
! LNAC    5    component or phase,constituent
!                                          index (in svid array)
! U       10   (phase#set)                    6     Internal energy (J)
! UM      11    "                             6     per mole components
! UW      12    "                             6     per kg
! UV      13    "                             6     per m3
! UF      14    "                             6     per formula unit
! S       2x    "                             7     entropy
! V       3x    "                             8     volume
! H       4x    "                             9     enthalpy
! A       5x    "                            10     Helmholtz energy
! G       6x    "                            11     Gibbs energy
! NP      7x    "                            12     moles of phase
! BP      8x    "                            13     mass of moles
! DG      9x    "                            15     Driving force
! Q       10x   "                            14     Internal stability
! N       11x (component/phase#set,component) 16  moles of components
! X       111   "                            17     mole fraction of components
! B       12x   "                            18     mass of components
! W       122   "                            19     mass fraction of components
! Y       13    phase#set,constituent#subl   20     constituent fraction
!----- model variables <<<< these now treated differently
! TC      -     phase#set                    -      Magnetic ordering T
! BMAG    -     phase#set                    -      Aver. Bohr magneton number
! MQ&     -     element, phase#set           -      Mobility
! THET    -     phase#set                    -      Debye temperature
!
   implicit none
   integer, parameter :: noos=20
   character*4, dimension(noos), parameter :: svid = &
       ['T   ','P   ','MU  ','AC  ','LNAC','U   ','S   ','V   ',&
        'H   ','A   ','G   ','NP  ','BP  ','DG  ','Q   ','N   ',&
        'X   ','B   ','W   ','Y   ']
   character statevar*(*)
   integer istv,iref,iunit
   integer, dimension(4) :: indices
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Calculate molar and mass properties for a phase}\label{sec:mmph}

This subroutine calculates mole and massfractions of all components
for a phase (mole fractions of components not dissolved is zero).  It
also returns the total number of moles of compoinets and the mass.  In
amount the number of moles per formula unit is returned (same as qq(1)
in get\_phase\_data and set\_constitution).

{\small
\begin{verbatim}
 subroutine calc_phase_molmass(iph,ics,xmol,wmass,totmol,totmass,amount,ceq)
! calculates mole fractions and mass fractions for a phase#set
! xmol and wmass are fractions of components in mol or mass
! totmol is total number of moles and totmass total mass of components.
! amount is number of moles of components per formula unit.
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
   integer iph,ics
   double precision, dimension(*) :: xmol,wmass
   double precision amount,totmol,totmass
\end{verbatim}
}

\subsubsection{Calculate molar amounts for a phase}

Specially used for grid minimization.

{\small
\begin{verbatim}
 subroutine calc_phase_mol(iph,xmol,ceq)
! calculates mole fractions for phase iph, compset 1 in equilibrium ceq
! used for grid generation and some other things
! returns current constitution in xmol equal to mole fractions of components
   implicit none
   integer iph
   double precision xmol(*)
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Sum molar and mass properties for all phases}

Sums the mole and mass fractions for all components and also total
number of moles and mass over all stable phases using \ref{sec:mmph}.

{\small
\begin{verbatim}
 subroutine calc_molmass(xmol,wmass,totmol,totmass,ceq)
! summing up N and B for each component over all phases with positive amount
! Check that totmol and totmass are correct ....
   implicit none
   double precision, dimension(*) :: xmol,wmass
   double precision totmol,totmass
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Sum all normalizing property values}

Used to calculate normallizing propertes like V, N and B but also G
and S for the whole system.  Used when calculating state variable
values.

{\small
\begin{verbatim}
 subroutine sumprops(props,ceq)
! summing up G, S, V, N and B for all phases with positive amount
! Check if this is correct
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
   double precision props(5)
\end{verbatim}
}

\subsubsection{Encode state variable}\label{sec:svencode}

This converts the internal coding of a state variable into a character
variable text starting at position ip.  ip is updated inside.

The subroutine also handle property symbols used in the parameters,
see \ref{sec:paramid}, to make it possible to list the symbol of such
a propery after an equilibrium calculation.  See \ref{sec:svdecode}

{\small
\begin{verbatim}
 subroutine encode_state_variable(text,ip,istv,indices,iunit,iref,ceq)
! writes a state variable in text form position ip.  ip is updated
! the internal coding provides in istv, indices, iunit and iref
! >>>> unfinished as iunit and iref not cared for
   implicit none
   integer, parameter :: noos=20
   character*4, dimension(noos), parameter :: svid = &
       ['T   ','P   ','MU  ','AC  ','LNAC','U   ','S   ','V   ',&
        'H   ','A   ','G   ','NP  ','BP  ','DG  ','Q   ','N   ',&
        'X   ','B   ','W   ','Y   ']
   character*(*) text
   integer, dimension(4) :: indices
   integer istv,ip,iunit,iref
\end{verbatim}
}

\subsubsection{Calculate state variable value}\label{sec:svcalculate}

This is the subroutine that actually calculates the value of a state
variable.  The state variable is indentified using the internal
coding.

The subroutine also handle properties used in the parameters, see
\ref{sec:paramid}, to make it possible to obtain the value of such
a propery after an equilibrium calculation.  The values of istv etc
must be as returned from decode\_state\_variable, see
\ref{sec:svdecode}.

{\small
\begin{verbatim}
 subroutine state_variable_val(istv,indices,iref,iunit,value,ceq)
! calculate the value of a state variable in equilibrium record ceq
! istv is state variable type (integer)
! indices are possible specifiers
! iref idicates use of possible reference state
! iunit is unit, (K, oC, J, cal etc). For % it is 100
! value is the calculated values. for state variables with wildcards use
! get_many_svar
   implicit none
   integer, dimension(4) :: indices
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer istv,iref,iunit
   double precision value
\end{verbatim}
}

\subsubsection{Calculate state variable derivative}

This is not yet implemented.  It should calculate derivatives of a
state variable with respect to another state variable for example
things like $H.T$ i.e. the heat capacity and $x({\rm liquid,cr}).T$
i.e. the liquidus slope.  It must use the derivatives of G stored
after an equilibrium calculation.  Two state variables are supplied.

{\small
\begin{verbatim}
 subroutine state_var_value_derivative(istv,indices,iref,iunit,&
      istv2,indices2,iref2,iunit2,value,ceq)
! calculates a state variable value derivative NOT IMPLEMENTED YET
! istv and istv2 are state variable type (integer)
! indices and indices2 are possible specifiers
! iref and iref2 are possible reference state
! iunit and iunit2 are units, (K, oC, J, cal etc)
! value is calculated value
! ceq is current equilibrium
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
   integer :: istv,iref,iunit,istv2,iref2,iunit2
   integer, dimension(4) :: indices,indices2
   double precision value
\end{verbatim}
}

%%%%%%%%%%%% here starts pmod25D.F90

\subsection{State variable functions}

This section is separated from the state variables itself to make it a
little simpler.  State variable function can conatin any combination
of state variables using normal operators like +, -, *, / but also
EXP, LN, LOG10, ERF etc.  The PUTFUN subroutine in the METLIB package
is used.  No derivatives can be calculated.  A state variable function
can refer to another state variable function.

An extention planned but not yet implemented is to allow formal
arguments when defining a state variable function, for example
CP(@P)=HM(@P).T where the formal argument @P means a phase.  @S would
stand for a species and @C for a component.  When calling the function
an actual argument must be supplied.

\subsubsection{Enter a state variable function}

This subroutine stores a state variable function in the SVFLISTA
array.

{\small
\begin{verbatim}
 subroutine store_putfun(name,lrot,nsymb,&
       istv,indstv,iref,iunit,idot)
! enter an expression of state variables
! name: character, name of state variable function
! lrot: pointer, to a putfun_node that is the root of the stored expression
! nsymb: integer, number of formal arguments
! istv: integer array, formal argument state variables typ
! indstv: 2D integer array, indices for the formal state variables
! iref: integer array, reference for the formal state variables
! iunit: integer array, unit of the formal state variables
   implicit none
   type(putfun_node), pointer :: lrot
   integer nsymb
   integer, dimension(*) :: istv,iref,iunit,idot
   integer, dimension(4,*) :: indstv
   character name*(*)
\end{verbatim}
}

\subsubsection{List a state variable function}

Writes the state variable function in the character text from position
ipos.

{\small
\begin{verbatim}
 subroutine list_svfun(text,ipos,lrot,ceq)
! list a state variable function
   implicit none
   character text*(*)
   integer ipos,lrot
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List all state variable functions}

Lists all state variables functions on device kou.

{\small
\begin{verbatim}
 subroutine list_all_svfun(kou,ceq)
! list all state variable funtions
   implicit none
   integer kou
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Evaluate all state variable functions}

As state variable functions can call eachother all state variable
functions are evaluated when any is called.  I am not sure what
happends with state variables with formal arguments.

{\small
\begin{verbatim}
 subroutine evaluate_all_svfun(kou,ceq)
! evaluate and list all functions
   implicit none
   integer kou
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Evaluate one state variable function}

The specific state variable function is evaluated.

{\small
\begin{verbatim}
 double precision function evaluate_svfun(lrot,actual_arg,mode,ceq)
! envaluate all funtions as they may depend on each other
! actual_arg are names of phases, components or species as @Pi, @Ci and @Si
! needed in some deferred formal parameters  (NOT IMPLEMENTED YET)
   implicit none
   integer lrot,mode
   character actual_arg(*)*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsection{Interactive things}

The current user interface to OC and GTP is command oriented and there
are subroutines provided in GTP to enter, set, list and get many
things.  Most subroutines where the user is expected to provide
information is collected in this section.

\subsubsection{Ask for phase constitution}

The used can provide the default constitution or enter a constitution
specificly for a phase and composition set.

{\small
\begin{verbatim}
 subroutine ask_phase_constitution(cline,last,iph,ics,lokcs,ceq)
! interactive input constitution of phase iph
   implicit none
   integer last,iph,ics,lokcs
   character cline*(*)
\end{verbatim}
}

\subsubsection{Ask for parameter}\label{sec:enterparinter}

The user can enter a model parameter with this subroutine.

{\small
\begin{verbatim}
 subroutine enter_parameter_interactivly(cline,ip)
! enter a parameter from terminal or macro
! NOTE both for ordered and disordered fraction set !!
   implicit none
   integer ip
   character cline*(*)
\end{verbatim}
}

\subsubsection{Amend global bits}

There are a number of global bits that can be set by this subroutine.

{\small
\begin{verbatim}
 subroutine amend_global_data(cline,ipos)
   implicit none
   character cline*(*)
   integer ipos
\end{verbatim}
}

\subsubsection{Ask for reference of parameter data}

Each parameter in a model can have a data reference, preferably a
published paper.  When a parameters is entered by calling
enter\_parameter\_interactivly the refernce is asked for but with this
routine it is possible to enter such a reference separately.

{\small
\begin{verbatim}
 subroutine enter_reference_interactivly(cline,last,mode,iref)
! enter a reference for a parameter interactivly
! this should be modified to allow amending an existing reference
   implicit none
   character cline*(*)
   integer last,mode,iref
\end{verbatim}
}

\subsubsection{Set a condition}\label{sec:setcondition}

This is the central routine to set a condition for an equilibrium
calculation.  Anther alternative is the set\_input\_amount.  When
setting the status of a phase as fixed this subroutine is called
automatically to add this as condition.

{\small
\begin{verbatim}
 subroutine set_condition(cline,ip,ceq)
! decode an equilibrium condition, can be an expression with + and -
! the expression should be terminated with an = or value supplied on next line
! like "T=1000", "x(liq,s)-x(pyrrh,s)=0", "2*mu(cr)-3*mu(o)=muval"
! It can also be a "NOFIX=<phase>" or "FIX=<phase> value"
! The routine should accept conditions identified with the <number>:
! preceeding each condition in a list_condition
! It should also accept changing conditions by <number>:=new_value
   implicit none
   integer ip
   character cline*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Using conditions when calculating}

This subrotine is called at each iteration in the equilibrium
calculation to formulate the system matrix containing the
external conditions.  It is still very rudimentary and can
be improved.

{\small
\begin{verbatim}
 subroutine apply_condition_value(current,what,type,value,cmix,ceq)
! This is called when calculating an equilibrium.
! It returns one condition at each call, at first current must be nullified
! When all conditions done the current is nullified again
! If what=-1 then return degrees of freedoms and maybe something more
! what=0 means calculate current values of conditions
! calculate the value of a condition, used in minimizing G
   implicit none
   integer what,type,cmix(*)
   double precision value
   TYPE(gtp_equilibrium_data), pointer :: ceq
   TYPE(gtp_condition), pointer :: current
\end{verbatim}
}

\subsubsection{Ask for a state variable function}

The user can provide a state variable function in the character cline.

{\small
\begin{verbatim}
 subroutine enter_svfun(cline,last,ceq)
! enter a state variable function
! no check that the name is unique!!!
   implicit none
   integer last
   character cline*(*)
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Ask for new set of components}

When working with real quasibinary or quasiternary systems when the
models of the phases does not extend outside this system, like the
CaO-SiO$_2$ system, it is convenient to specify CaO, SiO$_2$ as
components rather than the elements Ca, Si and O.  However, one cannot
change the number of components this way, one must also specify a
third element like CaO, SiO2, O.  The condition for the third
component can be removed by giving an arbitrary chemical potential or
activity.

If one defines a new set of components can calculates a composition
outide the hypervolume defined by these components one may have
negative fractions of the components.

This subroutine is not implemented yet.

{\small
\begin{verbatim}
 subroutine amend_components(cline,last,ceq)
! enter a new set of components for equilibrium ceq
   implicit none
   integer last
   character cline*(*)
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Ask for default constitution}

The user can enter a default constitution for a phase.  A negtive
value means a maximum value, a positive means a minimum value.

{\small
\begin{verbatim}
 subroutine ask_default_constitution(cline,last,iph,ics,ceq)
! set values of default constitution interactivly
! phase and composition set already given
   implicit none
   character cline*(*)
   integer last,iph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Interactive set input amounts}

This subroutine allows setting condition by entering the amount of
species.  The amount of the species is converted to amount of
components internally.  Redundancy is allowed.  If several species
contain the same element the amounts are added.  For example
set\_input\_amount N(C1O1)=10, N(H2O1)=5, N(C1H4)=7, N(O2)=20 is
translated to the conditions N(C)=17, N(H)=38, N(O)=55.

{\small
\begin{verbatim}
 subroutine set_input_amounts(cline,lpos,ceq)
! set amounts like n(specie)=value or b(specie)=value
! value can be negative removing amounts
! values are converted to moles and set or added to conditions
   implicit none
   integer lpos
   character cline*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

%%%%%%%%%%%%% here starts pmod25E.F90

\subsection{List things}

The routines in this section are intended for the line oriented user
interface of GTP.  It lists data assuming 80 column width of the
screen.  In some cases a character variable is retured but in most
case the list unit is provided in the call.  This can be the screen,
a file or a device.

Some listings are described in connection with the objects that are
listed, see \ref{sec:listadditions}.

\subsubsection{List data for all elements}

The element data is listed

{\small
\begin{verbatim}
 subroutine list_all_elements(unit)
! lists elements
   implicit none
   integer unit
\end{verbatim}
}

\subsubsection{List data for all components}

The components may be different in each equilibrium.

{\small
\begin{verbatim}
 subroutine list_all_components(unit,ceq)
! lists the components for an equilibrium
   implicit none
   integer unit
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List data for one element}

The data for element ``elno'' in written to the character variable text from
position ipos.

{\small
\begin{verbatim}
 subroutine list_element_data(text,ipos,elno)
   implicit none
   character text*(*)
   integer ipos,elno
\end{verbatim}
}

\subsubsection{List data for one species}

The data for species ``spno'' in written to the character variable text from
position ipos.

{\small
\begin{verbatim}
 subroutine list_species_data(text,ipos,spno)
   implicit none
   character text*(*)
   integer ipos,spno
\end{verbatim}
}

\subsubsection{List data for all species}

One line for each species is listed on device unit.

{\small
\begin{verbatim}
 subroutine list_all_species(unit)
   implicit none
   integer unit
\end{verbatim}
}

\subsubsection{List a little data for all phases}

One line for each phase is listed on device unit for equilibrium ceq.

{\small
\begin{verbatim}
 subroutine list_all_phases(unit,ceq)
! list one line for each phase
   implicit none
   integer unit
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List global results}

This is part of the ``list\_result'' command in the GTP user i/f.

{\small
\begin{verbatim}
 subroutine list_global_results(lut,ceq)
! list G, T, P, V and some other things
   implicit none
   integer lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List components result}

This is part of the ``list\_result'' command in the GTP user i/f.

{\small
\begin{verbatim}
 subroutine list_components_result(lut,mode,ceq)
! list one line per component (name, fraction, x/w, chem.pot. reference state
! mode 1=mole fractions, 2=mass fractions
   implicit none
   integer lut,mode
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List all phases with positive dgm}

This is part of the ``list\_result'' command in the GTP user i/f.  If
a phase has positive dgm it should either be dormant or there has been
an error calculating the equilibrium.

{\small
\begin{verbatim}
 subroutine list_phases_with_positive_dgm(mode,lut,ceq)
! list one line for each phase+comp.set with positive dgm on device lut
! The phases must be dormant or the result is in error.  mode is not used
   implicit none
   integer mode,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List results for one phase}

This is part of the ``list\_result'' command in the GTP user i/f.  It
lists normally only the stable phases with their amounts and
compositions.  With different values of mode units and listing can be
changed.

{\small
\begin{verbatim}
 subroutine list_phase_results(iph,jcs,mode,lut,ceq)
! list results for a phase+comp.set on lut
! mode specifies the type and amount of results,
! unit digit:   0=mole fraction,      othewise mass fractions
! 10th digit:   0=only composition,   10=also constitution
! 100th digit:  0=value order,        100=alphabetical order
! 1000th digit: 0=only stable phases, 1000=all phases
   implicit none
   integer iph,jcs,mode,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Format output for constitution}

This subroutine formatts the output of composition or constitution in
nice columns trying to use as few lines as possible.

{\small
\begin{verbatim}
 subroutine format_phase_composition(mode,nv,consts,vals,lut)
! list composition/constitution in alphabetical or value order
! entalsiffra 0 mole fraction, 1 mass fraction, 3 mole percent, 4 mass percent
! tiotalsiffra ?
! mode >100 else alphanetical order
! nv is number of components/constitunents (in alphabetical order in consts)
! components/constituents in consts, fractions in vals
   implicit none
   integer nv,mode,lut
   character consts(nv)*(*)
   double precision vals(nv)
\end{verbatim}
}

\subsubsection{List some phase model stuff}

This is probably redundant but can be used to check the conversion from
site fractions to disordered fractions for phases with several
fraction sets.

{\small
\begin{verbatim}
 subroutine list_phase_model(iph,ics,lut,ceq)
! list model (no parameters) for a phase on lut
   implicit none
   integer iph,ics,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List all parameter data for a phase}

This is the big listing of the model and data for a phase.  It lists
the sublattices, sites, constituents.  Then all endmembers and
all interaction parameters.

{\small
\begin{verbatim}
 subroutine list_phase_data(iph,lut)
! list parameter data for a phase on unit lut
   implicit none
   integer iph,lut
\end{verbatim}
}

\subsubsection{Format expression of references for endmembers}

When listing an endmember parameter for the Gibbs energy this
subroutine subtracts the H298 expression.

{\small
\begin{verbatim}
 subroutine subrefstates(funexpr,jp,lokph,parlist,endm)
! list a sum of reference states for a G parameter
   implicit none
   integer jp,lokph,parlist,endm(*)
   character funexpr*(*)
\end{verbatim}
}

\subsubsection{Encode stoichiometry of species}

This subroutine generate a stoichiometric formula for a species
including a charge.

{\small
\begin{verbatim}
 subroutine encode_stoik(text,ipos,spno)
! generate a stoichiometric formula of species from element list
   implicit none
   integer ipos,spno
   character text*(*)
\end{verbatim}
}

\subsubsection{Decode stoichiometry of species}

This subroutine can translate a stoichiometric formula to elements and
stoichimetric factors including a charge.

{\small
\begin{verbatim}
 subroutine decode_stoik(name,noelx,elsyms,stoik)
! decode a species stoichiometry in name to element index and stoichiometry
! all in upper case
   implicit none
   character name*(*),elsyms(*)*2
   double precision stoik(*)
   integer noelx
\end{verbatim}
}

\subsubsection{Encode constituent array for parameters}

This subroutine generates a constituent array for a parameter.
Constituents are species.  Constituents in different sublattices are
separated by ``:'', interacting constituents in same sublattice are
separated by ``,''.  The degree is written after a ``;''.

{\small
\begin{verbatim}
 subroutine encode_constarr(constarr,nsl,endm,nint,lint,ideg)
! creates a constituent array
   implicit none
   character constarr*(*)
   integer, dimension(*) :: endm
   integer nsl,nint,ideg
   integer, dimension(2,*) :: lint
\end{verbatim}
}

\subsubsection{Decode constituent array for parameters}

By providing the indices of constituent in the endmember and possible
interaction constituents and the degree a text with the constitent
array is generated.

{\small
\begin{verbatim}
 subroutine decode_constarr(constarr,nsl,endm,nint,lint,ideg)
! deconde a text string with a constituent array
! a constituent array has <species> separated by , or : and ; before degree
   implicit none
   character constarr*(*)
   integer endm(*),lint(2,*)
   integer nsl,nint,ideg
\end{verbatim}
}

\subsubsection{List parameter data references}

This subroutine lists the data references for parameters.

{\small
\begin{verbatim}
 subroutine list_references(lut)
! list references
   implicit none
   integer lut
\end{verbatim}
}

\subsubsection{List condition on a file or screen}

The heading says all.

{\small
\begin{verbatim}
 subroutine list_conditions(lut,ceq)
! lists conditions on lut
   implicit none
   integer lut
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List condition in character variable}

All current active conditions in equilibrium ceq is written to the
character variable text.  This can be written on the screen or used
for other purposes.  It can also be used for experiments (not
implemented yet).

{\small
\begin{verbatim}
 subroutine get_all_conditions(text,mode,ceq)
! list all conditions if mode=0, experiments if mode=1
   implicit none
   integer mode
   character text*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{List available parameter identifiers}\label{sec:listavailprop}

The GTP package allows definition of new properties that can be
modelled as dependent on the constitution of each phase.  Such
properties must be defined in the software and they can be listed with
this subroutine.  Many additions depend on such parameter properties
like the Curie temperature and the Debye temperature.

On can also add properties that does not affect the Gibbs energy but
which depend on the constitution of the phase like the mobility,
resistivity, lattice parameter etc.

{\small
\begin{verbatim}
 subroutine list_defined_properties(lut)
! lists all parameter identifiers allowed
   implicit none
   integer lut
\end{verbatim}
}

\subsubsection{Find defined properties}\label{sec:listpropval}

Although properties like TC (Curie temperature) and BMAG (Average Bohr
magneton number) are not state variables they can be listed using the
command LIST STATE\_VARIABLEs and their values can be obtained by the
same subroutines that are used for state variables like
get\_state\_variable.  They use the following subroutine to find
the properties defined in the gtp\_propid structure.

{\small
\begin{verbatim}
 subroutine find_defined_property(symbol,mode,typty,iph,ics)
! searches the propid list for one with symbol or identifiction typty
! if mode=0 then symbol given, if mode=1 then typty given
! symbol can be TC(BCC), BM(FCC), MQ&FE(HCP) etc, the phase must be
! given in symbol as otherwise it is impossible to find the consititent!!!
! A constituent may have a sublattice specifier, MQ&FE#3(SIGMA)
   implicit none
   integer mode,typty,iph,ics
   character symbol*(*)
\end{verbatim}
}

%%%%%%%%%%%%%%%%%5 here starts pmod25F.F90

\subsection{Save and read data from files}

Most of the subroutines in this section are unfinished.  The only
thing that can be read is a simple TDB file.

The problem is that whenever a change is made in the data structure
these routines must be modified accordingly.  And the data structure
is still undergoing big changes.

\subsubsection{Save all data}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine gtpsave(filename,str)
! save all data on file, unformatted, TDB or macro NOT EVEN STARTED
! header
! element list
! species list
! phase list with sublattices, endmembers, interactions and parameters etc
! tpfuns
! state variable functions
! references
!
   implicit none
   character*(*) filename,str
\end{verbatim}
}

\subsubsection{Save data for a phase}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine savephase(lut,form,jph)
! save data for phase jph except data in the equilibrium record
! For phases with disordered set of parameters we must access the number of
! sublattices via firsteq ... UNFINISHED
   implicit none
   integer lut,jph
   logical form
\end{verbatim}
}

\subsubsection{Save data for an equilibrium}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine saveequil(lut,form,ceq)
! save data for an equilibrium record
   implicit none
   logical form
   integer lut
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Read data from a saved file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine gtpread(filename,str)
! being updated
! read all data in the following order
! header
! element list
! species list
! phase list with sublattices, endmembers, interactions and parameters etc
! tpfuns
! state variable functions
! references
! equilibrium record(s) with conditions, componenets, phase_varres records etc
!
   implicit none
   character*(*) filename,str
\end{verbatim}
}

\subsubsection{Read data for a phase from file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine readphase(lut)
! read data for phlista and all endmembers etc
! works for test case without disordered fraction test
   implicit none
   integer lut
\end{verbatim}
}

\subsubsection{Read data for an endmember from file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine readendmem(lut,nsl,emrec,nop,noi,nem)
! allocates and reads an endmember record
   implicit none
   integer lut,nsl,nop,noi,nem
   type(gtp_endmember), pointer :: emrec
\end{verbatim}
}

\subsubsection{Read data for a property record from file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine readproprec(lut,proprec,nox)
! allocates and reads a property record
   implicit none
   integer lut,nox
   type(gtp_property), pointer :: proprec
\end{verbatim}
}

\subsubsection{Read data for an interaction record from file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine readintrec(lut,intrec,noi,nup,nop)
! allocates and reads an interaction record UNFINISHED
   integer none
   integer lut,noi,nup,nop
   type(gtp_interaction), pointer :: intrec
\end{verbatim}
}

\subsubsection{Read an equilibrium from file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine readequil(lut,ceq)
! Read equilibria records from a file
   implicit none
   integer lut
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Erase all data}

This is necessary before reading a new saved file. Not implemented yet.

{\small
\begin{verbatim}
 subroutine new_gtp
! deletes all data
!
! MUST BE COMPLETELY REWRITTEN
!
! this is also needed before reading a new file (or same file ...)
! we must go through all records and delete and deallocate each
! separately.  Copied from "bmpread" so some comments irrelevant.
!   implicit double precision (a-h,o-z)
   implicit none
\end{verbatim}
}

\subsubsection{Save state variable functions on file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine svfunsave(lut,form,ceq)
! saves all state variable functions on a file
   implicit none
   integer lut
   logical form
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Save data references on file}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine refsave(lut,form)
! saves references on a file
   implicit none
   integer lut
   logical form
\end{verbatim}
}

\subsubsection{Read state variable functions}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine svfunread(lut)
! read a state variable function from save file and store it.
! by default there are some state variable functions, make sure
! they are deleted.  Done here just by setting nsvfun=0
   implicit none
   integer lut
\end{verbatim}
}

\subsubsection{Read reference records}

Not implemented yet.

{\small
\begin{verbatim}
 subroutine refread(lut)
! read references from save file
   implicit none
   integer lut
\end{verbatim}
}

\subsubsection{Read a TDB file}

This subroutine can read a TDB file that is not too fancily edited
manually.  Best is to read as written from Thermo-Calc.  Some
TYPE\_DEFINITIONS are not handelled, especially the DISORDERED\_PART as
this has been implemented differently in GTP.

{\small
\begin{verbatim}
 subroutine readtdb(filename)
! reading data from a TDB file.  No selection of elements.
! Several TYPE_DEFS not handelled
! first read only FUNCTION (maybe several times), then the rest
! Only minimally edited iutput files from TC accepted
   implicit none
   character filename*(*)
\end{verbatim}
}

%%%%%%%%%%%%%%%% here pmod25G.F90

\subsection{Enter data}

The subroutines for entering data and other things can be named as
new, enter, add, create etc. according to the mind of the programmer
when the subroutine was written.  In all cases the data is provided as
arguments in the call, there is no interactions with the user.

\subsubsection{Enter element data}

All data for an element.  Some checks are made.  The elements are
automatically eneterd also as species so they can be constituents of
phases.

{\small
\begin{verbatim}
 subroutine new_element(symb,name,refstate,mass,h298,s298)
! Creates an element record after checks.
! symb: character*2, symbol (it can be a single character like H or V)
! name: character, free text name of the element
! refstate: character, free text name of reference state.
! mass: double, mass of element in g/mol
! h298: double, enthalpy difference between 0 and 298.14 K
! s298: double, entropy at 298.15 K
   implicit none
   CHARACTER*(*) symb,name,refstate
   DOUBLE PRECISION mass,h298,s298
\end{verbatim}
}

\subsubsection{Enter species data}

All data for an element.  Some checks are made.  The elements
constituting the species must have been entered before.  A species can
have a positive or negative charge using the element index -1 with a
stoichiometic factor.

{\small
\begin{verbatim}
 subroutine new_species(symb,noelx,ellist,stoik)
! creates a new species
! symb: character*24, name of species, often equal to stoichimoetric formula
! noelx: integer, number of elements in stoichiometric formula (incl charge)
! ellist: character array, element names (electron is /-)
! stoik: double array, must be positive except for electron.
   implicit none
   character symb*(*),ellist(*)*(*)
   integer noelx
   double precision stoik(*)
\end{verbatim}
}

\subsubsection{Enter phase and model}

This subroutine is called with the model data needed to create the
data structure for a phase (no parameter data).  The model variable is
just a text, phtype is used to arrange gas (G) and liquids (L) before
the alphabetical list of the other phases.

{\small
\begin{verbatim}
 subroutine new_phase(name,nsl,knr,const,sites,model,phtype)
! creates the data structure for a new phase
! name: character*24, name of phase
! nsl: integer, number of sublattices (range 1-9)
! knr: integer array, number of constituents in each sublattice
! const: character array, constituent (species) names in sequential order
! sites: double array, number of sites on the sublattices
! model: character, free text
! phtype: character*1, specifies G for gas, L for liquid
   implicit none
   character name*(*),model*(*),phtype*(*)
   integer nsl
   integer, dimension(*) :: knr
   double precision, dimension(*) :: sites
   character, dimension(*) :: const*(*)
\end{verbatim}
}

\subsubsection{Enter composition set}

As explained in section~\ref{sec:compsets} a phase may exist
simultaneously with several different composition sets.  This can be
due to miscibility gaps or ordering.  Some carbides like cubic TiC is
modelled as the same phase as the metallic FCC and it may be stable at
the same time as the austenite phase in steels.  This subroutine
creates a new composition set for a phase.

{\small
\begin{verbatim}
 subroutine add_composition_set(iph,prefix,suffix,icsno,ceq)
! adds a composition set to a phase.
! iph: integer, phase index
! prefix: character*4, optional prefix to original phase name
! suffix: character*4, optional suffix to original phase name
! icsno: integer, returned composition set index (value 2-9)
! ceq: pointer, to current gtp_equilibrium_data
!
! BEWARE this must be done in all equilibria (also during parallel processes)
! There may still be problems with equilibria saved during STEP and MAP
!
   implicit none
   integer iph,icsno
   character*(*) prefix,suffix
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Remove composition set}

Sometimes the grid minimizer creates too many composition sets and
the furter calculations may be easier if these are removed.

{\small
\begin{verbatim}
 subroutine remove_composition_set(iph,force)
! the last composition set is deleted
!
! >>>>>>>>>>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< !
! Safe to remove composition sets only when there is just one equilibrium  !
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< !
!
! If force is TRUE delete anyway ... very dangerous ...
!
   implicit none
!
! BEWARE must be for all equilibria but maybe not allowed when threaded
!
   integer iph
   logical force
\end{verbatim}
}

\subsubsection{Enter parameter}

All kind of parameters are entered by this subroutine.  Called when
reading a TDB file or entered interactivly,
see~\ref{sec:enterparinter}.

{\small
\begin{verbatim}
 subroutine enter_parameter(lokph,typty,fractyp,nsl,endm,nint,lint,ideg,&
      lfun,refx)
! enter a parameter for a phase from database or interactivly
! typty is the type of property, 1=G, 2=TC, ... , n*100+icon MQ&const#subl
! fractyp is fraction type, 1 is site fractions, 2 disordered fractions
! nsl is number of sublattices
! endm has one constituent index for each sublattice
! constituents in endm and lint should be ordered so endm has lowest
! (done by decode_constarr)
! nint is number of interacting constituents (can be zero)
! lint is array of sublattice+constituent indices for interactions
! ideg is degree
! lfun is link to function (integer index)
! refx is reference (text)
! if this is a phase with permutations all interactions should be in
! the first or the first two identical sublattices (except interstitals)
! a value in endm can be negative to indicate wildcard
   implicit none
   integer, dimension(*) :: endm
   character refx*(*)
   integer lokph,fractyp,typty,nsl,nint,ideg,lfun
   integer, dimension(2,*) :: lint
\end{verbatim}
}

\subsubsection{Subroutines handling fcc permutatations}

These subroutines creates all possible permutations of parameters for
a 4 sublattice fcc phase.  The 4 ordering sublattices must be the
first and they represent the tetrahedron in the lattice.  The number
of sites must be the same and the constituents also.  There can be
additional sublattices for interstitials.

{\small
\begin{verbatim}
 subroutine fccpermuts(lokph,nsl,iord,noperm,elinks,nint,jord,intperm,intlinks)
! finds all fcc/hcp permutations needed for this parameter
! The order of elements in the sublattices is irrelevant when one has F or B
! ordering as all permutations are stored in one place (with some exceptions)
! Thus the endmembers are ordered alphabetically in the sublattices and also
! the interaction parameters.  Max 2 levels of interactions allowed.
   implicit none
   integer, dimension(*) :: iord,intperm
   integer, dimension(2,*) :: jord
   integer lokph,nsl,noperm,nint
 subroutine fccip2A(lokph,jord,intperm,intlinks)
! 2nd level interaction permutations for fcc
   implicit none
   integer, dimension(*) :: intperm
   integer, dimension(2,*) :: jord,intlinks
   integer lokph
 subroutine fccip2B(lq,lokph,lshift,jord,intperm,intlinks)
! 2nd level interaction permutations for fcc
   implicit none
   integer lq,lokph,lshift
   integer, dimension(*) :: intperm
   integer, dimension(2,*) :: jord,intlinks
 subroutine fccint31(jord,lshift,intperm,intlinks)
! 1st level interaction in sublattice l1 with endmember A:A:A:B or A:B:B:B
! set the sublattice and link to constituent for each endmember permutation
! 1st permutation of endmember: AX:A:A:B; A:AX:A:B; A:A:AX;B  4      0 1 2
! 2nd permutation of endmember: AX:A:B:A; A:AX:B:A; A:A:B:AX  3      0 1 3
! 3rd permutation of endmember: AX:B:A:A; A:B:AX:A; A:B:A:AX  3      0 2 3
! 4th permutation of endmember: B:AX:A:A; B:A:AX:A; B:A:A:AX  1 or   1 2 3
! 1st permutation of endmember: A:BX:B:B; A:B:BX:B; A:B:B:BX  4      0 1 2
! 2nd permutation of endmember: BX:A:B:B; B:A:BX:B; B:A:B:BX  1 etc -1 1 2
! 3rd -1 0 2 ; -1 0 1
! suck
   implicit none
   integer lshift
   integer, dimension(2,*) :: jord,intlinks
   integer, dimension(*) :: intperm
 subroutine fccint22(jord,lshift,intperm,intlinks)
! 1st level for endmember A:A:B:B with interaction in sublattice jord(1,1)
! 6 permutations of endmember, 2 permutations of interactions, 12 in total
! 1st endmemperm: AX:A:B:B; A:AX:B:B      0  1
! 2nd endmemperm: AX:B:A:B; A:B:AX:B      0  2
! 3rd endmemperm: AX:B:B:A; A:B:B:AX      0  3
! 4th endmemperm: B:AX:B:A; B:A:B:AX      1  3
! 5th endmemperm: B:B:AX:A; B:B:A:AX      2  3
! 6th endmemperm: B:AX:A:B; B:A:AX:B or   1  2
! 1th endmemperm: A:A:BX:B; A:A:B:BX      0  1
! 2nd endmemperm: A:BX:A:B; A:B:A:BX     -1  1
! 3rd endmemperm: A:BX:B:A; A:B:BX:A     -1  0
! 4th endmemperm: BX:A:B:A; B:A:BX:A     -2  0
! 5th endmemperm: BX:B:A:A; B:BX:A:A     -2 -1
! 6th endmemperm: BX:A:A:B; B:A:A:BX     -2  1
   implicit none
   integer lshift
   integer, dimension(2,*) :: jord,intlinks
   integer, dimension(*) :: intperm
 subroutine fccint211(a211,jord,lshift,intperm,intlinks)
! 1st level interaction in sublattice l1 with endmember like A:A:B:C
! 12 endmember permutations of AABC; ABBC; or ABCC
! 2 interaction permutations for each, 24 in total
   implicit none
   integer a211,lshift
   integer, dimension(2,*) :: jord,intlinks
   integer, dimension(*) :: intperm
 subroutine fccpe211(l1,elinks,nsl,lshift,iord)
! sets appropriate links to constituents for the 12 perumations of
! A:A:B:C (l1=1), A:B:B:C (l1=2) and A:B:C:C (l1=3)
   implicit none
   integer, dimension(nsl,*) :: elinks
   integer, dimension(*) :: iord
   integer l1,nsl,lshift
 subroutine fccpe1111(elinks,nsl,lshift,iord)
! sets appropriate links to 24 permutations when all 4 constituents different
! A:B:C:D
! The do loop keeps the same constituent in first sublattice 6 times, changing
! the other 3 sublattice, then changes the constituent in the first sublattice
! and goes on changing in the other 3 until all configurations done
   implicit none
   integer, dimension(nsl,*) :: elinks
   integer, dimension(*) :: iord
   integer nsl,lshift
\end{verbatim}
}

\subsubsection{Subroutines handling bcc permutatations}

Not implemented yet

{\small
\begin{verbatim}
 subroutine bccpermuts(lokph,nsl,iord,noperm,elinks,nint,jord,intperm,intlinks)
! finds all bcc permutations needed for this parameter
   implicit none
   integer lokph,nsl,noperm,nint
   integer, dimension(*) :: iord,intperm
   integer, dimension(2,*) :: jord
   integer, dimension(:,:), allocatable :: elinks
   integer, dimension(:,:), allocatable :: intlinks
\end{verbatim}
}

\subsubsection{Find constituent}

{\small
\begin{verbatim}
 subroutine findconst(lokph,ll,spix,constix)
! locates the constituent index of species with index spix in sublattice ll
! and returns it in constix.  For wildcards spix is -99; return -99
! THERE MAY ALREADY BE A SIMULAR SUBROUTINE ... CHECK
   implicit none
   integer lokph,ll,spix,constix
\end{verbatim}
}

\subsubsection{Enter references for parameter data}

{\small
\begin{verbatim}
 subroutine tdbrefs(refid,line,mode,iref)
! store a reference from a TDB file or given interactivly
! If refid already exist and mode=1 then amend the reference text
   implicit none
   character*(*) refid,line
   integer mode,iref
\end{verbatim}
}

\subsubsection{Enter equilibrium}

The equilibrium record as explained in
section~\ref{sec:equilibriumrec} has all data necessary for specifying
an equilibrium: conditions, compoenets, phases etc.  One may have
several equilibria with different sets of conditions but normally they
have the same set of phases (the set of stable phases may differ).
This can be used to interactivly compare different states or used in
parallel processing where each thread is connected with an equilibrium
record.  When assessing model parameter each experimental datum can be
described by an equilibrium record.

{\small
\begin{verbatim}
 subroutine enter_equilibrium(name,number)
! creates a new equilibrium.  Allocates arrayes for conditions,
! components, phase data and results etc.
! returns index to new equilibrium record
! THIS CAN PROBABLY BE SIMPLIFIED, especially phase_varres array can be
! copied as a whole, not each record structure separately ... ???
   implicit none
   character name*(*)
   integer number
\end{verbatim}
}

\subsubsection{Check that a phase is allowed to have fcc permutations}

Some minimal checks made.

{\small
\begin{verbatim}
 logical function check_minimal_ford(lokph)
! some tests if the fcc/bcc permutation model can be applied to this phase
! The function returns FALSE if the user may set the FORD or BORD bit of lokph
   implicit none
   integer lokph
\end{verbatim}
}

%%%%%%%%%%%%%%%%% here starts pmod25H.F90

\subsection{Status for things}

There are many status bits in various records.  These subroutines
and function set, clear or test these.

Setting means to set the bit to 1 and clearing means to set the
bit to 0.  A problem is that I always mix up if BTEST return TRUE
or FALSE it the bit is set.

The subroutines and functions in this section should be simplified.

\subsubsection{Set status for elements}

An element can be entered or suspended.

{\small
\begin{verbatim}
 subroutine change_element_status(elname,nystat,ceq)
! change the status of an element, can affect species and phase status
! nystat:0=entered, 1=suspended, -1 special (exclude from sum of mole fraction)
!
! suspending elements for each equilibrium separately not yet implemented
!
   implicit none
   character elname*(*)
   integer nystat
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Test status for element}

An element can be entered or suspended.

{\small
\begin{verbatim}
 logical function testelstat(iel,status)
! return value of element status bit
   implicit none
   integer iel,status
\end{verbatim}
}

\subsubsection{Set status for species}

A species can be entered or suspended.

{\small
\begin{verbatim}
 subroutine change_species_status(spname,nystat,ceq)
! change the status of a species, can affect phase status
! nystat:0=entered, 1=suspended
   implicit none
   integer nystat
   character spname*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Test status for species}

A species can be entered or suspended.

{\small
\begin{verbatim}
 logical function testspstat(isp,status)
! return value of species status bit
   implicit none
   integer isp,status
\end{verbatim}
}

\subsubsection{Get and test status for phase}

Get and test phase status are almost identical but the get routine
returns some additional informantion.  Note that there are also phase
bits that determine the model used.

{\small
\begin{verbatim}
 integer function get_phase_status(iph,ics,text,ip,val,ceq)
! return phase status as text and amount formula units in val
! for entered and fix phases also phase amounts.
! Function value: 1=entered, 2=fix, 3=dormant, 4=suspended, 5=hidden
   implicit none
   character text*(*)
   integer iph,ics,ip
   TYPE(gtp_equilibrium_data), pointer :: ceq
   double precision val
 integer function test_phase_status(iph,ics,val,ceq)
! Almost same as get_..., returns phase status as function value but no text
! 1=entered, 2=fix, 3=dormant, 4=suspended, 5=hidden
! this is different from in change_phase .... one has to make up one's mind
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer iph,ics
   double precision val
\end{verbatim}
}

\subsubsection{Set phase model bit}

This sets bits indicating if the phase is ideal, has fcc ordering etc.

{\small
\begin{verbatim}
 subroutine set_phase_status_bit(lokph,bit)
! set the status bit "bit" in status1, cannot be done outside this module
! as the phlista is private
! These bits do not depend on the composition set
   implicit none
   integer lokph,bit
\end{verbatim}
}

\subsubsection{Unset phase model bit}

The opposite of the previous subroutine.

{\small
\begin{verbatim}
 subroutine unset_phase_status_bit(lokph,bit)
! clear the status bit "bit" in status1, cannot be done outside this module
! as the phlista is private
   implicit none
   integer lokph,bit
\end{verbatim}
}

\subsubsection{Change status for phase}

Changes status bits for a phase or all if qph negative Note NYSTAT
values are different from this in GET and TEST above.  Same values
should be used.

{\small
\begin{verbatim}
 subroutine change_phase_status(qph,ics,nystat,val,ceq)
! change the status of a phase. Also used when setting phase fix etc.
! nystat:0=entered, 1=suspended, 2=dormant, 3=fix, 4=hidden,5=not hidden
   implicit none
   integer qph,ics,nystat
   double precision val
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Test phase record status bits}

This can be used to test bits in the status1 word in the phase record
to know if the phase is ideal, a gas etc., see \ref{sec:phasebits}.

{\small
\begin{verbatim}
 logical function phase_bit(iph,ibit)
! return TRUE is status bit ibit for  phase iph, is set
! because phlista is private.  Needed to test for gas, ideal etc,
! DOES NOT TEST STATUS liske entered/fixed/dormant/suspended
   implicit none
   integer iph,ibit
\end{verbatim}
}

\subsubsection{Set reference state for a component}

Setting the reference state of a component.

{\small
\begin{verbatim}
 subroutine set_reference_state(icomp,iph,tpval,ceq)
! set the reference state of a component to be "iph" at tpval
   implicit none
   integer icomp,iph
   double precision, dimension(2) :: tpval
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Set unit for energy etc.}

This is not yet implemented.

{\small
\begin{verbatim}
 subroutine set_unit(property,unit)
! set the unit for a property, like K, F or C for temperature
! >>>> unfinished
   implicit none
   character*(*) property,unit
\end{verbatim}
}

\subsubsection{Save results for a phase}

This is not yet implemented.

{\small
\begin{verbatim}
 subroutine save_results(lut,iph,ics,long)
! write calculated results for a phase for later use in POST
   implicit none
   integer lut,iph,ics,long
\end{verbatim}
}

\subsubsection{Set reference state for constituent}

This is not yet implemented.

{\small
\begin{verbatim}
 subroutine set_constituent_reference_state(iph,icon,asum)
! determine the end member to calculate as reference state for this constituent
! Used when giving a chemical potential for a constituent like MU(GAS,H2O)
   implicit none
   integer iph,icon
   double precision asum
\end{verbatim}
}

\subsubsection{calculate conversion matrix for new components}

{\small
\begin{verbatim}
 subroutine elements2components(nspel,stoi,ncmp,cmpstoi,ceq)
! converts a stoichiometry array for a species from elements to components
   implicit none
   integer nspel,ncmp
   double precision stoi(*),cmpstoi(*)
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsection{Internal stuff}

The subroutines in this section are internal and not to be used by
calls from outside GTP.

\subsubsection{Alphabetical ordering}

The elements, species and phases are stored in the arrays ELLISTA,
SPLISTA and PHLISTA in the order they are entered.  They are sorted in
alphabetical order in the array ELEMENTS, SPECIES and PHASES.  These
routines are used to maintain the alphabetical order.

{\small
\begin{verbatim}
 subroutine alphaelorder
! arrange new element in alphabetical order
! also make alphaindex give alphabetical order
   implicit none
 subroutine alphasporder
! arrange new species in alphabetical order
! also make alphaindex give alphabetical order
   implicit none
 subroutine alphaphorder
! arrange last added phase in alphabetical order
! also make alphaindex give alphabetical order
! phletter G and L and I have priority
   implicit none
\end{verbatim}
}

\subsubsection{Check alphaindex}

Just for testing.

{\small
\begin{verbatim}
 subroutine check_alphaindex
! just for debugging, check that ellist(i)%alphaindex etc is  correct
   implicit none
\end{verbatim}
}

\subsubsection{Create constlist}

{\small
\begin{verbatim}
 subroutine create_constitlist(constitlist,nc,klist)
! creates a constituent list ...
   implicit none
   integer, dimension(*) :: klist
   integer, dimension(:), allocatable :: constitlist
   integer nc
\end{verbatim}
}

\subsubsection{Create phase\_varres record for composition sets}

This should probably be rewritten as I did not know much of F08 when
it was written.

{\small
\begin{verbatim}
 subroutine create_parrecords(lokcs,nsl,nc,nprop,iva,ceq)
! fractions and results arrays for a phase for parallell calculations
! location is returned in lokcs
! nsl is sublattices, nc number of constituents, nprop max number if propert,
! iva is an array which is set as constituent status word (to indicate VA)
! ceq is always firsteq ???
!
! BEWARE not adopted for threads
!
! >>> changed all firsteq below to ceq????
!
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer, dimension(*) :: iva
   integer lokcs, nsl, nc, nprop
\end{verbatim}
}

\subsubsection{Create interaction record}

Finds the correct place to add an interaction parameter.  It should
always be linked from the first possible endmember (with the
alphabetically first constituents) and then in alphabetical order of
the interaction elements.

{\small
\begin{verbatim}
 subroutine create_interaction(intrec,mint,lint,intperm,intlinks)
! creates a parameter interaction record
! with permutations if intperm(1)>0
   implicit none
   type(gtp_interaction), pointer :: intrec
   integer, dimension(2,*) :: lint,intlinks
   integer, dimension(*) :: intperm
   integer mint
\end{verbatim}
}

\subsubsection{Create endmember record}

Creates a record for an endmember.  Sometimes endmembers have
no property records if there are interaction parameters must be
linked from this endmember.

{\small
\begin{verbatim}
 subroutine create_endmember(lokph,newem,noperm,nsl,endm,elinks)
! create endmember record with nsl sublattices with endm as constituents
! noperm is number of permutations
! endm is the basic endmember
! elinks are the links to constituents for all permutations
   implicit none
   integer endm(*)
   type(gtp_endmember), pointer :: newem
   integer, dimension(nsl,noperm) ::elinks
   integer lokph,noperm,nsl
\end{verbatim}
}

\subsubsection{Create property record}

All parameter values for an endmember or interaction record are
stored in property records.  An endmember or interaction parameter
may have several property records linked in a list.  

{\small
\begin{verbatim}
 subroutine create_proprec(proprec,proptype,degree,lfun,refx)
! reservs a property record from free list and insert data
   implicit none
   TYPE(gtp_property), pointer :: proprec
   integer proptype,degree,lfun
   character refx*(*)
\end{verbatim}
}

\subsubsection{Extend property record}

An interaction record can have a degree and each degree a function.
When entering a funtion for a higher degree than in the current
property record it must be extended.

{\small
\begin{verbatim}
 subroutine extend_proprec(current,degree,lfun)
! extends a property record  and insert new data
   implicit none
   integer degree,lfun
   type(gtp_property), pointer :: current
\end{verbatim}
}

\subsubsection{Create a new phase\_varres record}

The phase\_varres record belog to the dynamic dataset in the
equilibrium record.  When creating new equilibrium records or
composition sets new phase\_varres records are needed.

{\small
\begin{verbatim}
 subroutine new_phase_varres_record(iph,phvar,ceq)
! this subroutine returnes a copy of the phase variable structure for iph
! >>>>>>>>>>>>>
! this subroutine is probably redundant since the structure
! gtp_equilibrium_data was introduced.  Each parallell tread should have
! its own gtp_equilibrium_data record.
! >>>>>>>>>>>>>>>>>>>>>>>>>>
! The programmer can enter fraction in this structure and use it in calls
! to parcalcg should be suitable for parallel processing (NOT TESTED)
! when the same phase is calculated in several threads (like when separate
! threads calculate different lines suring mapping)
   implicit none
! >>>> unfinished
! >>>> for calculation of the same phase in separate threads
   integer iph
   TYPE(gtp_equilibrium_data) :: ceq
   TYPE(gtp_phase_varres) :: phvar
\end{verbatim}
}

\subsubsection{Add a disordered fraction set record}

A phase with sublattices for long range ordering may have a fraction
set representing the disordered phase.  That can be for an fcc phase
where the disordered fractions represent the disordered state or for a
sigma phase where the disordered fractions represent some kind of
hypothetical state.  A disordered fraction set can have its own set of
parameters,

{\small
\begin{verbatim}
 subroutine new_disordered_phase_variable_record(lokdis,phvar,phdis,ceq)
! Does this really work????
! creates a copy of the disordered phase variable record lokdis
! and set links from ordered phvar
!   ?????????????? does this work ??????????  is it necessary ????
! can one just make an assignment ????
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
   TYPE(gtp_phase_varres) :: phvar
   TYPE(gtp_phase_varres), target :: phdis
   integer lokdis
\end{verbatim}
}

\subsubsection{Add a fraction set record}

{\small
\begin{verbatim}
 subroutine add_fraction_set(iph,id,ndl,totdis)
! add a new set of fractions to a phase, usually to describe a disordered state
! like the "partitioning" in old TC
!
! BEWARE this is only done for firsteq, illegal when having more equilibria
!
! id is a letter used as suffix to identify the parameters of this set
! ndl is the last original sublattice included in the (first) disordered set
! ndl can be 1 meaning sublattice 2..nsl are disordered, or nsl meaning all are
!     disordered
! totdis=0 if phase never disorder totally (like sigma)
!
! For a phase like (Al,Fe,Ni)3(Al,Fe,Ni)1(C,Va)4 to add (Al,Fe,Ni)4(C,Va)4
! icon=1 2 3 1 2 3 4 5 with ndl=2
! For a phase like (Fe,Ni)10(Cr,Mo)4(Cr,Fe,Mo,Ni)16 then
! icon=2 4 1 3 1 2 3 4 with ndl=3
! This subroutine will create the necessary data to calculate the
! disordered fraction set from the site fractions.
!
! IMPORTANT (done): for each composition set this must be repeated
! if new composition sets are created it must be repeated for these
!
! IMPORTANT (not done): order the constituents alphabetically in each disorderd
! sublattice otherwise it will not be possible to enter parameters correctly
!
   implicit none
   integer iph,ndl,totdis
   character id*1
\end{verbatim}
}

\subsubsection{Copy record for fraction sets}

{\small
\begin{verbatim}
 subroutine copy_fracset_record(lokcs,disrec,ceq)
! attempt to create a new disordered record  ??? this can probably be done
! with just one statement .. but as it works I am not changing right now
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
   TYPE(gtp_fraction_set) :: disrec
   integer lokcs
\end{verbatim}
}

\subsubsection{Implicit suspend and restore}

If an element is suspended some species may have to be suspended too
and if a species is suspended some phases may have to be suspended.
This routine does that.

{\small
\begin{verbatim}
 subroutine suspend_species_implicitly(ceq)
! loop through all entered species and suspend those with an element suspended
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
 subroutine suspend_phases_implicitly(ceq)
! loop through all entered phases and suspend constituents and
! SUSPEND phases with all constituents in a sublattice suspended
!   dimension lokcs(9)
   implicit none
   TYPE(gtp_equilibrium_data) :: ceq
 subroutine restore_species_implicitly_suspended
! loop through all implicitly suspended species and restore those with
! all elements enteded
   implicit none
 subroutine restore_phases_implicitly_suspended
! loop through all implicitly suspended phases and restore those with
! at least one constituent entered in each sublattice
   implicit none
\end{verbatim}
}

\subsubsection{Add to reference phase}

There is a reference phase that should have parameters for each
element it its stable state at all temperatures and 1 bar.  For each
element eneterd this subroutine adds it to the reference phase.  This
phase can never be used in calculations.  It represent different
phases for each element, gas for H, bcc for Cr etc.

{\small
\begin{verbatim}
 subroutine add_to_reference_phase(loksp)
! add this element to the reference phase
! loksp: species index of new element
   implicit none
   integer loksp
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%% here starts pmod25I.F90

\subsection{Additions}

Creating, handling and calculations of additions to the Gibbs energy.
This is a section that will probably be extended with several new
subroutines for different kinds of additions.

{\small
\begin{verbatim}
 subroutine addition_selector(addrec,moded,phres,lokph,mc,ceq)
! called when finding an addtion record while calculating G for a phase
! addrec is addition record
! moded is 0, 1 or 2 if no, first or 2nd order derivatives should be calculated
! phres is ?
! lokph is phase location
! mc is number of constitution fractions
! ceq is current equilibrium record
   implicit none
   type(gtp_phase_add), pointer :: addrec
   integer moded,lokph,mc
   TYPE(gtp_phase_varres), pointer :: phres
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Generic subroutine to add an addition}

Not well structured here.

{\small
\begin{verbatim}
 subroutine add_addrecord(iph,addtyp)
! generic subroutine to add an addition typ addtyp (Except Inden)
   implicit none
   integer iph,addtyp
\end{verbatim}
}

\subsubsection{Utility routine for addition}

Searches for the composition dependent properties for a specific
addition.

{\small
\begin{verbatim}
 subroutine need_propertyid(id,typty)
! get the index of the property needed
   implicit none
   integer typty
   character*4 id
\end{verbatim}
}

\subsubsection{Enter and calculate Inden magnetic 
model}\label{sec:calculateinden}

The first two subroutines create the ferromagnetic addition due to
Inden model and store all necessary data inside this.  The last
subroutine is called when calculating the Gibbs energy for a phase if
there is a magnetic addition linked to the phase.  It must calculate
the contribution to G and all first and second derivates of G.

In the call the pointer to the phase\_varres record is provided where
current values of G and derivatives can be found.  Values of the
ferromagnetic temperature and its derivatives with respect to
constititution is also stored there. The chain rule for derivatives
must be applied.

{\small
\begin{verbatim}
 subroutine add_magrec_inden(lokph,addtyp,aff)
! adds a magnetic record to lokph
! lokph is phase location
! addtyp should be 1 of Inden model
! aff is antiferromagnic factor, -1 for bcc and -3 for fcc and hcp
   implicit none
   integer lokph,addtyp,aff
 subroutine create_magrec_inden(addrec,aff)
! enters the magnetic model
   implicit none
   type(gtp_phase_add), pointer :: addrec
   integer aff
 subroutine calc_magnetic_inden(moded,phres,lokadd,lokph,mc,ceq)
! calculates Indens magnetic contribution
! NOTE: values for function not saved, should be done to save time.
! Gmagn = RT*f(T/Tc)*ln(beta+1)
! moded: integer, 0=only G, S, Cp; 1=G and dG/dy; 2=Gm dG/dy and d2G/dy2
! phres: pointer, to phase\_varres record
! lokadd: pointer, to addition record
! lokph: integer, phase record
! mc: integer, number of constituents
! ceq: pointer, to gtp_equilibrium_data
   implicit none
   integer moded,lokph,mc
   TYPE(gtp_phase_varres) :: phres
   TYPE(gtp_phase_add), pointer :: lokadd
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Create new magnetic model}\label{sec:addewei}

Wei Xiagong has proposed a simplified magnetic model.  It is
not yet implemented.

{\small
\begin{verbatim}
 subroutine create_weimagnetic(addrec,bcc)
! adds a wei type magnetic record, we must separate fcc and bcc but no aff!!
! copied from Inden magnetic model
! The difference is that it uses TCA for Curie temperature and TNA for Neel
! and individual Bohr magneton numbers
   implicit none
   logical bcc
   type(gtp_phase_add), pointer :: addrec
 subroutine calc_weimagnetic(moded,phres,lokadd,lokph,mc,ceq)
! calculates Wei-Indens magnetic contribution
!
! NOTE this is just copied from Inden subroutine, must be changed
!
! Gmagn = RT*f(T/Tc)*ln(beta+1)
! moded: integer, 0=only G, S, Cp; 1=G and dG/dy; 2=Gm dG/dy and d2G/dy2
! phres: pointer, to phase\_varres record
! lokadd: pointer, to addition record
! lokph: integer, phase record
! mc: integer, number of constituents
! ceq: pointer, to gtp_equilibrium_data
   implicit none
   integer moded,lokph,mc
! phres points to result record with gval etc for this phase
   TYPE(gtp_phase_varres) :: phres
   TYPE(gtp_phase_add), pointer :: lokadd
   TYPE(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Calculate and calculate elastic
contribution}\label{sec:add elast}

This creates and calculates the elastic record.

{\small
\begin{verbatim}
 subroutine create_elastic_model_a(newadd)
! addition record to calculate the elastic energy contribution
   implicit none
   type(gtp_phase_add), pointer :: newadd
 subroutine calc_elastica(moded,phres,addrec,lokph,mc,ceq)
! calculates elastic contribution and adds to G and derivatives
   implicit none
   integer moded,lokph,mc
   type(gtp_phase_varres), pointer :: phres
   type(gtp_phase_add), pointer :: addrec
   type(gtp_equilibrium_data), pointer :: ceq
 subroutine set_lattice_parameters(iph,ics,xxx,ceq)
! temporary way to set current lattice parameters for use with elastic model a
   implicit none
   integer iph,ics
   double precision, dimension(3,3) :: xxx
   type(gtp_equilibrium_data) :: ceq
\end{verbatim}
}

\subsubsection{Heat capacity model for Einstein solids}

Unfinished

{\small
\begin{verbatim}
 subroutine create_einsteincp(newadd)
   implicit none
   type(gtp_phase_add), pointer :: newadd
 subroutine calc_einsteincp(moded,phres,addrec,lokph,mc,ceq)
! Calculate the contibution due to Einste Cp model for low T
! moded 0, 1 or 2
! phres all results
! addrec pointer to addition record
! lokph phase record
! mc number of variable fractions
! ceq equilibrum record
!
! G = 3*R*T*ln( 1 - exp( THET/T ) )
! This is easier to handle inside the calc routine without TPFUN
!
   implicit none
   integer moded,lokph,mc
   type(gtp_phase_varres), pointer :: phres
   type(gtp_phase_add), pointer :: addrec
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Glas addition}

Unfinished

{\small
\begin{verbatim}
 subroutine create_glas_transition_modela(newadd)
! not implemented
   implicit none
   type(gtp_phase_add), pointer :: newadd
\end{verbatim}
}

\subsubsection{Debye heat capacity model}

These subroutines are called to create and calculate the Gibbs energy
contribution for a phase if there is a Debye model addition linked to
the phase.  It must calculate the contribution to G and all first and
second derivates of G.  Careful study of the Inden magnetic model
record is recommended.

In the call the pointer to the phase\_varres record is provided where
current values of G and derivatives can be found.  Values of the Debye
temperature and its derivatives with respect to constititution is also
stored there. The chain rule for derivatives must be applied.

Unfinished.

{\small
\begin{verbatim}
 subroutine create_debyecp(addrec)
! enters a record for the debye model
   implicit none
   type(gtp_phase_add), pointer :: addrec
 subroutine calc_debyecp(moded,phres,lokadd,lokph,mc,ceq)
! calculates Mauro Debye contribution
! NOTE: values for function not saved, should be done to save calculation time.
! moded: integer, 0=only G, S, Cp; 1=G and dG/dy; 2=Gm dG/dy and d2G/dy2
! phres: pointer, to phase\_varres record
! lokadd: pointer, to addition record
! lokph: integer, phase record
! mc: integer, number of constituents
! ceq: pointer, to gtp_equilibrium_data
   implicit none
   integer moded,lokph,mc
   TYPE(gtp_equilibrium_data) :: ceq
   TYPE(gtp_phase_add), pointer :: lokadd
   TYPE(gtp_phase_varres) :: phres
\end{verbatim}
}

\subsubsection{List additions}\label{sec:listadditions}

When listing data for a phase with addition the relevant information
must be listed also for additions.

{\small
\begin{verbatim}
 subroutine list_addition(unit,lokph,lokadd)
! list description of an addition for a phase on unit
   implicit none
   integer unit,lokph
   TYPE(gtp_phase_add), pointer :: lokadd
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%% here starts pmod25J.F90

\subsection{Grid minimizer}

When there is only massbalance conditions it is possible to use a
global minimization technique to find start points for a more standard
Newton-Raphson technique.  The latter has the disadvantage that it can
only find local minima.

Tn the global minimization all solution phases are divided into a grid
with fixed compositions and the Gibbs energy for each gridpoint is
calculated.  These gridpoints are then searched until one finds a set
that encloses the given overall composition which represent the
minimal Gibbs energy.  It is thus necessary to know the overall
composition.

The phases the gridpoints in the solution are then identified and
possibly one can merge gridpoints in the same phase unless they are
separated by a miscibility gap.

Some care should be taken with ordered phases as they have several
identical sublattices and one thus can reduce significantly the number
of gridpoints generated if this is taken into account.

\subsubsection{Global Gridminimizer}

This is the main grid minimizing subroutine.  It should be modified to
be callable also after an equilibrium calculation to chack if there
are any phases below the calculated G hypersurface.

{\small
\begin{verbatim}
 subroutine global_gridmin(what,tp,xknown,nvsph,iphl,icsl,aphl,&
      nyphl,yphl,cmu,ceq)
!
! finds a set of phases that is a global start point for an equilibrium
! calculation at T and P values in tp and known mole fraction in xknown
! It is intentional that this routine is independent of current conditions
! returns: nvsph stable phases, list of phases in iphl, amounts in aphl,
! constitution in yphl (compact after each other, nyphl(i) is number of
! fractions in phase i), cmu are element chemical potentials of solution
! WHAT determine what to do with the results, 0=just return solution,
! 1=enter stable set and constitution of all phases in gtp datastructure
! and create composition sets if necessary (and allowed)
! what=-1 will check if any gridpoint below current calculated equilibrium
   implicit none
! nyphl(j) is the start position of the constitiuent fractions of phase j in
! yphl that contains all the constitutions of the phases in the gridpoints
   integer, dimension(*) :: iphl,nyphl,icsl
   integer what,nvsph
   TYPE(gtp_equilibrium_data), pointer :: ceq
   double precision, dimension(2) :: tp
! cmu(1..nrel) is the chemical potentials of the solution
   double precision, dimension(*) :: xknown,aphl,yphl,cmu
\end{verbatim}
}

\subsubsection{Generate grid}

This is a very rudimentary grid generator.

{\small
\begin{verbatim}
 subroutine generate_grid(mode,iph,ngg,nrel,xarr,garr,ny,yarr,ceq)
! Different action depending of the value of mode,
! for mode<0:
!    return the number of gridpoints that will be generated for phase iph
! for mode=0:
!    return garr(i) gibbs energy and xarr(1,i) the compositions of gridpoint i
! for mode>0:
!    return site fractions of gridpoint mode in yarr, number of fractions in ny
!    iph is phase number, ngg is number of gridpoints, nrel number of elements,
! if mode=0:
!    return xarr mole fractions of gridpoints, garr Gibbs energy of gridpoints,
!    ngg is dimension of garr
! if mode>0:
!   "mode" is a gridpoint of this phase in solution, return number of
!   constituent fractions in ny and fractions in yarr for this gridpoint
! The current constitution is restored at the end of the subroutine
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer mode,iph,ngg,nrel,ny
   real xarr(nrel,*),garr(*)
   double precision yarr(*)
\end{verbatim}
}

\subsubsection{Calculate gridpoint}

The Gibbs energy for each gridpoint is calculated as well as its
composition.

{\small
\begin{verbatim}
 subroutine calc_gridpoint(iph,yfra,nrel,xarr,gval,ceq)
! called by global minimization routine
! Not adopted to charged crystalline phases as gridpoints have net charge
   implicit none
   real xarr(*),gval
   integer iph,nrel
   double precision yfra(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Calculate endmember}

This is used by the calc\_gridpoint routine.

{\small
\begin{verbatim}
 subroutine calcg_endmember(iph,endmember,gval,ceq)
! calculates G for one mole of real atoms for a single end member
! used for reference states. Restores current composition (but not G or deriv)
! endmember contains indices in the constituent array, not species index
   implicit none
   integer iph
   double precision gval
   integer endmember(maxsubl)
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Calculate minimum of grid}\label{sec:findgridmin}

The search starts from the lowest G value for the pure elements.
(This seems obvious but makes it impossible to have a grid for only
fcc with carbon dissolved as fcc does not exist for pure carbon).  The
selected gridpoints always represent a hyperplane (number of
dimensions equal to that of the number of components) of Gibbs energy
over the whole composition range.  Then the whole grid is searched for
the gridpoint that has the most negative deviation from this
hyperplane.  Then one gridpoint in the existing hyperplance is
replaced by this in such a way that the overall massbalance is inside
the points forming the plane.  Then a new search is made and a point
is replaced until there are no points below the hyperplane.  The
points forming this plane represent the solution.  There will always
be as many points as components.

{\small
\begin{verbatim}
 subroutine find_gridmin(kp,nrel,xarr,garr,xknown,jgrid,phfrac,cmu,trace)
! there are kp gridpoints, nrel is number of components
! composition of each gridpoint in xarr, G in garr
! xknown is the known overall composition
! return the gridpoints of the solution in jgrid, the phase fraction in phfrac
! cmu are the final chemical potentials
   implicit none
   integer, parameter :: jerr=50
   integer kp,nrel
   integer, dimension(*) :: jgrid
   real xarr(nrel,*),garr(*)
   double precision xknown(*),phfrac(*),cmu(nrel)
   logical trace
\end{verbatim}
}

\subsubsection{Merge gridpoints in same phase}

This subroutine tries to check if the number of gridpoints can be
reduced by merging gridpoints in the same phase.  Care must be taken
that there can be miscibility gaps between points.

This subroutine may automatically create new composition sets if
necessay (unless the user has set the appropriate bit to prevent
that).

{\small
\begin{verbatim}
 subroutine merge_gridpoints(nv,iphl,aphl,nyphl,yphl,trace,nrel,xsol,cmu,ceq)
!
! BEWARE not adopted for parallel processing
!
! if the same phase occurs several times check if they are really separate
! (miscibility gaps) or if they can be murged.  Compare them two by two
! nv is the number of phases, iphl(i) is the index of phase i, aphl(i) is the
! amount of phase i, nyphl is the number of site fractions for phase i,
! and yphl is the site fractions packed together
!
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer nv,nrel
   integer, dimension(*) :: iphl,nyphl
   double precision, dimension(*) :: aphl,yphl,cmu
   logical trace
   real xsol(maxel,*)
\end{verbatim}
}

\subsubsection{Set constitution of metastable phases}

Phases not part of the final solution will have their constitution set
to a gridpoint that is closeset to the final hyperplane.

{\small
\begin{verbatim}
 subroutine set_metastable_constitutions(ngg,nrel,kphl,ngrid,xarr,garr,&
      nr,iphl,cmu,ceq)
! this subroutine goes through all the metastable phases
! after a global minimization and sets the constituion to the most
! favourable one.  Later care should be taken that composition set 2
! and higher are not set identical or equal to the stable
! kp    total number of gridpoints
! nrel  number of components
! ngg   number of gridpoints
! kphl  array with first points calculated for phase(i) in garr
! ngrid array with last  points calculated for phase(i) in garr
! garr  array with Gibbs energy/RT for each gridpoint
! xarr  matix with composition in all gridpoints
! nr    is the number of stable phases in the solution
! iphl  array with the phase numbers of the stable phases (not ordered)
! cmu   are the chemical potentials/RT of the solution
! ceq   equilibrium record
! called by global_gridmin
   implicit none
   integer ngg,nrel,nr
   integer, dimension(*) :: kphl,ngrid,iphl
   double precision, dimension(*) :: cmu
   real garr(*),xarr(nrel,*)
   type(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsection{Miscellaneous things}

Things that does not fit anywhere else.

\subsubsection{Phase record location}

{\small
\begin{verbatim}
 integer function phvarlok(lokph)
! return index of the first phase_varres record for phase with location lokph
! needed for external routines as phlista is private
   implicit none
   integer lokph
\end{verbatim}
}

\subsubsection{Numbers an interaction tree for permutations}

For permutations it turned out to be necessary to keep track of the
individual interaction records to know the permutation.  This
subroutine indexes the interaction records for each endmember of a
phase.

{\small
\begin{verbatim}
 subroutine palmtree(lokph)
! Initiates a numbering of all interaction trees of an endmember of a phase
   implicit none
   integer lokph
\end{verbatim}
}

\subsubsection{Check that certain things are allowed}

To have a uniform check if something is allowed.  One must not
enter a phase before there are any elements for example.

{\small
\begin{verbatim}
 logical function allowenter(mode)
! Check if certain commands are allowed
! mode=1 means entering an element or species
! mode=2 means entering a phase
! mode=3 means entering an equilibrium
! returns TRUE if command can be executed
   implicit none
   integer mode
\end{verbatim}
}

\subsubsection{Check proper symbol}

There are many symbols and names in the GTP package.  In general a
symbol must start with a letter A-Z.  All symbols are also case
insensitive, i.e. upper and lower case are treated as the same.  Most
symbols may conatain digits as second and later character.  Some
symbols and names may contain special characters like ``\_'' and
others.

This subroutine checks this.

{\small
\begin{verbatim}
 logical function proper_symbol_name(name,typ)
! checks that name is a proper name for a symbol
! A proper name must start with a letter A-Z
! for typ=0 it must contain only letters, digits and underscore
! for typ=1 it may contain also +, - maybe ?
   implicit none
   integer typ
   character name*(*)
\end{verbatim}
}

\subsubsection{Total number of phases and composition sets}

This is used when dimensioning arrays for calculations.

{\small
\begin{verbatim}
 subroutine sumofphcs(npx,ceq)
! returns the total number of unhidden and unsuspended phases+composition sets
! in the system.  Used for dimensioning work arrays and in loops
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer npx
\end{verbatim}
}

\subsubsection{Set default constitution}

The constitution of a phase is set to its default constitution

{\small
\begin{verbatim}
 subroutine enter_default_constitution(iph,ics,mmyfr,ceq)
! set values of default constitution
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer iph,ics
   real mmyfr(*)
\end{verbatim}
}

\subsubsection{The amount of a phase is set to a value}

I am not sure when this is used or needed.

{\small
\begin{verbatim}
 subroutine set_phase_amounts(jph,ics,val,ceq)
! set the amount formula units of a phase
! iph can be -1 meaning all phases, all composition sets
   implicit none
   integer jph,ics
   double precision val
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Create a default constitution}

I am not sure when this is used and if it is needed.

{\small
\begin{verbatim}
 subroutine set_default_constitution(jph,ics,all,ceq)
! set the current constitution to the default constitution
! iph can be -1 meaning all phases, all composition sets
! if all=-1 then change constitution of all phases, else just those not stable
! do not change the amounts of the phases
   implicit none
   integer all,jph,ics
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Subroutine to prepare for an equilibrium calculation}

Unfinished

{\small
\begin{verbatim}
 subroutine todo_before(mode,ceq)
! this could be called before an equilibrium calculation
! It removes any phase amounts and clears CSSTABLE
! DUMMY
!
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer mode
\end{verbatim}
}

\subsubsection{Subroutine to clean up after an equilibrium calculation}

Unfinished

{\small
\begin{verbatim}
 subroutine todo_after_found_equilibrium(mode,ceq)
! this is called after an equilibrium calculation
! It marks stable phase (set CSSTABLE and remove any CSAUTO)
! remove redundant unstable composition sets created automatically
! (CSAUTO set).  It will also shift stable composition sets to loweest
! possible (it will take into account if there are default constituent
! fractions, CSDEFCON set).
! mode determine some of the actions
!
! >>>>>>>>>>> THIS IS DANGEROUS IN PARALLELL PROCESSING
! It should work in step and map as a composition set that once been stable
! will never be removed except if one does global minimization during the
! step and map. Then  metallic-FCC and MC-carbides may shift composition sets.
! Such shifts should be avoided by manual entering of comp.sets with
! default constitutions, but comparing a stable constitution with a
! default has not been implemented yet.
!
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   integer mode
\end{verbatim}
}

\subsubsection{Select composition set for stable phase}

This has not yet been written.  It is part of the global gridminimizer
but also useful in other cases when one has two or more composition
sets with user defined default consititutions, like fcc\#1 with little
C and fcc\#2 with a lot of C.  Then a carbide rich fcc phase should be
fcc\#2 and not fcc\#1 even if fcc\#1 is not stable.

This routine should handle such thing but it is not implemented.

{\small
\begin{verbatim}
 subroutine select_composition_set(iph,ics,yarr,ceq)
! if phase iph wants to become stable and there are several composition sets
! this subroutine selects the one with default composition set that fits best.
! For example if an FCC phase that could be an austenite (low carbon content)
! or a cubic carbo-nitride (high carbon or nitrogen content, low vacancy)
! Less easy to handle ordered phases like B2 or L1_2 as ordering can be
! in any sublatittice ... option B and F needed
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: ceq
   double precision, dimension(*) :: yarr
   integer iph,ics
\end{verbatim}
}

\subsection{Unfinished things}

There are many unfinished parts among the other sections, in
particular the save/read section.

\subsubsection{Set reference state for a component}

This is not yet implemented.

{\small
\begin{verbatim}
 subroutine set_reference_state(comp,phase,tpval,ceq)
! set the reference state of a component to be phase at tpval
   implicit none
   integer icomp,iph
   double precision, dimension(2) :: tpval
   TYPE(gtp_equilibrium_data), pointer :: ceq
\end{verbatim}
}

\subsubsection{Dump results}

This is not yet implemented.

{\small
\begin{verbatim}
 subroutine dump_phase_results(lut)
! write calculated results for a phase for later use in POST
! not implemented yet
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%% this in the tpfun.F90 file

\section{TP functions}

TP functions are a subpackage inside GTP.  These can store simple
expressions depending on T and P including unary functions LN and EXP
(and maybe more).  They can return a function value and the first and
second derivative with respect to T and P.  There are three datatypes
associated with these functions.

\subsection{Function root record type}

In this record a name of the function is stored and the number of
temperature ranges.  For each range a low temperature limit and a link
to a tpfun\_expression record is stored.  There is also a high
temperature limit.  As the number of ranges can vary the arrays are
allocatable (declared as pointers).  At the same time as a root record
is reserved to store a TP function one also reservs a tpfun\_parres
record and in this the last calculated result of the function is
stored.  Saving the last calculated values speeds up calculation
because the same function is often used in many parameters and needed
many times for the same values of T and P.  But in parallell
processing the values of T and P can be different in each processor
and thus the results mut be separate in each.

{\small
\begin{verbatim}
  TYPE tpfun_root
! Root of a TP function including name with links to coefficients and codes
! and results.  Note that during calculations which can be parallellized
! the results can be different in each parallell process
     character*(lenfnsym) symbol
! limit is the low T limit of each range
! funlinks links to expression records for each range
     integer noofranges
     real, dimension(:), pointer :: limits
     integer, dimension(:), pointer :: funlinks
     real hightlimit
  END TYPE tpfun_root
\end{verbatim}
}

\subsection{Structure to store expressions of TP functions}

In this record the coefficients and powers of T and P and possible
unary functions used is stored.  There is a simple parser that can
read a simple TP function similar to what TC has.  My idea has been to
extend this a bit by allowing parenthesis in a more flexible way but
that is not yet implemented.  A TP function can refer to another TP
function using the link array.  This means a recursive evaluation of
TP functions must be implemented.

This information must not be changed during parallell processing.
During assessments one may calculate each experimental equilibria in
parallell and as the coefficients of TP functions are varied by the
assessment procedure one may think that this array must also be
separate for each parallell process.  But changes of coefficients are
not done during the parallell execution so there is no problem.

{\small
\begin{verbatim}
  TYPE tpfun_expression
! Coefficients, T and P powers, unary functions and links to other functions
     integer noofcoeffs
     double precision, dimension(:), pointer :: coeffs
! For each coefficient one may have a power of T, power of P,
! power of any symbol (not implemented)
! parenthesis level (not implemented)
! link to a symbol (i.e. another TP function)
     integer, dimension(:), pointer :: tpow
     integer, dimension(:), pointer :: ppow
     integer, dimension(:), pointer :: wpow
     integer, dimension(:), pointer :: plevel
     integer, dimension(:), pointer :: link
  END TYPE tpfun_expression
  TYPE(tpfun_expression), dimension(:), pointer :: tpexpr
\end{verbatim}
}

\subsection{Structure for calculated results of TP functions}

This record contains the last values of T and P used for calculation
the TP function and the results including first and second derivatives
of T and P.  These are ordered as F, F.T, F.P, F.T.T, F.T.P and F.P.P.
The reason to have this as a separate array is that in parallell
processing the values of T and P may be different in each process and
thus the results also, whereas the values of the coefficients are the
same.  The size of all the function records are allocated dynamically
by the tpfun\_init subroutine.

{\small
\begin{verbatim}
  TYPE tpfun_parres
! Contains a TP results, 6 double for results and  2 double for T and P
! values used to calculate the results
! Note that during calculations which can be parallellized the final
! results can be different for each parallell process
     double precision, dimension(2) :: tpused
     double precision, dimension(6) :: results
  END TYPE tpfun_parres
  TYPE(tpfun_parres), dimension(:), allocatable :: tpres
\end{verbatim}
}

\section{Summary}

Thats all!

\begin{thebibliography}{77Zzz}
\bibitem[07Luk]{07Luk} H L Lukas, S G Fries and B Sundman, {\em
Computational Thermodynamics, the Calphad method}, Cambridge univ
press (2007)
\end{thebibliography}

\end{document}
