! Hillert's Minimizer as implemented by Sundman (HMS)
! Based on Mats Hillert paper in Physica 1981 and Bo Janssons thesis 1984
! Details of this implementation published in Computational Materials Science,
!  vol 101, (2015) pp 127-137
!
MODULE liboceq
!
! Copyright 2012-2015, Bo Sundman, France
!
!    This program is free software; you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation; either version 2 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program; if not, write to the Free Software
!    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
!---------------------------
!
! To be implemented
! - calculating dot derivatives (Cp, thermal expansion etc) PARTIALLY DONE
! - stability check (eigenvalues)
! - fix bug with mass and mass fractions
! - conditions for properties H, V, S etc.
! - expressions as conditions
!
! To be done later outside this module:
! - step, map and plot (gnuplot) PARTIALLY DONE
! - assessment module
! 
  use general_thermodynamic_package
!
! For parallellization, also use in gtp3.F90
!  use omp_lib
!
  implicit none
  character*8, parameter :: hmsversion='HMS-2.00'
!
!-------------------------------------------------------
! for single equilibrium
!
!\begin{verbatim}
  TYPE meq_phase
! parts of the data in this structure should be in the gtp_equilibrium_data
! it contains phase specific results from various subroutines during
! equilibrium calculation
! iph: phase number
! ics: composition set number
! idim: the dimension of phase matrix, 
! ncc: the number of constituents
! stable: is 1 for a stable phase
! xdone: set to 1 for stoichiometric phases after calculating xmol first time
! dormlink: used to link phases that temporarily been set dormant
     integer iph,ics,idim,stable,ncc,xdone,dormlink
! value of phase status (-1,0=ent, 1=stable, 2=fix, -2=dorm, -3=sus, -4 hidden)
     integer phasestatus
! inverted phase matrix
     double precision, dimension(:,:), allocatable :: invmat
! mole fractions of components and their sum
     double precision, dimension(:), allocatable :: xmol
     double precision :: sumxmol,sumwmol
! Derivatives of moles of component wrt all constituent fractions of the phase
     double precision, dimension(:,:), allocatable :: dxmol
! link to phase_varres record
     TYPE(gtp_phase_varres), pointer :: curd
! value of amount and driving force at previous iteration
     double precision prevam, prevdg
! iteration when phase was added/removed
     integer itadd, itrem
! chargebal is 1 if external charge balance needed, ionliq<0 unless 
! ionic liquid when it is equal to nkl(1)=number of cations
     integer chargebal,ionliq,i2sly(2)
     double precision iliqcharge,yva
! end specific ionic liquids
  end TYPE meq_phase
!\end{verbatim}
!
!-------------------------------------------------------------------
!  
!\begin{verbatim}
  TYPE meq_setup
! one structure of this type is created when an equilibrium calculation
! is started and it holds all global data needed for handling the
! calculation of an equilibrium.  The phase specific data is in meq_phase
! nv: initial guess of number of stable phases
! nphase: total number of phases and composition sets
! nstph: current number of stable phases
! dormlink: is start of list of phases temporarily set dormant
! noofits current number of iterations
! nrel number of elements (omponents)
! typesofcond: types of conditions, =1 only massbal, =2 any conditions
! nfixmu number of fixed chemical potentials
! nfixph number of conditions representing fix phases
     integer nv,nphase,nstph,dormlink,noofits
     integer nrel,typesofcond,maxsph,nfixmu,nfixph
! component numbers of fixed potentials, reference and value 
     integer, dimension(:), allocatable :: mufixel
     integer, dimension(:), allocatable :: mufixref
     double precision, dimension(:), allocatable :: mufixval
! fix phases and amounts
     integer, dimension(:,:), allocatable :: fixph
     double precision, dimension(:), allocatable :: fixpham
! fix phases during mapping: phase index and composition set index, zero amount
!     type(gtp_phasetuple), dimension(:), allocatable :: nodefixph
! indices of axis conditions that has been inactivated
!     integer, dimension(:), allocatable :: inactiveaxis
! iphl, icsl: phase and composition sets of intial guess of stable phases
! aphl: initial guess of amount of each stable phase
     integer iphl(maxel+2),icsl(maxel+2)
     double precision aphl(maxel+2)
! stphl: current list of stable phases, value is index in phr array
     integer, dimension(maxel+2) :: stphl
! current values of chemical potentials stored in gtp_equilibrium_data
! if variable T and P these are TRUE, otherwise FALSE
     logical tpindep(2)
! these are the maximum allowed changes in T and P during iterations
     double precision tpmaxdelta(2)
! individual phase information
     type(meq_phase), dimension(:), allocatable :: phr
! information about conditions should be stored here.  Note that conditions
! may change during STEP and MAP
  end TYPE meq_setup
!\end{verbatim}
!
!------------------------------------------------------------------
!
! This is a connection to step/map
!\begin{verbatim}
  TYPE map_fixph
! provides information about phase sets for each line during mapping
     integer nfixph,nstabph
     type(gtp_phasetuple), dimension(:), allocatable :: fixph
     type(gtp_phasetuple), dimension(:), allocatable :: stableph
     double precision, dimension(:), allocatable :: stablepham
  end TYPE map_fixph
!\end{verbatim}
!
!--------------------------------------------------------------
!
! IMPORTANT
! phase_varres(lokcs)%amfu is the number of formula units of the phase
! phase_varres(lokcs)%netcharge is the current total charge  of the phase
! phase_varres(lokcs)%abnorm(1) is the number of real atoms per formula unit
! (may vary with composition like in (Fe,Cr,...)(Va,C,N,...) )
! phase_varres(lokcs)%abnorm(2) is the mass per formula unit
! NOTE: abnorm(1) and abnorm(2) is set by call to set_constitution
!
CONTAINS
  
!\begin{verbatim}
  subroutine calceq2(mode,ceq)
! calculates the equilibrium for the given set of conditions
! mode=0 means no global minimization
! ceq is a datastructure with all relevant thermodynamic data
    implicit none
    integer mode
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    TYPE(meq_setup), pointer :: meqrec
    type(map_fixph), pointer :: mapfix
    double precision starting,finish2
    integer starttid,endoftime,ij
!--------------------------------
    allocate(meqrec)
    nullify(mapfix)
    call cpu_time(starting)
    call system_clock(count=starttid)
    call calceq7(mode,meqrec,mapfix,ceq)
    call system_clock(count=endoftime)
    call cpu_time(finish2)
1000 continue
    if(gx%bmperr.eq.0) then
       write(*,1010)meqrec%noofits,finish2-starting,endoftime-starttid
1010   format('Equilibrium calculation ',i4', its, ',&
            1pe12.4,' s and ',i7,' clockcycles')
! Here we have now an equilibrium calculated.  Do a cleanup of the structure
! for phases with several compsets the call below shifts the stable one
! to the lowest compset number unless the default constitution fits another
! For example to ensure a fcc-carbonitrides is always the same compset.
       ij=1
       call todo_after_found_equilibrium(ij,ceq)
    else
       write(*,1020)gx%bmperr
1020   format('Error return from equilibrium calculation ',i5)
    endif
    return
  end subroutine calceq2

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine calceq7(mode,meqrec,mapfix,ceq)
! calculates the equilibrium for the given set of conditions
! mode=0 means no global minimization
! mode=-1 means used during step/map, no gridmin and do not deallocate phr
! ceq is a datastructure with all relevant thermodynamic data
! calling this routine instead of calceq2 makes it possible to extract
! additional information about the equilibrium from meqrec.
! Meqrec is also used for calculation of derivatives of state vatiables
    implicit none
    integer mode
    TYPE(meq_setup), pointer :: meqrec
    type(map_fixph), pointer :: mapfix
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    TYPE(gtp_condition), pointer :: condition,lastcond
! conditions on T and P and mole fractions of components
    double precision, dimension(2) :: tpval
    double precision, dimension(maxel) :: xknown,vmu
! antot is total number of moles of atoms.  Needed to scale results from
! gridmin which assumes 1 mole of atoms
    double precision xxx,antot,cvalue
    logical gridtest,formap
! for global minimization (change maybe to allocate dynamically)
    integer, dimension(maxph) :: nyphl
    double precision, dimension(maxconst) :: yarr
    integer np,iph,ics,jph,lokph,lokcs,mode2
    integer mostcon,mph,nvf
    integer, parameter :: mmu=5
    integer what,mjj,ij,cmix(10),cmode,mufixel(mmu),mufixref(mmu)
    integer fixph(2,maxel),oldorder(mmu),kst
    double precision fixpham(maxel)
    character statevar*40,encoded*60,name*24
!
    if(ocv()) write(*,*)"Entering calceq7",mode
    if(gx%bmperr.ne.0) then
       write(*,*)'Error code set before calling grid minimizer',gx%bmperr
       goto 1000
    endif
    if(mode.ge.0) then
       mode2=mode
       formap=.FALSE.
    else
! formap .TRUE. means that phr will not be deallocated
! and that phr(jj)%phasestatus will be set from meqrec%fixph ....
       mode2=0
       formap=.TRUE.
    endif
! skip this if mode=-1, we may not have degrees of freedom equal to zero
! as the fix phase is not stored as condition ...
    if(mode.ge.0) then
!---------------------------
! extract conditions
       call extract_massbalcond(tpval,xknown,antot,ceq)
       if(gx%bmperr.ne.0) then
! error 4143 means no conditions, 4144 wrong number of conditions
! 4151 not only massbalance conditions
!       if(gx%bmperr.eq.4151) goto 1000
          if(gx%bmperr.eq.4143 .or. gx%bmperr.eq.4144) then
             write(*,*)'Degrees of freedom not zero',gx%bmperr
             goto 1000
          endif
          write(*,*)' *** Warning, conditions prevent using gridminimizer'
          gx%bmperr=0
          gridtest=.true.
          meqrec%typesofcond=2
       else
!          meqrec%antot=antot
! no need for final grid minimizer as we will do one as start
          gridtest=.false.
          meqrec%typesofcond=1
       endif
       if(ocv()) write(*,*)'checked massbalance'
!------------------------------------
    endif
    meqrec%nrel=noel()
! set some initial values
    meqrec%maxsph=noel()+2
    meqrec%nfixph=0
    meqrec%nfixmu=0
    meqrec%tpindep=.TRUE.
! limit change in T and P.  For P it should be a factor ...
    meqrec%tpmaxdelta(1)=2.0D2
    meqrec%tpmaxdelta(2)=1.0D2
! now we calculate maxsph, nfixmu and maybe other things for later
    lastcond=>ceq%lastcondition
    if(.not.associated(lastcond)) then
       write(*,*)'No conditions'
       gx%bmperr=7777; goto 1000
    endif
    condition=>lastcond
    cmix=0
    np=0
    mjj=0
! set default values
!    write(*,69)tpval,ceq%tpval
!69  format('T&P: ',4(1pe12.4))
    tpval(1)=ceq%tpval(1)
    tpval(2)=ceq%tpval(2)
    ceq%rtn=globaldata%rgas*tpval(1)
!---------------- loop
! loop through all conditions, end when the pointer condition is empty
! loop to investigate conditions, apply_condition:value in pmod25D.F90
70  continue
       cmode=-1
       condition=>condition%next
       mjj=mjj+1
       if(ocv()) write(*,*)'check condition'
       call apply_condition_value(condition,cmode,cvalue,cmix,ceq)
       if(gx%bmperr.ne.0) goto 1000
! cmix(1)=0 for inactive conditions
! cmix(1)=1 fix T, =2, fix P, =3 fix MU/AC/LNAC, =4 fix phase, =5 anything else
! if condition on T, P, potential or fix phase reduce maxsph
       select case(cmix(1))
       case default
          if(.not.associated(condition,lastcond)) goto 70
       case(1) ! fix T
          if(cvalue.le.0.1D0) then
             write(*,*)'Condition on T must be larger than 0.1 K'
             gx%bmperr=4187; goto 1000
          endif
          meqrec%maxsph=meqrec%maxsph-1
          meqrec%tpindep(1)=.FALSE.
          ceq%tpval(1)=cvalue
       case(2) ! fix P
          if(cvalue.le.0.1D0) then
             write(*,*)'Condition on P must be larger than 0.1 Pa'
             gx%bmperr=4187; goto 1000
          endif
          meqrec%maxsph=meqrec%maxsph-1
          meqrec%tpindep(2)=.FALSE.
          ceq%tpval(2)=cvalue
!-------------------------
       case(3) ! (MU,AC,LNAC) in cmix(2)=3,4,5
! The component is in cmix(3) and reference state in cmix(4)
! Handling of the reference state ignored at present
          np=np+1
          if(np.gt.mmu) then
             write(*,*)'Max conditions on potentials is ',mmu
             gx%bmperr=7777; goto 1000
          endif
          mufixel(np)=cmix(3)
          mufixref(np)=cmix(4)
! temporarily use yarr for something else
          if(cmix(2).eq.3) then
! Divide MU by RT
             yarr(np)=cvalue/ceq%rtn
          elseif(cmix(2).eq.4) then
! AC=exp(MU/RT) converted to chemical potential/RT
             if(cvalue.le.zero) then
                write(*,*)'Conditions on activity must be larger than zero'
                gx%bmperr=7777; goto 1000
             endif
             yarr(np)=LOG(cvalue)
          else
! LNAC=MU/RT which is the value used during minimization
             yarr(np)=cvalue
          endif
!          write(*,*)'Chemical potential condition: ',yarr(np)
          meqrec%maxsph=meqrec%maxsph-1
!             write(*,72)'MM, chemp: ',cmix(1),cmix(2),cmix(3),cvalue
!72           format(a,3i3,1pe12.4)
!-------------------------
       case(4) ! fix phase
          meqrec%nfixph=meqrec%nfixph+1
          fixph(1,meqrec%nfixph)=cmix(2)
          fixph(2,meqrec%nfixph)=cmix(3)
          fixpham(meqrec%nfixph)=cvalue
!          write(*,*)'Fix phase condition: ',cmix(2),cmix(3),cvalue
! debug output of fix phase composition
!          call calc_phase_mol(cmix(1),yarr,ceq)
!          write(*,83)'fix phasse: ',cmix(1),(yarr(mjj),mjj=1,noel())
!83        format(a,i2,10f7.4)
       end select !-----------------------------------------------
       if(.not.associated(condition,lastcond)) goto 70
! end loop of conditions
!--------------------------------------------------------------
!       write(*,*)'variable potentials, max variable phases: ',&
!               noel()-cmix(2),meqrec%maxphases
    meqrec%nfixmu=np
    if(np.gt.0) then 
       allocate(meqrec%mufixel(np))
       allocate(meqrec%mufixref(np))
       allocate(meqrec%mufixval(np))
       if(np.gt.1) then
! sort components with fix MU in increasing order to simplify below
          call sortin(mufixel,np,oldorder)
          do mjj=1,np
             nvf=mufixel(mjj)
             meqrec%mufixel(mjj)=nvf
             meqrec%mufixref(mjj)=mufixref(oldorder(mjj))
             meqrec%mufixval(mjj)=yarr(oldorder(mjj))
! copy fixed chemical potential (divided by RT) to ceq%cmuval also
             ceq%cmuval(nvf)=yarr(oldorder(mjj))
! in the component records multiply with RT
             ceq%complist(nvf)%chempot(1)=yarr(oldorder(mjj))*ceq%rtn
          enddo
       else
          nvf=mufixel(1)
          meqrec%mufixel(1)=nvf
          meqrec%mufixref(1)=mufixref(1)
          meqrec%mufixval(1)=yarr(1)
! also copy fixed chemical potential to ceq%cmuval
          ceq%cmuval(nvf)=yarr(1)
          ceq%complist(nvf)%chempot(1)=ceq%cmuval(nvf)*ceq%rtn
       endif
    endif
    if(meqrec%nfixph.gt.0) then
! allocate 5 extra places for fix phase during mapping ...
       allocate(meqrec%fixph(2,meqrec%nfixph+5))
       allocate(meqrec%fixpham(meqrec%nfixph+5))
       if(np.gt.1) then
! ?? sort phases in increasing order to simplify below
          write(*,*)'Cannot handle two fix phases ... '
          gx%bmperr=8888; goto 1000
       endif
       do mjj=1,meqrec%nfixph
          meqrec%fixph(1,mjj)=fixph(1,mjj)
          meqrec%fixph(2,mjj)=fixph(2,mjj)
          meqrec%fixpham(mjj)=fixpham(mjj)
       enddo
    else
! allocate 5 places for fix phase during mapping (one per axis)
       if(.not.allocated(meqrec%fixph)) then
          allocate(meqrec%fixph(2,5))
          allocate(meqrec%fixpham(5))
       endif
    endif
!----------------------------
!    call list_conditions(kou,ceq)
! skip global gridminimizer if bit set
    if(ocv()) write(*,*)'checked conditions'
    if(mode2.eq.0 .or. btest(globaldata%status,GSNOGLOB)) goto 110
! skip global gridminimizer if only one component but make sure one phase
! has positive amount
    if(meqrec%nrel.eq.1) then
       goto 110
    endif
! Try global gridminimization.  Returned values are:
! nv is number of stable phase, iphl, icsl list of stable  phases, aphl amounts
! nyphl(j) is number of constituent fractions in phase j, yarr are the 
! constituent fractions, vmu the chemical potentials
! THIS CALL MAY CREATE NEW COMPOSITION SETS unless GSNOACS set.
! loop through all phases and set amount=0 and CSSTABLE off
    ij=1
    call todo_before(ij,ceq)
    if(gx%bmperr.ne.0) goto 1000
    if(meqrec%typesofcond.eq.1) then
! with only massbalance condition make a global grid minimization
!       call global_gridmin(1,tpval,antot,xknown,meqrec%nv,&
       call global_gridmin(1,tpval,xknown,meqrec%nv,&
            meqrec%iphl,meqrec%icsl,meqrec%aphl,nyphl,yarr,vmu,ceq)
       if(ocv()) write(*,*)'back from gridmin'
       if(gx%bmperr.ne.0) then
! if global fails reset error code and try a default start set of phases
          if(gx%bmperr.ge.4000 .and. gx%bmperr.le.4220) then
             write(kou,102)gx%bmperr,bmperrmess(gx%bmperr)
102          format('Tried but failed to use grid minimization, error: ',i5/a)
          endif
! no initial gridmin, make a gridtest at the end
          gridtest=.true.
          gx%bmperr=0; goto 110
       endif
! multiply phase amounts with antot as global_grimin assumes 1 mole
       if(abs(antot-one).gt.1.0D-8) then
!          write(*,*)'From gridmin: ',meqrec%nv,antot
          do mph=1,meqrec%nv
             call get_phase_compset(meqrec%iphl(mph),meqrec%icsl(mph),&
                  lokph,lokcs)
             ceq%phase_varres(lokcs)%amfu=antot*ceq%phase_varres(lokcs)%amfu
          enddo
       endif
       goto 200
    endif
    if(ocv()) write(*,103)(meqrec%iphl(mjj),meqrec%icsl(mjj),meqrec%aphl(mjj),&
         mjj=1,meqrec%nv)
103 format('Phases: ',6(i3,i2,1pe12.4))
!--------------------
! no global gridmin or we come here if gridtest finds a new stable phase
110 continue
!    write(*,*)'starting without gridmin'
    meqrec%nv=0
! at least one phase must be stable
    mostcon=-1
    mph=0
    jph=0
    do iph=1,noph()
       do ics=1,noofcs(iph)
          kst=test_phase_status(iph,ics,xxx,ceq)
          if(gx%bmperr.ne.0) goto 1000
! new: -4 hidden, -3 suspended, -2 dormant, -1,0,1 entered, 2 fix
!          if(kst.le.PHDORM) goto 115
          if(kst.le.PHDORM) cycle
          call get_phase_compset(iph,ics,lokph,lokcs)
          if(ceq%phase_varres(lokcs)%amfu.gt.zero) then
             meqrec%nv=meqrec%nv+1
             meqrec%iphl(meqrec%nv)=iph
             meqrec%icsl(meqrec%nv)=ics
             meqrec%aphl(meqrec%nv)=ceq%phase_varres(lokcs)%amfu
          endif
       enddo
! select phase with most constituents
       call get_phase_variance(iph,nvf)
       if(nvf.gt.mostcon) then
          mostcon=nvf
          jph=iph
       endif
    enddo
!    write(*,*)'Phase selected ',meqrec%nv,jph
    if(meqrec%nv.eq.0) then
! no phase with positive amount, set phase with most constituents as stable
       if(jph.gt.0) then
          call get_phase_compset(jph,1,lokph,lokcs)
          ceq%phase_varres(lokcs)%amfu=one
          meqrec%nv=1
          meqrec%iphl(1)=jph
          meqrec%icsl(1)=1
          meqrec%aphl(1)=one
          if(ocv()) write(*,*)'No gridminimization, selecting phase ',&
               jph,' as stable'
! this sets the default constitution 
          call set_default_constitution(jph,1,ceq)
       else
!          write(*,*)'No phase to set stable'
          gx%bmperr=4200; goto 1000
       endif
    else
! hopefully set_constitution has been called ...
       if(ocv()) write(*,*)'No gridminimization, using current phase set',&
            meqrec%nv
    endif
! copy ceq%complist%chempot(1) to ceq%cmuval
    do mjj=1,meqrec%nrel
       if(abs(ceq%complist(mjj)%chempot(1)).ge.one) then
          ceq%cmuval(mjj)=ceq%complist(mjj)%chempot(1)/ceq%rtn
       else
          ceq%cmuval(mjj)=zero
       endif
    enddo
    if(ocv()) write(*,68)'cmuval: ',meqrec%nrel,&
         (ceq%cmuval(mjj),mjj=1,meqrec%nrel)
68  format(a,i3,6(1pe12.4))
!
! we must make sure the fix phases are in the initial list of stable phases
! the order does not matter, the phases will be sorted later
    addfixph: do mjj=1,meqrec%nfixph
       jph=1
       do while (jph.le.meqrec%nv)
          if(meqrec%iphl(jph).eq.meqrec%fixph(1,mjj) .and. &
               meqrec%icsl(jph).eq.meqrec%fixph(2,mjj)) then
! found fix phase as already stable, just store the amount
             meqrec%aphl(jph)=meqrec%fixpham(mjj)
             cycle addfixph
          endif
          jph=jph+1
       enddo
! add this phase as stable, check that not too many stable phases ...
! meqrec%nv is the current number of stable phases
       if(meqrec%nv.eq.meqrec%maxsph) then
          write(*,*)'Too many stable phases'
          gx%bmperr=9998; goto 1000
       endif
!       write(*,*)'Adding fix phase to stable phase set',&
!            meqrec%fixph(1,mjj),meqrec%fixph(2,mjj)
       meqrec%nv=meqrec%nv+1
       meqrec%iphl(meqrec%nv)=meqrec%fixph(1,mjj)
       meqrec%icsl(meqrec%nv)=meqrec%fixph(2,mjj)
       meqrec%aphl(meqrec%nv)=meqrec%fixpham(mjj)
    enddo addfixph
!------------------------------- special for mapping
    if(associated(mapfix)) then
! the stable and fix phases copied from mapfix record.
       do ij=1,meqrec%nv
!          write(*,64)'Removing already stable phase: ',ij,meqrec%iphl(ij),&
!               meqrec%icsl(ij)
          meqrec%iphl(ij)=0
          meqrec%icsl(ij)=0
       enddo
       if(ocv()) write(*,64)'Fix phase in mapfix record: ',mapfix%nfixph,&
            mapfix%fixph(1)%phase,mapfix%fixph(1)%compset
64     format(a,i3,5x,2i3,5x,i3)
       meqrec%nfixph=mapfix%nfixph
       meqrec%nv=0
       do ij=1,meqrec%nfixph
          meqrec%fixph(1,ij)=mapfix%fixph(ij)%phase
          meqrec%fixph(2,ij)=mapfix%fixph(ij)%compset
          meqrec%fixpham(ij)=zero
          meqrec%nv=meqrec%nv+1
          meqrec%iphl(meqrec%nv)=mapfix%fixph(ij)%phase
          meqrec%icsl(meqrec%nv)=mapfix%fixph(ij)%compset
       enddo
!       write(*,64)'MM: Number of stable phase from mapfix: ',mapfix%nstabph
       do ij=1,mapfix%nstabph
          meqrec%nv=meqrec%nv+1
          meqrec%iphl(meqrec%nv)=mapfix%stableph(ij)%phase
          meqrec%icsl(meqrec%nv)=mapfix%stableph(ij)%compset
          meqrec%aphl(meqrec%nv)=mapfix%stablepham(ij)
!          write(*,*)'MM: Amount: ',ij,mapfix%stablepham(ij)
       enddo
    endif
!------------------------------- 
! debug output of fix phase composition
!    call calc_phase_mol(1,yarr,ceq)
!    write(*,83)'at 200: ',cmix(1),(yarr(mjj),mjj=1,noel())
! zero start of link to phases set temporarily dormant ....
    meqrec%dormlink=0
!
!-------------------------------
! Now we calculate the equilibrium
200 continue
!
! this routine varies the set of phases and the phase constitutions
! until the stable set is found for the given set of conditions.
    if(ocv()) write(*,*)'calling meq_phaseset'
    call meq_phaseset(meqrec,formap,ceq)
    if(gx%bmperr.ne.0) goto 1000
    gridtest=.false.
!------------------------------------------------------
!
! When we come here the equilibrium is calculated or calculation failed
!   gridtest value should have been set to .true. if no gridmin done initially
    gridcheck: if(gridtest .and. btest(ceq%status,EQGRIDTEST)) then
! if conditions are not massbalance apply gridtest as we now know the
! overall composition.  First extract the molefractions
       write(*,*)'Testing solution with new grid'
       do mjj=1,meqrec%nrel
          call get_component_name(mjj,name,ceq)
          if(gx%bmperr.ne.0) then
             write(*,*)'error getting component name ',mjj,gx%bmperr
             goto 1000
          endif
          statevar='X('//name(1:len_trim(name))//') '
          call get_state_var_value(statevar,xknown(mjj),encoded,ceq)
          if(gx%bmperr.ne.0) then
             write(*,*)'Error extracting x to test the solution',gx%bmperr
             goto 1000
          endif
          statevar='MU('//name(1:len_trim(name))//') '
          call get_state_var_value(statevar,vmu(mjj),encoded,ceq)
          if(gx%bmperr.ne.0) then
             write(*,*)'Error extracting mu to test the solution',gx%bmperr
             goto 1000
          endif
       enddo
       tpval(1)=ceq%tpval(1)
       tpval(2)=ceq%tpval(2)
! with what=-1 this is a test, what is changed if new phase should be stable.
! Use same variables as earler call. New composition sets can be entered
       stop 'This is not yet implemented'
       what=-1
!       call global_gridmin(what,tpval,antot,xknown,meqrec%nv,meqrec%iphl,&
       call global_gridmin(what,tpval,xknown,meqrec%nv,meqrec%iphl,&
            meqrec%icsl,meqrec%aphl,nyphl,yarr,vmu,ceq)
       if(gx%bmperr.ne.0) then
          write(*,*)'Error calculating grid to test the solution',gx%bmperr
          goto 1000
       endif
       if(what.gt.0) then
! solution incorrect, a gridpoint is below the chem.pot surface
          iph=what/10
          ics=mod(what,10)
          write(*,*)'Recalculate as another phase is stable: ',iph,ics
          goto 110
       endif
    endif gridcheck
!--------------------------------------------------
1000 continue
    return
  end subroutine calceq7

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine meq_phaseset(meqrec,formap,ceq)
! this subroutine can change the set of stable phase and their amounts
! and constitutions until equilibrium is found for the current conditions.
    implicit none
    TYPE(meq_setup) :: meqrec
    TYPE(gtp_equilibrium_data), pointer :: ceq
    logical formap
!\end{verbatim}
! should one use meqrec as pointer here???
    integer ok,iadd,iph,ics,irem,jj,jph,kk,lastchange,lokph,lokcs,minadd
    integer kph,minrem,mph,nip,nochange,zap,toomanystable,jrem,krem
    double precision, parameter :: ylow=1.0D-3
    double precision, parameter :: addedphase_amount=1.0D-2
    double precision xxx
    integer iremsave,zz,tupadd,tuprem
! replace always FALSE except when we must replace a phase as we have max stable
    logical replace
! number of iterations without adding or removing a phase
    replace=.FALSE.
    minadd=4
    minrem=4
! minum number if iterations between any change of stable phase set
    nochange=5
    lastchange=0
!
    if(ocv()) write(*,*)'entering meq_phaseset: '
    meqrec%dormlink=0
! nphase is set to total number of phases (phase+compset) to be calculated
! >>> parallellization ALERT, nphase may change when composition sets created
!    call sumofphcs(meqrec%nphase,ceq)
!    meqrec%nphase=totalphcs(ceq)
    meqrec%nphase=nonsusphcs(ceq)
    if(gx%bmperr.ne.0) goto 1000
    allocate(meqrec%phr(meqrec%nphase))
! order the inital set of stable phases in ascending order
! VERY CLUMSY SORTING
15  continue
    ok=0
!    write(*,16)meqrec%nv,meqrec%nphase,size(meqrec%iphl)
!16  format('sort: ',10i3)
    do iph=2,meqrec%nv
       if(meqrec%iphl(iph-1).gt.meqrec%iphl(iph)) then
          ok=1
          kk=meqrec%iphl(iph-1)
          meqrec%iphl(iph-1)=meqrec%iphl(iph)
          meqrec%iphl(iph)=kk
          kk=meqrec%icsl(iph-1)
          meqrec%icsl(iph-1)=meqrec%icsl(iph)
          meqrec%icsl(iph)=kk
          xxx=meqrec%aphl(iph-1)
          meqrec%aphl(iph-1)=meqrec%aphl(iph)
          meqrec%aphl(iph)=xxx
       endif
    enddo
    if(ok.ne.0) goto 15
17  continue
    ok=0
    do iph=2,meqrec%nv
       if(meqrec%iphl(iph-1).eq.meqrec%iphl(iph)) then
          if(meqrec%icsl(iph-1).gt.meqrec%icsl(iph)) then
             kk=meqrec%icsl(iph-1)
             meqrec%icsl(iph-1)=meqrec%icsl(iph)
             meqrec%icsl(iph)=kk
             xxx=meqrec%aphl(iph-1)
             meqrec%aphl(iph-1)=meqrec%aphl(iph)
             meqrec%aphl(iph)=xxx
             ok=1
          endif
       endif
    enddo
    if(ok.ne.0) goto 17
!-----------------------------
    mph=0
    nip=1
!    krem=0
    meqrec%nstph=0
    do iph=1,noph()
       do ics=1,noofcs(iph)
! ignore hidden and suspended phases (also ignored above in sumofphcs)
! entered, fixed and dormat has values 1, 2 and 3, suspended 4, hidden 5
          zap=test_phase_status(iph,ics,xxx,ceq)
! new: -4 hidden, -3 suspended, -2 dormant, -1,0,1 entered, 2 fixed
          if(zap.ge.PHDORM) then
             mph=mph+1
             meqrec%phr(mph)%iph=iph
             meqrec%phr(mph)%ics=ics
! compare with these the first time a phase wants to be added or removed
! if zero it means phase can be added/removed at iteration minadd/minrem
             meqrec%phr(mph)%itadd=0
             meqrec%phr(mph)%itrem=0
! initiate indicator for phases with fix composition, set to 1 later if so
             meqrec%phr(mph)%xdone=0
! save phasestatus, zap>-2 here so set all -1,0,1 set to 0
             if(abs(zap).le.1) zap=0
             meqrec%phr(mph)%phasestatus=zap
             if(formap) then
! when mapping fix phases are used to replace axis conditions.  The
! fix phases are in the meqrec%fixph array
! They do not return PHFIXED for test_phase_status !!!
                do zz=1,meqrec%nfixph
                   if(iph.eq.meqrec%fixph(1,zz) .and. &
                        ics.eq.meqrec%fixph(2,zz)) then
                      meqrec%phr(mph)%phasestatus=PHFIXED
                   endif
                enddo
             endif
             meqrec%phr(mph)%ionliq=-1
             meqrec%phr(mph)%i2sly=0
             if(test_phase_status_bit(iph,PHIONLIQ)) meqrec%phr(mph)%ionliq=1
! set link to calculated values of G etc.
             call get_phase_compset(iph,ics,lokph,lokcs)
             meqrec%phr(mph)%curd=>ceq%phase_varres(lokcs)
             if(iph.eq.meqrec%iphl(nip) .and. ics.eq.meqrec%icsl(nip)) then
! this phase is part of the initial stable set, increment nstph
                meqrec%nstph=meqrec%nstph+1
                meqrec%stphl(meqrec%nstph)=mph
                meqrec%phr(mph)%stable=1
                if(meqrec%phr(mph)%phasestatus.eq.PHFIXED) then
! Rather confused here ...
! fixed phases as conditions have an amount in meqrec%fixpham
! fixed phases during mapping should have zero amount
!                   krem=krem+1
!                   write(*,*)'aphl for fix phase: ',krem,mph,&
!                        meqrec%fixpham(krem)
                   if(meqrec%phr(mph)%curd%phstate.ne.PHFIXED) then
! this is a phase set fix by mapping, set amount to zero
                      meqrec%phr(mph)%curd%amfu=zero
!                   else
! phases set fix by user have their amount in meqrec%phr(mph)%curd%amfu 
!                      write(*,*)'User set fixed phase:',mph,&
!                           meqrec%phr(mph)%curd%amfu
                   endif
                else
                   meqrec%phr(mph)%curd%amfu=meqrec%aphl(meqrec%nstph)
                endif
! set "previous values"
                meqrec%phr(mph)%prevam=meqrec%aphl(meqrec%nstph)
                meqrec%phr(mph)%prevdg=zero
                nip=nip+1
             else
! unstable phase
                meqrec%phr(mph)%stable=0
                meqrec%phr(mph)%prevam=zero
                meqrec%phr(mph)%prevdg=-one
                meqrec%phr(mph)%curd%amfu=zero
             endif
! mark that no data arrays allocated for this phase
             meqrec%phr(mph)%idim=0
! initiate link to another phase temporarily set dormant zero
             meqrec%phr(mph)%dormlink=0
          else
! we are here for phases that are suspended, test_phase_status return -3
! make sure stable bit is cleared in phases not included in calculation
! maybe the whole status word should be zeroed?
             call get_phase_compset(iph,ics,lokph,lokcs)
             ceq%phase_varres(lokcs)%status2=&
                  ibclr(ceq%phase_varres(lokcs)%status2,CSSTABLE)
! check if suspended phase bits CSSUS set
!z             if(btest(ceq%phase_varres(lokcs)%status2,CSSUS)) then
!                write(*,*)'MM Suspended bit set',lokph,lokcs
!             else
! This should not be necessary but it fixes the problem using c n with
! suspended phases.  The CSSUS bit should no longer be used???
!                write(*,*)'MM warning, suspended bit NOT set',lokph,lokcs
!z                ceq%phase_varres(lokcs)%status2=&
!z                     ibset(ceq%phase_varres(lokcs)%status2,CSSUS)
!z             endif
          endif
       enddo
    enddo
! problem phases suspended are restored!!
!    write(*,*)'at start, nonsuspenden phases: ',mph
    meqrec%noofits=0
    toomanystable=0
    jrem=0
    krem=0
    iremsave=0
! code above executed only intially
!----------------------------------------------------------------
!
! meq_sameset calculate the equilibrium for a given set of stable phases
! if phase set change one return to this routine to take some action and
! then call meq_sameset again
! irem nonzero if phase irem should be removed
! iadd nonzero if phase iadd should be added
! meqrec has the general information needed
! meqrec%phr is the array with phases
! ceq is the connection to the model package data
200 continue
!    iadd=-1 ! iadd =-1 turns on verbose in meq_sameset
    iadd=0
    irem=iremsave
! meq_sameset varies amounts of stable phases and constitutions of all phases
! If there is a phase change (iadd or irem nonzeri) or error it exits 
    call meq_sameset(irem,iadd,meqrec,meqrec%phr,ceq)
    if(ocv()) write(*,*)'Back from sameset ',irem,iadd,meqrec%noofits
    if(gx%bmperr.ne.0) goto 1000
!
    if(irem.gt.0 .or. iadd.gt.0) then
       if(iremsave.gt.0 .and. iadd.eq.iremsave) then
! if iadd=iremsave>0 there was a equil matrix error when removing iremsave
          irem=0
       elseif(meqrec%noofits-lastchange.lt.nochange) then
!          write(*,221)' *** Phase set change not allowed: ',&
!               meqrec%noofits,lastchange,nochange,irem,iadd
221       format(a,10i4)
          goto 200
       endif
       if(iadd.gt.0) then
! check if phase to be added is already stable as another composition set
! This check should maybe be above as maybe another phase want to be stable??
! The last argument is not used
          if(same_composition(iadd,meqrec%phr,meqrec,ceq,zero)) then
             write(*,*)'Ignoring the same phase twice: ',iadd
             goto 200
          endif
       endif
       tupadd=0
       tuprem=0
       xxx=0.0D0
       if(iadd.gt.0) tupadd=meqrec%phr(iadd)%curd%phtupx
       if(irem.gt.0) tuprem=meqrec%phr(irem)%curd%phtupx
       write(*,219)'Phase change: its/add/remove: ',&
            meqrec%noofits,tupadd,tuprem
219    format(a,3i5,1pe12.4)
       if(formap) then
! when called during mapping the set of phases must not change!
          if(ocv()) write(*,*)'Phase change not allowed',ceq%tpval(1)
! Phase change not allowed due to step/map constraints
! step/map should handle this by creating node points
          gx%bmperr=4210; goto 1000
       endif
    endif
222 continue
    remove: if(irem.gt.0) then
! remove a phase ---------------------------
       if(ocv()) write(*,223)'Phase to be removed: ',meqrec%phr(irem)%iph,&
            meqrec%phr(irem)%ics,meqrec%phr(irem)%curd%amfu,meqrec%noofits
       if(meqrec%nstph.eq.1) then
          if(.not.REPLACE) then
! we must be able to REPLACE the only stable phase for a unary system
             write(*,*)'Attempt to remove the only stable phase!!!'
!          gx%bmperr=7777; goto 1000
             goto 200
          endif
!          write(*,*)'We are replacing one stable phase with another',irem,iadd
       else
! make sure replace is false unless explitly set below
          replace=.FALSE.
       endif
       if(meqrec%noofits-meqrec%phr(irem)%itadd.lt.minrem) then
! if phase was just added do not remove before minrem iterations
          if(ocv()) write(*,*)'Too soon to remove phase',&
               meqrec%phr(irem)%iph,meqrec%noofits,meqrec%phr(irem)%itadd
          goto 200
       endif
! shift phases after irem down in meqrec%stphl
! irem is index to meqrec%phr(), meqrec%stphl(jph) is index to meqrec%phr
       meqrec%nstph=meqrec%nstph-1
       do iph=1,meqrec%nstph
          jj=meqrec%stphl(iph)
          if(jj.ge.irem) then
             meqrec%stphl(iph)=meqrec%stphl(iph+1)
          endif
       enddo
! we must zero the last phase !!
       meqrec%stphl(meqrec%nstph+1)=0
!
       meqrec%phr(irem)%itrem=meqrec%noofits
       meqrec%phr(irem)%prevam=zero
       meqrec%phr(irem)%stable=0
       meqrec%phr(irem)%curd%amfu=zero
! save irem as it is used to restore a phase if massbalance problem
       iremsave=irem
       irem=0
       lastchange=meqrec%noofits
! one can remove and add a phase at the same time !!!
       if(iadd.eq.0) then
          toomanystable=0
          jrem=0
          goto 200
       endif
    endif remove
!------------------------------------------- 
    add: if(iadd.gt.0) then
! add a phase.  This can be tricky
! NOTE it must be added so meqrec%stphl in ascending order
       if(ocv()) write(*,223)'Phase to be added:   ',meqrec%phr(iadd)%iph,&
            meqrec%phr(iadd)%ics,meqrec%phr(iadd)%curd%dgm,meqrec%noofits
223    format(a,2x,2i4,1pe15.4,i7)
       if(meqrec%noofits-meqrec%phr(iadd)%itrem.lt.minadd) then
! if phase was just removed do not add it before minadd iterations
          write(*,224)'Too soon to add phase: ',minadd,&
               meqrec%phr(iadd)%iph,&
               meqrec%phr(iadd)%ics,meqrec%noofits,meqrec%phr(iadd)%itrem
224       format(a,i3,2x,2i4,5i5)
          goto 200
       endif
! make sure iremsave is set to zero
       iremsave=0
       if(meqrec%nstph.eq.meqrec%maxsph) then
! No more phases allowed, we must see if  some other phase may be removed
          if(toomanystable.ge.3) then
             write(*,*)'Attempt to set too many phases stable',meqrec%maxsph
!             gx%bmperr=4201; goto 1000
! During mapping do not replace phases ...
             if(formap) then
                gx%bmperr=4201; goto 1000
             endif
! the code below does not work ...
             if(jrem.eq.0) then
! try to remove a stable phase ... which? make it simple, last or first one
                if(krem.eq.jrem) then
                   jrem=meqrec%stphl(meqrec%nstph)
                else
                   jrem=meqrec%stphl(1)
                endif
                krem=jrem
                irem=jrem
                if(ocv()) write(*,240)irem,iadd,meqrec%noofits
240             format('Too many phases stable, replacing ',i3,' by ',i3,&
                     ' at iteration ',i4) 
                replace=.TRUE.
                goto 222             
             else
                write(*,*)'Error setting too many phases stable',meqrec%maxsph
                gx%bmperr=4201; goto 1000
             endif
          else
! try ignore adding 3 times
!             write(*,*)'Ignoring attempt to set too many phases stable',&
!                  meqrec%maxsph,toomanystable
             toomanystable=toomanystable+1
             goto 200
          endif
       endif
! the phase must be added in sequential order of phase and composition set no
       findplace: do jph=1,meqrec%nstph
          jj=meqrec%stphl(jph)
          if(meqrec%phr(iadd)%iph.gt.meqrec%phr(jj)%iph) then
             cycle
          endif
          if(meqrec%phr(iadd)%iph.lt.meqrec%phr(jj)%iph) then
             exit
          endif
! if same phase number compare composition set numbers
          if(meqrec%phr(iadd)%iph.eq.meqrec%phr(jj)%iph) then
             if(meqrec%phr(iadd)%ics.gt.meqrec%phr(jj)%ics) then
                cycle
             else
                exit
             endif
          endif
       enddo findplace
! one should come here at exit, iadd should be inserted before 
! meqrec%stphl(jph), jph can be nstph+1 if added phase should be the last
! otherwise shift previous phases one step up.
       do kph=meqrec%nstph,jph,-1
          meqrec%stphl(kph+1)=meqrec%stphl(kph)
       enddo
!       write(*,*)'Phase added: ',jph,meqrec%nstph,meqrec%maxsph
! phase added at jph, (note jph may be equal to nstph+1)
       meqrec%stphl(jph)=iadd
       meqrec%nstph=meqrec%nstph+1
       meqrec%phr(iadd)%itadd=meqrec%noofits
       meqrec%phr(iadd)%curd%dgm=zero
       lastchange=meqrec%noofits
! maybe some more variables should be set?
       meqrec%phr(iadd)%curd%amfu=addedphase_amount
       meqrec%phr(iadd)%stable=1
       iadd=0
       toomanystable=0
       jrem=0
       goto 200
    endif add
!---------------------------------------------------
! found stable phase set or error
1000 continue
    if(gx%bmperr.eq.0) then
! equilibrium calculation converged, one should add check on stability
!
! >> add calculate eigenvalues of phase matrix to check stability, 
! >> a negative eigenvalue means inside spinodal
! >> Note charge problems for metastable phases, phase must be neutral ...
!
!------------------------------------------------------------
! clear bits: no equilibrium calculated/ inconsistent conditions and result/
! equilibrium calculation failed
       ceq%status=ibclr(ceq%status,EQNOEQCAL)
       ceq%status=ibclr(ceq%status,EQINCON)
       ceq%status=ibclr(ceq%status,EQFAIL)
! set stable bit in stable phases and clear it in all others
       kk=1
       do jj=1,mph
          if(jj.eq.meqrec%stphl(kk)) then
             meqrec%phr(jj)%curd%status2=&
                  ibset(meqrec%phr(jj)%curd%status2,CSSTABLE)
! the stable phase list should be ordered in increasing phase number
             kk=kk+1
          else
             meqrec%phr(jj)%curd%status2=&
                  ibclr(meqrec%phr(jj)%curd%status2,CSSTABLE)
          endif
       enddo
!-----------------------
! loop through all phases and if their status is entered set it as PHENTUNST
! unless stablestable phases and set the PHENTST for phases in stable set
! That is important for extracting values later ...
       do jph=1,meqrec%nphase
          if(meqrec%phr(jph)%curd%phstate.ge.PHENTUNST .and. &
               meqrec%phr(jph)%curd%phstate.le.PHENTSTAB) then
             meqrec%phr(jph)%curd%phstate=PHENTUNST
          endif
       enddo
       do jph=1,meqrec%nstph
          jj=meqrec%stphl(jph)
          if(meqrec%phr(jj)%curd%phstate.lt.PHFIXED) then
             meqrec%phr(jj)%curd%phstate=PHENTSTAB
          endif
       enddo
!-----------------------------------------
    else
! set some failure bits
       ceq%status=ibset(ceq%status,EQINCON)
       ceq%status=ibset(ceq%status,EQFAIL)
! even when not converged save the current chemical potentials
       do jj=1,meqrec%nrel
          ceq%complist(jj)%chempot(1)=ceq%cmuval(jj)*ceq%rtn
       enddo
    endif
! restore phases set dormant
    jj=meqrec%dormlink
1200 continue
    if(jj.ne.0) then
       write(*,*)'Restore from dormant: ',jj,meqrec%phr(jj)%iph,&
            meqrec%phr(jj)%ics
       meqrec%phr(jj)%phasestatus=PHENTUNST
       jj=meqrec%phr(jj)%dormlink
       goto 1200
    endif
! try to find problem with listed chemical potential    
! chempot(2) should be value with user defined reference state, has
! to be implemented ...
    do jj=1,meqrec%nrel
       ceq%complist(jj)%chempot(2)=ceq%complist(jj)%chempot(1)
    enddo
!-------------
    if(.not.formap) then
! if called during mapping keep phr
       deallocate(meqrec%phr)
    endif
! >>>> here one can allow new composition set in parallelization
    return
  end subroutine meq_phaseset

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine meq_sameset(irem,iadd,meqrec,phr,ceq)
! iterate until phase set change, converged or error (incl too many its)
! iadd = -1 indicates called from calculating a sequence of equilibria
    implicit none
    integer irem,iadd
    TYPE(meq_setup) :: meqrec
    TYPE(meq_phase), dimension(*), target :: phr
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    integer increase,ioff,ik,jj,jph,ie,ierr,jmaxy
    integer kk,kkz,level3,mph,negam,negamph,nj,nk,nl
    integer nz1,nz2
    TYPE(meq_phase), pointer :: pmi
    logical, save :: once=.true.
!    character ch1*1
!    double precision, dimension(maxel) :: ccm
!    double precision, dimension(maxel) :: sccm
    double precision, dimension(5) :: qq
!    double precision, dimension(2) :: tpvalz
!    double precision, dimension(maxel+2) :: ycormax
    double precision, dimension(maxconst) :: ycormax
!    double precision phfrac(maxel)
    double precision, dimension(:,:), allocatable :: smat
    double precision, dimension(:), allocatable :: svar
! these arrays should maybe be allocated ....
    double precision, dimension(maxconst) :: ycorr,yarr
    integer converged,jz
    double precision chargefact,chargerr
    double precision dgm,summ,dgmmax,gsurf,phf,phs
    double precision prevmaxycorr,pv,signerr
    double precision xxx,ycormax2,yprev,ys,ysmm,ysmt,yss,yst
    double precision, parameter :: ylow=1.0D-3,ymin=1.0D-12,ymingas=1.0D-30
    double precision maxphch
    double precision sum
!    double precision, dimension(:), allocatable :: xcol
    double precision, dimension(:), allocatable :: cit
!    double precision, dimension(:,:), allocatable :: cpmat
    double precision deltat,deltap,deltaam,yfact
! this is an emergecy fix to improve convergence for ionic liquid
    double precision, parameter :: ionliqyfact=3.0D-1
!    double precision, parameter :: ionliqyfact=1.0D0
    integer iz,tcol,pcol
    integer notf,dncol,iy,jy,iremsave,phasechangeok
    double precision, dimension(:), allocatable :: lastdeltaam
    logical vbug
!
    if(iadd.eq.-1 .or. ocv()) then
       write(*,*)'Debug output in meq_sameset'
       vbug=.TRUE.; iadd=0
    else
       vbug=.FALSE.
    endif
!    vbug=.TRUE.
    if(vbug)write(*,*)'entering meq_sameset',meqrec%nphase,irem
    iremsave=irem
! this is max correction of constituent fraction for each phases
    ycormax=zero
! magic trying to force decreasing step in fractions
!    ymagic=one
!    nmagic=0
! this is an attempt to decrease variation in phase amount corrections
    allocate(lastdeltaam(meqrec%nstph))
! dimension matrix for conditions, components+stable phases
    nz1=meqrec%nrel-meqrec%nfixmu+meqrec%nstph-meqrec%nfixph
    if(meqrec%tpindep(1)) nz1=nz1+1
    if(meqrec%tpindep(2)) nz1=nz1+1
    if(ocv()) write(*,11)meqrec%nrel,meqrec%nfixmu,meqrec%nstph,&
         meqrec%nfixph,meqrec%tpindep,nz1,ceq%tpval(1)
11  format('In meq_sameset, sysmat: ',4i7,2l2,i5,1pe12.4)
    nz2=nz1+1
    if(vbug) write(*,*)'Allocating smat: ',nz1
    allocate(smat(nz1,nz2))
    allocate(svar(nz1))
! check if constituent fraction correction in stable phases increases
! for each iteration.  Needed for the Re-V case ....
    prevmaxycorr=zero
    increase=0
    level3=0
! this is set TRUE after 3 iterations
    phasechangeok=meqrec%noofits
! debugging problem with changing axis in mapping
    if(ocv() .and. meqrec%tpindep(1)) write(*,*)'variable T: ',ceq%tpval(1)
!-------------------------------------------------------------
! return here until converged or phase set change
100 continue
    meqrec%noofits=meqrec%noofits+1
! this is magic ....
!    nmagic=nmagic+1
!    if(mod(nmagic,5).eq.0) ymagic=0.5*ymagic
!    if(mod(nmagic,25).eq.0) ymagic=one
! end of magic
!101 format(a)
!    write(*,*)'Iteration: ',meqrec%noofits,' ----------------------------- '
    if(ocv()) write(*,199)meqrec%noofits,ceq%tpval(1),meqrec%nstph,&
         (meqrec%stphl(jz),jz=1,meqrec%nstph)
199 format(/'Equil iter: ',i3,f8.2', stable phases: ',i3,2x,10i3)
    if(meqrec%noofits.gt.ceq%maxiter) goto 1200
    converged=0
    if(vbug) write(*,*)'Iteration: ',meqrec%noofits,converged
! loop for all phases and composition sets, loop over phr
!    if(meqrec%tpindep(1)) write(*,*)'variable T: ',meqrec%noofits,ceq%tpval(1)
!
! >>>>>>>>>>>> here we can parallelize 
!
!-$omp parallel do private(pmi) shared(meqrec)
    parallel: do mph=1,meqrec%nphase
       pmi=>phr(mph)
! this routine calculates the phase matrix and inverts it.
! it also calculates the amounts of moles of components in the phase
!-$     write(*,*)'Phase and tread: ',mph,omp_get_thread_num()
       call meq_onephase(meqrec,pmi,ceq)
       if(gx%bmperr.ne.0) then
          if(pmi%stable.eq.0) then
! if this happends for an unstable phase just continue but ensure it will
! not be stable (in a very crude way)
!             write(*,*)'Matrix inversion error for unstable phase',pmi%iph
             pmi%curd%gval(1,1)=one
             gx%bmperr=0
          else
! Inversion error for stable phase is fatal, error code already set
             if(once) then
                write(*,*)'Warning, matrix inversion problem: ',pmi%iph
                once=.false.
             endif
!             stop
             gx%bmperr=0
          endif
       endif
!107       format(a,6(1pe12.3))
! end of pmi% scope
    enddo parallel
!-$omp end parallel do
!
!=======================================================================
! step 2: calculation of equil matrix
! Solve for chemical potentials and conditions using all stable phases
! The EQUIL MATRIX (smat) has one row for each stable phase and
! one row for each component representing a condition
! (If a fix phase condition or chem.pot. condition slightly different??)
!----------------------------------------
300 continue
    if(vbug) write(*,301)'Calculating general equil matrix',meqrec%nfixmu,&
         meqrec%nfixph,meqrec%tpindep,meqrec%noofits
301 format(a,2i2,2l2,i5)
! some arguments here are redundant but kept for some
    call setup_equilmatrix(meqrec,phr,nz1,smat,tcol,pcol,&
         dncol,converged,ceq)
    if(gx%bmperr.ne.0) goto 1000
!    write(*,*)'Back from setup_equilmatrix'
!=====================================================================
! debug output of equil matrix, last column is right hand side
380 continue
    if(vbug) then
! when problem output the smat here and (and svar below) and study!!!
       do iz=1,nz1
          write(*,228)'smat1:',(smat(iz,jz),jz=1,nz2)
       enddo
    endif
228 format(a,6(1pe12.4),(8x,6e12.4))
    call lingld(nz1,nz2,smat,svar,nz1,ierr)
    if(ierr.ne.0) then
       if(vbug) write(*,*)'Error solving equil matrix',meqrec%noofits,ierr
       if(iremsave.gt.0) then
! equil matrix wrong at first iteration after removing a phase
! This can be caused by having no phase with solubility of an element
! (happened in Fe-O-U-Zr calculation with just C1_MO2 stable and C1 does not
! dissolve Fe).  Try to set back the last phase removed!!
          write(*,*)'Emergency fix: ',iremsave
          iadd=iremsave
          goto 1100
       endif
       if(vbug) then
          do iz=1,nz1
             write(*,228)'smat2:',(smat(iz,jz),jz=1,nz2)
          enddo
       endif
!       do iz=1,nz1
!          write(*,228)'smat2:',(smat(iz,jz),jz=1,nz2)
!       enddo
       gx%bmperr=4203; goto 1000
    endif
! when problems output svar here !! (and smat above)
    if(vbug) write(*,228)'svar1:',(svar(jz),jz=1,nz1)
!
! if no error at first calculation after phase set change iremsave=0
    iremsave=0
    if(vbug) write(*,229)'pm: ',meqrec%noofits,(svar(iz),iz=1,nz1)
229 format(a,i3,6(1pe12.4))
!---------
! copy the chemical potentials, take care of fixed values ....
! new potentials are in svar(1..meqrec%nrel-meqrec%nfixmu)
    iz=1
    notf=1
    setmu: do ik=1,meqrec%nrel
       if(notf.le.meqrec%nfixmu) then
          if(ik.eq.meqrec%mufixel(notf)) then
! this potential is fixed, no incrementing "iz", ceq%cmuval(ik) is a condition
             notf=notf+1
             cycle setmu
          endif
       endif
       if(abs(svar(iz)-ceq%cmuval(ik)).gt.ceq%xconv) then
          if(vbug) write(*,387)'Unconverged pot: ',iz,ik,svar(iz),&
               ceq%cmuval(ik),abs(svar(iz)-ceq%cmuval(ik)),ceq%xconv
387       format(a,2i3,2(1pe14.6),2(1pe12.4))
          converged=7
       endif
       ceq%cmuval(ik)=svar(iz)
       iz=iz+1
    enddo setmu
    ioff=meqrec%nrel-meqrec%nfixmu+1
!------------
! update T and P if variable
    if(meqrec%tpindep(1)) then
       xxx=ceq%tpval(1)
! limit changes in T to +/-half its current value
       if(abs(svar(ioff)/ceq%tpval(1)).gt.0.2D0) then
          svar(ioff)=sign(0.2D0*ceq%tpval(1),svar(ioff))
       endif
       deltat=svar(ioff)
! limit maximum change in deltat
       if(abs(deltat).gt.meqrec%tpmaxdelta(1)) then
          deltat=sign(meqrec%tpmaxdelta(1),deltat)
          if(ocv()) write(*,386)'limit the change in T: ',&
               ceq%tpval(1),deltat,svar(ioff)
386       format(a,3(1pe12.4))
       endif
       ceq%tpval(1)=ceq%tpval(1)+deltat
! problems here when -finit-local-zero is removed
       if(vbug) write(*,*)'T and deltaT:',ceq%tpval(1),deltat
       if(ceq%tpval(1).le.0.1D0) then
          write(*,*)'Attempt to set temperature less than 0.1 K !!!'
          gx%bmperr=4187; goto 1000
       endif
       ioff=ioff+1
    endif
    if(meqrec%tpindep(2)) then
       xxx=ceq%tpval(2)
       if(abs(svar(ioff)/ceq%tpval(2)).gt.0.2D0) then
          svar(ioff)=sign(0.2D0*ceq%tpval(2),svar(ioff))
       endif
       deltap=svar(ioff)
! limit the changes in P
       if(abs(deltap).gt.meqrec%tpmaxdelta(2)) then
          deltap=sign(meqrec%tpmaxdelta(2),deltap)
          if(ocv()) write(*,386)'limit the change in P: ',&
               ceq%tpval(2),deltap,svar(ioff)
       endif
       ceq%tpval(2)=ceq%tpval(2)+svar(ioff)
       if(ceq%tpval(2).le.0.1D0) then
          write(*,*)'Attempt to set pressure lower than 0.1 Pa!!!'
          gx%bmperr=4187; goto 1000
       endif
       ioff=ioff+1
    endif
!------------
! update phase amounts, take care of fixed phases ....
! the change in amounts are in svar(ioff+...)
    negamph=0
    negam=0
    irem=0
! dncol+1 should be the first Delta_phase-amount
    ioff=dncol+1
! scale all changes in phase amount with total number of atoms. At present
! assume this is unity.  Without scaling phase changes can be +/-1E+11 or more
! which creates instabilities
    maxphch=zero
!    normphchange: do jph=1,meqrec%nstph
    normphchange: do jph=1,meqrec%nstph-meqrec%nfixph
       if(abs(svar(ioff+jph-1)).gt.maxphch) maxphch=abs(svar(ioff+jph-1))
    enddo normphchange
    if(maxphch.gt.one) then
       ioff=dncol+1
       do jph=1,meqrec%nstph-meqrec%nfixph
          svar(ioff+jph-1)=svar(ioff+jph-1)/maxphch
       enddo
    endif
!
    ioff=dncol+1
    phamount2: do jph=1,meqrec%nstph
! loop for all stable phases
       jj=meqrec%stphl(jph)
!       phr(jj)%curd%damount=zero
!       kkz=test_phase_status(phr(jj)%iph,phr(jj)%ics,xxx,ceq)
       kkz=phr(jj)%phasestatus
! new -4=hidden, -3 suspended, -2 dormant, -1,0,1 entered, 2 fixed
       if(kkz.ge.PHENTUNST .and. kkz.le.PHENTSTAB) then
! phase is entered so its amount can change, -svar(ioff) is the change
          phs=phr(jj)%curd%amfu
          deltaam=svar(ioff)
! limit change in amount of phase
          if(abs(deltaam).gt.ceq%xconv) then
! For the equil O-U with conditions on N(O) and N(U) there is no problem
! with the amount of C1 but with N= and x(O)= the phase amount change varies
! with sign and converges very slowly.  Probably an interference with the
! charge balance criteria.
             if(lastdeltaam(jph)*deltaam.lt.zero) then
! wow, this seems to work ... other attmepts interfere directly with the
! charge balance so one should carefully check how they are connected...
!                deltaam=5.0D-1*deltaam
! The half worked to C1+tetragonal, it did not work for ionic liquid misc. gap
! and in that case there is no charge balance criteria ... suck
!                deltaam=5.0D-1*deltaam
! Dubbelt wow ... 0.2 works for both cases ... why?? More iterations though .. 
                deltaam=2.0D-1*deltaam
                if(ocv()) write(*,3)'Phase amount sign change: ',&
                     meqrec%noofits,jph,jj,phs,lastdeltaam(jph),deltaam
!                write(*,3)'Phase amount sign change: ',&
!                     meqrec%noofits,jph,jj,phs,lastdeltaam(jph),deltaam
3               format(a,3i3,6(1pe12.4))
             endif
             if(converged.lt.6) converged=6
! desperate fix, change sign of deltaam
!             deltaam=-deltaam
             if(vbug) write(*,381)'Phase amount change: ',meqrec%noofits,jj,&
                  phs,deltaam
381          format(a,2i3,4(1pe12.4))
          endif
          lastdeltaam(jph)=deltaam
          if(phr(jj)%curd%amfu-deltaam.le.zero) then
             if(meqrec%nstph.eq.1) then
! this is the only stable phase!  cannot have negative or zero amount!
                deltaam=phr(jj)%curd%amfu-1.0D-2
             endif
          endif
          if(-deltaam.gt.one) then
! try to prevent too large increase in phase amounts.  Should be related to
! total amount of components.
             deltaam=-one
          endif
          phf=phr(jj)%curd%amfu-deltaam
          if(vbug) write(*,363)'Stable phase: ',jj,phr(jj)%iph,&
               phr(jj)%ics,phf,phs,deltaam
363          format(a,3i3,6(1pe12.4))
!          phr(jj)%curd%damount=deltaam
          ioff=ioff+1
       elseif(kkz.eq.PHFIXED) then
! phase is fix, there is no change in its amounts
          phf=phr(jj)%curd%amfu
!          write(*,*)'Fixed phase: ',jj,phf
       else
! phase is dormant or suspended, must not be stable!!!!
          write(*,373)phr(jj)%iph,phr(jj)%ics,kkz
373       format('This phase must not be stable:',3i7)
          gx%bmperr=7777; goto 1000
       endif
! problem with Fe-O-U-Zr convergence, all phases disappear ??
!       write(*,364)'Stable phase: ',meqrec%noofits,jj,phr(jj)%iph,&
!       phr(jj)%ics,phf,phs,phr(jj)%prevam
!364    format(a,4i3,6(1pe12.4))
! make sure the driving force of stable phases to zero
       phr(jj)%curd%dgm=zero
       if(phf.lt.zero) then
! phase has negative amount, NOT ALLOWED if it is the only stable phase 
          if(meqrec%nstph-meqrec%nfixph.eq.1) then
             write(*,367)'Trying to remove the only stable phase ',jj,&
                  phr(jj)%curd%amfu
367          format(a,i3,1pe14.6)
             phf=0.5D0*phr(jj)%curd%amfu
             gx%bmperr=7867; goto 1000
          else
!             write(*,363)'Phase with negative amount: ',jj,0,0,&
!                  phf,phs,phr(jj)%prevam
!             if(phf.lt.-1.0D-2) phf=zero
             if(phr(jj)%prevam.lt.zero) then
! remove this phase if negative amount previous iteration also
                irem=jj
! jumping to 1000 here means constitutions not changed in this iteration
                goto 1000
             else
! mark this phase had negative amount this iteration
! PROBLEM removing one of two composition sets of the same phase,
! (miscibility gap), they may change which have negative amount each iteration
                phr(jj)%prevam=-one
                phf=zero
             endif
          endif
       else ! phase has positive amount, mark in prevam
          phr(jj)%prevam=one
       endif
! store the new phase fraction (moles formula units)
       phr(jj)%curd%amfu=phf
    enddo phamount2 ! end of loop for jph=1,meqrec%nstph
!
    if(vbug) write(*,*)'finished updating phase amounts: ',&
         meqrec%noofits,phasechangeok,irem
!-------------------------------------------------------
! After solving the equil matrix and updating the chemical potentials,
! the phase amounts and possibly T and P we correct constitions of all phases
! - Now calculate correction of constituent fractions for all phases
! See BoJ thesis eq. 30 (also in metastable phases) (paper I)
! At the same time calculate the driving force for metastable phases
    ycorr=zero
    ycormax2=zero
! to handle charge balance correction of constituent fractions
    chargerr=zero
! chargerr fitted to fastest convergence using the ou test case
!    chargefact=1.0D-1 requires more than 100 iterations
!    chargefact=one requires more than 100 iterations
! this value requires about 40 iteration
    chargefact=5.0D-1
!    chargefact=1.0D-1
! kk is used to check if a charged phase is stable,
! it is incremented for each stable phase
    kk=1
! iadd is set to the unstable phase with largest positive driving force
! dgmmax is the largest psoitive driving force
    iadd=0
    dgmmax=zero
    ysmm=zero
!-----------------------------------------------------
! Update the constitutions.  If irem>0 remove this phase unless
! we have made at least 3 iterations with the current phase set
    if(irem.gt.0 .and. meqrec%noofits-phasechangeok.gt.3) goto 1000
!--------------------------
    lap: do jj=1,meqrec%nphase
! The current chemical potentials are in ceq%cmuval(i)
!       if(vbug) write(*,*)'Phase: ',phr(jj)%iph,phr(jj)%ics,&
!              phr(jj)%curd%amfu
       if(jj.eq.meqrec%stphl(kk)) then
! jj is stable, increment kk but do not make it larger than meqrec%nstph
! save index in meqrec%stphl in jph
          jph=kk
          kk=min(kk+1,meqrec%nstph)
       else ! phase is not stable
! calculate driving force for unstable phases. First calculate the sum
! of the current phase composition and the calculated chemical potentials
          jph=0
          gsurf=zero; summ=zero
          do ie=1,meqrec%nrel
             gsurf=gsurf+phr(jj)%xmol(ie)*ceq%cmuval(ie)
             summ=summ+phr(jj)%xmol(ie)
          enddo
          gsurf=gsurf/summ
! calculate G_m plus any deltat and deltap terms
          dgm=phr(jj)%curd%gval(1,1)
          if(meqrec%tpindep(1)) then
             dgm=dgm+phr(jj)%curd%gval(2,1)*deltat
          endif
          if(meqrec%tpindep(2)) then
             dgm=dgm+phr(jj)%curd%gval(3,1)*deltap
          endif
! scale dgm per mole atoms
          dgm=gsurf-dgm/phr(jj)%curd%abnorm(1)
          if(dgm.gt.dgmmax) then
             if(phr(jj)%phasestatus.ge.PHENTUNST .and. &
                phr(jj)%phasestatus.le.PHENTERED) then
! phase is entered, can have status changed
! if this is another constitution set of an already stable phase then check
! below if the constitution of this phase is very similar to the stable one
                iadd=jj
                dgmmax=dgm
             endif
          endif
          phr(jj)%prevdg=dgm
          phr(jj)%curd%dgm=dgm
       endif
! Update constituent fractions for ALL phases, stable or not
! if phr(jj)%xdone=1 then phase has no composition variation
       if(phr(jj)%xdone.eq.1) cycle
!----------------------------------------------------
       allocate(cit(phr(jj)%idim))
       cit=zero
       if(meqrec%tpindep(1)) then
! variable T, code copied from calc_dgdyterm, cit(nj) used below
!          write(*,44)'index 1: ',jj,phr(jj)%ncc,phr(jj)%idim,&
!               size(phr(jj)%invmat)
          do jy=1,phr(jj)%ncc
             sum=zero
             do iy=1,phr(jj)%ncc
                sum=sum+phr(jj)%invmat(iy,jy)*&
                     phr(jj)%curd%dgval(2,iy,1)
             enddo
             cit(iy)=sum*deltat
!             write(*,44)'index 2: ',jj,jy,iy,0,sum
!44           format(a,4i3,6(1pe12.4))
          enddo
!! end copy
!          write(*,*)'Adding contribution from variable T to delta-y',&
!               phr(jj)%ncc
! missing code for correction due to variable P?????
       endif
!
       moody: do nj=1,phr(jj)%ncc
          ys=zero
          do nk=1,phr(jj)%ncc
             pv=zero
             do nl=1,meqrec%nrel
! ceq%cmuval(nl) is the chemical potential of element nl (divided by RT)
! phr(jj)%dxmol(nl,nk) is the derivative of component nl
! wrt constituent nk
                pv=pv+ceq%cmuval(nl)*phr(jj)%dxmol(nl,nk)
             enddo
             pv=pv-phr(jj)%curd%dgval(1,nk,1)
             ys=ys+phr(jj)%invmat(nj,nk)*pv
          enddo
          if(phr(jj)%chargebal.eq.1) then
! For charged phases add a term 
! phr(jj)%invmat(phr(jj)%idim,phr(jj)%idim)*Q
             ys=ys-chargefact*phr(jj)%invmat(nj,phr(jj)%idim)*&
                  phr(jj)%curd%netcharge
!             ys=ys-chargefact*phr(jj)%invmat(nj,phr(jj)%idim)*&
!                  phr(jj)%charge
! jph is nonzero only for stable phases
             if(jph.gt.0 .and. &
!             if(jj.eq.meqrec%stphl(kk) .and. &
! Hm, is this check correct?  kk is updated above to be the next stable phase..
!                  abs(phr(jj)%charge).gt.chargerr) then
!                chargerr=abs(phr(jj)%charge)
!                signerr=phr(jj)%charge
                  abs(phr(jj)%curd%netcharge).gt.chargerr) then
                chargerr=abs(phr(jj)%curd%netcharge)
                signerr=phr(jj)%curd%netcharge
             endif
!             write(*,*)'Charge: ',jj,phr(jj)%netcharge
          endif
          ycorr(nj)=ys+cit(nj)
          if(abs(ycorr(nj)).gt.ycormax2) then
             ycormax2=ycorr(nj)
          endif
          if(abs(ys).gt.ceq%xconv) then
! if the change in any constituent fraction larger than xconv continue iterate
!             write(*,*)'Convergence criteria, phase/const: ',jj,nk
             if(phr(jj)%stable.eq.0) then
! Phase is not stable
                if(abs(ys).gt.1.0D1*phr(jj)%curd%yfr(nj)) then
! for unstable phases the corrections must be smaller than ...????
                   if(converged.lt.3) then
                      converged=3
                      yss=ys
                      yst=phr(jj)%curd%yfr(nj)
                   endif
                elseif(abs(ys).gt.1.0D2*ceq%xconv) then
! maybe accept 100 times larger correction than for stable phases
!                   write(*,107)'metast ph ycorr: ',ys,&
!                        phr(jj)%curd%yfr(nj)
                   if(converged.lt.2) then
                      converged=2
                      yss=ys
                      yst=phr(jj)%curd%yfr(nj)
                   endif
                else
                   if(converged.eq.0) then
                      converged=1
                      yss=ys
                      yst=phr(jj)%curd%yfr(nj)
                   endif
                endif
             elseif(converged.lt.4) then
! large correction in fraction of constituent fraction of stable phase
                converged=4
                yss=ys
                yst=phr(jj)%curd%yfr(nj)
             endif
          elseif(phr(jj)%stable.eq.1) then
! check to find good convergence criteria in Re-V test case
             if(abs(ycorr(nj)).gt.ysmm) then
                jmaxy=jj
                ysmm=abs(ycorr(nj))
                ysmt=phr(jj)%curd%yfr(nj)
             endif
          endif
          goto 77
!-----------------------------------------------------------
! fetch constituent fractions directly from phase_varres record
          yprev=phr(jj)%curd%yfr(nj)
          yarr(nj)=yprev+ycorr(nj)
! NOTE: yarr(nj) will be recalculated below if ycormax2 larger than 0.5
!          if(vbug) then
! output to check reasons for bad convergence
!             write(*,57)'MM y&dy ',phr(jj)%iph,phr(jj)%ics,&
!                  phr(jj)%stable,nj,&
!                  ys,cit(nj),phr(jj)%curd%yfr(nj),yarr(nj),ycorr(nj)
!57           format(a,3i2,i3,5(1pe12.4))
!          endif
          if(yarr(nj).lt.ymin) then
! this added to avoid too drastic jumps in small fractions
! The test case ccrfe1.BMM needs this
             if(yprev.gt.ylow) then
!                write(*,*)'Applying fraction change limitation'
                yarr(nj)=0.9*ylow
             elseif(test_phase_status_bit(phr(jj)%iph,PHGAS)) then
!             elseif(test_phase_status_bit(phr(jj)%iph,PHGAS,ceq)) then
! for gas phase one must allow smaller constituent fractions
                if(yarr(nj).lt.ymingas) then
                   yarr(nj)=ymingas
                endif
             else
                yarr(nj)=ymin
             endif
          endif
          if(yarr(nj).gt.one) then
             yarr(nj)=one
          endif
!          if(phr(jj)%stable.eq.1) then
!            write(*,51)'at 5A: ',jj,nj,phr(jj)%iph,phr(jj)%ics,&
!                 phr(jj)%stable,ys,ymagic,phr(jj)%curd%yfr(nj),&
!                 yarr(nj),phr(jj)%stable,ys,cit(nj),&
!                 phr(jj)%curd%yfr(nj),yarr(nj)
!          endif
77        continue
       enddo moody
! end of correction of y fractions
!---------------------------------
!       write(*,263)'yarr3: ',jj,&
!            (phr(jj)%curd%yfr(jz),jz=1,phr(jj)%ncc)
!263    format(a,i3,6(1pe12.4))
!       write(*,*)'phase: ',phr(jj)%iph,phr(jj)%ics
!       write(*,107)'ycorr: ',(ycorr(jz),jz=1,phr(jj)%ncc)
!       write(*,107)'yarr: ',(yarr(i),i=1,phr(jj)%ncc)
! maybe one can set constitution directly but some internal arrays need
! updating for each new constitition so better use the subroutine below
!       write(*,263)'mm yarr4: ',jj,(yarr(jz),jz=1,phr(jj)%ncc)
!       write(*,71)'v1: ',jj,(ycorr(nj),nj=1,phr(jj)%ncc)
!71     format(a,i2,6(1pe12.4))
!       goto 78
!-----------------------------------------
! Limit change in fractions .... all ycorr(nj) multiplied with same factor
! keeping the sum of corrections in all sublattices as zero
       if(vbug) write(*,74)'maximum corr: ',&
            meqrec%noofits,jj,ycormax2,ycormax(jj)
74     format(a,2i3,2(1pe12.4))
       if(ycormax(jj)*ycormax2.le.zero) then
! the condition is zero at first step, limit that
          yfact=one/(2.0D0+abs(ycormax2))
          ycormax2=yfact*ycormax2
       elseif(phr(jj)%ionliq.gt.0 .and. ycormax2.lt.1.0D-4) then
! step seems to be very small ... try to decrease number of iteration
          yfact=2.0d0
       else
          yfact=one
       endif
       moody2: do nj=1,phr(jj)%ncc
! all corrections of constituent fractions in ycorr(1..phr(jj)%ncc)
! ymagic is halfed every 5th iteration when same phase set, after 5 times reset
          yprev=phr(jj)%curd%yfr(nj)
!          yarr(nj)=yprev+ycorr(nj)
          if(phr(jj)%ionliq.gt.0) then
! For ionic liquids, an even smaller step is allowed ...
! The O-Pu-U test case converged up to 2800 without any particular factor
! with a factor 0.4 it converged up to 3000K (~150 its), yfact does not
! has any significant influence. 
!             yarr(nj)=yprev+4.0D-1*ycorr(nj)*yfact
! tafidbug, 0.2 created problems
!             yarr(nj)=yprev+2.0D-1*ycorr(nj)*yfact
!             yarr(nj)=yprev+3.0D-1*ycorr(nj)*yfact
             yarr(nj)=yprev+ionliqyfact*ycorr(nj)*yfact
!             yarr(nj)=yprev+ycorr(nj)*yfact
!             write(*,281)'ycorr: ',nj,yfact,yprev,yarr(nj)
281           format(a,i3,6(1pe12.4))
          else
             yarr(nj)=yprev+ycorr(nj)*yfact
          endif
!          if(vbug) then
! output to check reasons for bad convergence
!             write(*,57)'MM y&dy ',phr(jj)%iph,phr(jj)%ics,&
!                  phr(jj)%stable,nj,&
!                  ys,cit(nj),phr(jj)%curd%yfr(nj),yarr(nj),ycorr(nj)
!57           format(a,3i2,i3,5(1pe12.4))
!          endif
          if(yarr(nj).lt.ymin) then
! this added to avoid too drastic jumps in small fractions
! The test case ccrfe1.BMM needs this
             if(yprev.gt.ylow) then
!                write(*,*)'Applying fraction change limitation'
                yarr(nj)=0.9*ylow
             elseif(test_phase_status_bit(phr(jj)%iph,PHGAS)) then
! for gas phase one must allow smaller constituent fractions
                if(yarr(nj).lt.ymingas) then
                   yarr(nj)=ymingas
                endif
             else
                yarr(nj)=ymin
             endif
          endif
          if(yarr(nj).gt.one) then
             yarr(nj)=one
          endif
       enddo moody2 ! end loop for all constituents nj in phase jj
!
       ycormax(jj)=ycormax2
! >>>>>>>>>>>>>>>>>> HERE the new constitution is set <<<<<<<<<<<<<<<<<<<<<
       call set_constitution(phr(jj)%iph,phr(jj)%ics,yarr,qq,ceq)
       if(gx%bmperr.ne.0) goto 1000
       deallocate(cit)
    enddo lap
! finished correction of all constituent fractions in all phases
!-------------------------------------------------------
!    do jph=1,meqrec%nstph
!       jj=meqrec%stphl(jph)
!       write(*,393)'Stable phase: ',phr(jj)%iph,phr(jj)%ics,&
!            phr(jj)%curd%amfu
!    enddo
!393 format(a,2i4,6(1pe12.4))
! check if fraction corrections in stable phases increases
! it solved a problem in ReV when fractions initially changed very little
! but the change increased each iteration
    if(meqrec%noofits.gt.8) then
       increase=0
    elseif(abs(ysmm).gt.prevmaxycorr) then
! do this check only for the first 8 iterations
       increase=1
!       write(*,265)increase,ysmm,prevmaxycorr
!265    format('*** max stable phase ycorr: ',i3,2(1pe12.4))
    endif
    prevmaxycorr=abs(ysmm)
!-------------------------------------------------------
! check charge balance, must be 100 times better than fractions
! otherwise strange chemical potentials, why??
! The request for 100 times better than ceq%xconv is OK with conditions 
! N(U)= N(O)= but not with N= x(O)=
!    if(chargerr.gt.1.0D-2*ceq%xconv) then
! strengthen charge balance convergence criteria
    if(chargerr.gt.ceq%xconv) then
       if(ocv()) write(*,654)'Charge error: ',signerr,chargerr,ceq%xconv
654    format(a,6(1pe12.4))
       if(converged.lt.6) converged=6
    endif
!-------------------------------------------------------
    if(converged.eq.3) then
! force some iterations with large fraction variations in unstable phases
!       write(*,267)'End of iteration: ',meqrec%noofits,converged,&
!            increase,yss,yst
       level3=level3+1
    elseif(converged.eq.4) then
! this meas large fraction variations in stable phases
!       write(*,267)'End of iteration: ',meqrec%noofits,converged,&
!            increase,yss,yst
!267    format(a,3i4,2(1pe12.4))
       level3=0
    else
!       write(*,267)'End of iteration: ',meqrec%noofits,converged,increase
       level3=0
    endif
!----------------------------------------------
! continue iterate if phase change or not converged
    if(iadd.gt.0) then
! check if phase to be added is already stable as another composition set
! This check should maybe be above as maybe another phase want to be stable??
       if(same_composition(iadd,phr,meqrec,ceq,dgm)) iadd=0
    endif
    if(meqrec%noofits.gt.2 .and. (irem.gt.0 .or. iadd.gt.0)) then
! if a phase have negative amount remove it or if a phase has positive
! driving force add it
       if(vbug) write(*,363)'Phase set change remove/add: ',&
            irem,iadd,0,phf,dgmmax
       goto 1100
    endif
!    write(*,*)'Iterations and convergence: ',meqrec%noofits,converged
    if(vbug) write(*,*)'Convergence criteria: ',converged
! converged=1 or 2 means constituent fraction in metastable phase not converged
!    write(*,*)'Convergence criteria: ',converged
    if(converged.gt.3) goto 100
! converged 3 means large change conts. fraction of unstable phase change a lot
    if(converged.eq.3 .and. level3.lt.4) goto 100
! converged 4 means a constituent fraction of a stable phase change a lot
! converged=5 means a condition not fullfilled
! converged=6 means charge balance not converged or large phase fraction change
! converged=7 means large change in chemical potentials
! always force 4 iterations, there is a minimum above forcing 9 iterations.
    if(meqrec%noofits.lt.4) goto 100
    if(increase.ne.0) then
! continue if corrections in constituent fractions in stable phases increases
       goto 100
    endif
!------------------------
! equilibrium calculation converged, do some common thing
    goto 800
!
!==============================================================
! equilibrium calculation converged, save chemical potentials (svar*RT)
800 continue
!------------------------------------------------------
! do not save system matrix but save -dimension for use with derivatives
    ceq%sysmatdim=-nz1
! but save components with fix mu and fix phases
    ceq%nfixmu=meqrec%nfixmu
    if(allocated(ceq%fixmu)) deallocate(ceq%fixmu)
    if(ceq%nfixmu.gt.0) then
       allocate(ceq%fixmu(ceq%nfixmu))
       do ie=1,ceq%nfixmu
          ceq%fixmu(ie)=meqrec%mufixel(ie)
       enddo
    endif
    ceq%nfixph=meqrec%nfixph
    if(allocated(ceq%fixph)) deallocate(ceq%fixph)
    if(ceq%nfixph.gt.0) then
       allocate(ceq%fixph(2,ceq%nfixph))
       do ie=1,ceq%nfixph
! phase and composition set numbers
          ceq%fixph(1,ie)=meqrec%fixph(1,ie)
          ceq%fixph(2,ie)=meqrec%fixph(2,ie)
       enddo
    endif
!-------------------------------------
    if(vbug) write(*,*)'At 800 in meq_sameset: ',meqrec%nrel
    ceq%rtn=globaldata%rgas*ceq%tpval(1)
    do ie=1,meqrec%nrel
       ceq%complist(ie)%chempot(1)=ceq%cmuval(ie)*ceq%rtn
!       write(*,*)'Chempot/RT: ',cea%cmuval(ie),svar(ie)
    enddo
! list stable phases on exit
!    do jph=1,meqrec%nstph
!       jj=meqrec%stphl(jph)
!       write(*,393)'Stable phase Z: ',phr(jj)%iph,phr(jj)%ics,&
!            phr(jj)%curd%amfu
!    enddo
! set status of the stable phases on exit
    do jph=1,meqrec%nstph
       jj=meqrec%stphl(jph)
       call mark_stable_phase(phr(jj)%iph,phr(jj)%ics,ceq)
!       write(*,393)'Stable phase Z: ',phr(jj)%iph,phr(jj)%ics,&
!            phr(jj)%curd%amfu
    enddo
!----------------------
! save inverted phase matrix and more for future use when calculating H.T etc
! If already allocated then dealloc/alloc as number of constituents can change
!    if(vbug) write(*,*)'allocate/deallocate in meq_sameset: ',meqrec%nphase
    do jj=1,meqrec%nphase
       if(allocated(phr(jj)%curd%cinvy)) then
          deallocate(phr(jj)%curd%cinvy)
          deallocate(phr(jj)%curd%cxmol)
          deallocate(phr(jj)%curd%cdxmol)
       endif
! why is the dimension if invmat so different???
       ie=phr(jj)%idim
       if(vbug) write(*,*)'Allocate in meq_sameset: ',jj,ie
!       ie=int(sqrt(real(size(phr(jj)%invmat)))+0.1)
!       write(*,*)'Size: ',ie,phr(jj)%ncc
       allocate(phr(jj)%curd%cinvy(ie,ie))
       allocate(phr(jj)%curd%cxmol(meqrec%nrel))
       allocate(phr(jj)%curd%cdxmol(meqrec%nrel,phr(jj)%ncc))
       phr(jj)%curd%cinvy=phr(jj)%invmat
       phr(jj)%curd%cxmol=phr(jj)%xmol
       phr(jj)%curd%cdxmol=phr(jj)%dxmol
!----------------------
    enddo
1000 continue
    if(gx%bmperr.ne.0) then
       ceq%status=ibset(ceq%status,EQFAIL)
!      write(*,*)'minimization error: ',gx%bmperr
!   elseif(irem.eq.0 .and. iadd.eq.0) then
    endif
! jump here if phase change
1100 continue
    if(vbug) write(*,*)'Deallocating smat and svar'
    deallocate(smat)
    deallocate(svar)
    if(vbug) write(*,*)'Final return from meq_sameset'
    return
! too many iterations
1200 continue
!    write(*,*)'Too many iterations: ',meqrec%noofits,ceq%maxiter
    gx%bmperr=4204
    goto 1000
  end subroutine meq_sameset

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine setup_equilmatrix(meqrec,phr,nz1,smat,tcol,pcol,&
       dncol,converged,ceq)
! handels external conditions on extensive variables in the equil matrix
! meqrec and phr contains data for phases, nz1 is dimension of equlibrium
! matrix, smat is the equilibrium matrix, tcol and pcol are columns for
! variable T or P, dncol is the column with phase amount variables.
! converged is used to indicate calling routine and set if not converged
! external variable.
    TYPE(meq_setup) :: meqrec
    TYPE(meq_phase), dimension(*), target :: phr
    double precision smat(nz1,nz1+1)
    integer nz1,tcol,pcol,converged,dncol
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    TYPE(gtp_condition), pointer :: condition,lastcond
    TYPE(meq_phase), pointer :: pmi
    integer cmix(10),cmode,stvix,stvnorm,sel,sph,scs,jph,jj,ie,je,ke,ncol
    integer notf,nz2,nrow
    double precision cvalue,totam,pham,mag,mat,map,xxx,zval,xval
! the next line of values are a desperate search for a solution
    double precision totalmol,totalmass,check1,check2
    double precision, allocatable :: xcol(:),mamu(:),zcol(:)
    double precision, allocatable :: xxmm(:),wwnn(:),hval(:)
    logical :: vbug=.FALSE.

!-------------------------------------------------------------------
! Formulating the equil equation in general:
! Variables (one column per variable):
! - The chemical potentials of the components:     MEQREC%NREL
!   minus the number of fixed chemical potentials: -MEQREC%NFIXMU
! - The variation in T if not fixed                +1
! - The variation in P if not fixed                +1
! - The variation of the amounts of stable phases: MEQREC%NSTPH
!   minus those that have fixed amount:            -MEQREC%NFIXPH
!
! The variables will be ordered: MU, DeltaT, DeltaP, Delta Phase amounts
! this is important for the order of columns in the equil matrix
!
! Equations (one row per equation):
! If T or P are variable extra columns and terms are needed
! - The expression for the Gibbs energy for each stable phase, M_A mu_A = G
!   if a fixed chemical potentials incorporated that incorporated
!   if T or P variable an extra term for these
! - The user defined conditions like:
!   - Amount of components, N(A)= or B(A)=
!   - The total amount of moles, N=, or mass, B=
!   - Overall mole fractions, x(A)=, or mass fractions, w(A)=
!   - Phase specific mole or mass fractions, x(FCC,C)= or w(LIQUID,B)=
!   - The volume V=; enthalpy H= etc., with phase spec and normallizing
!   - relations between state variables x(C14,Fe)-x(liq,Fe)= 0 etc.
!
! The equations will always have the G expressions first.  The other will 
! be random (or in order of the user entered them)
!
! There must be as many equations as there are variables and the construction
! of the equations can be rather complex.  
! At present only a limited set has been implemented.
!
! A serious bug concerning mole fraction condition was fixed 2014.09.30
!
!-------------------------------------------------------------------
! zero all values in equil matrix, dimension (nz1)x(nz1)
    nz2=nz1+1
    smat=zero
!    dncol=0
!    write(*,*)'in setup_equil: ',converged,nz1,meqrec%tpindep
    if(converged.ge.0) then
! converged < 0 means called from dot derivative, then tcol or pcol set
! otherwise set them to zero
       tcol=0
       pcol=0
       dncol=0
!    else
!       write(*,11)meqrec%nstph,dncol
!11     format('setup: ',10i5)
    endif
!-----------------------------------------------------------
! step 2.1 the Gibbs energies for the stable phases (incl fixed)
    allstableph: do jph=1,meqrec%nstph
       jj=meqrec%stphl(jph)
!       write(*,*)'Stable phase: ',phr(jj)%iph,phr(jj)%ics,phr(jj)%curd%amfu
! column nz2 is the right hand side of the equation, to molar G
       smat(jph,nz2)=phr(jj)%curd%gval(1,1)
!       write(*,313)'Gm: ',0,0,jph,nz2,smat(jph,nz2),ceq%tpval(1)
! one column with amount of component A for each variable chemical potential
! components with fixed chemical potential are automatically skipped
       ncol=1
       xxx=zero
       gloop: do je=1,meqrec%nrel
          do ie=1,meqrec%nfixmu
             if(meqrec%mufixel(ie).eq.je) then
! meqrec%mufixel(ie) is the component number with fix mu, better use cmuval ?
! UNIFISHED: reference state must be handelled (may depend on T) ??
                xxx=smat(jph,nz2)
                smat(jph,nz2)=smat(jph,nz2)-&
                     phr(jj)%xmol(je)*meqrec%mufixval(ie)
!                write(*,312)'fix mu: ',jj,je,ie,xxx,smat(jph,nz2),&
!                     phr(jj)%xmol(je),meqrec%mufixval(ie)
312             format(a,3i3,6(1pe12.4))
                cycle gloop
             endif
          enddo
          smat(jph,ncol)=phr(jj)%xmol(je)
          ncol=ncol+1
       enddo gloop
       
       if(meqrec%tpindep(1)) then
! column for variable T, value is -dG/dT ??
          if(tcol.eq.0) then
             tcol=ncol
             dncol=ncol
             ncol=ncol+1
          endif
          smat(jph,tcol)=-phr(jj)%curd%gval(2,1)
       endif
       if(meqrec%tpindep(2)) then
! column for variable P, value is +dG/dP ??
          if(pcol.eq.0) then
             pcol=ncol
             dncol=ncol
             ncol=ncol+1
          endif
          smat(jph,pcol)=-phr(jj)%curd%gval(3,1)
       endif
    enddo allstableph
! we have generated meqrec%nstph rows with ncol columns and rhs in column nz2
! The columns for delta_phase-amounts should be zero
! dncol is number of variable potentials (including T or P if variable)
    if(dncol.eq.0) dncol=ncol-1
!    do iz=1,dncol
!       write(*,228)'smat 1: ',(smat(iz,jz),jz=1,nz2)
!    enddo
!228    format(a,6(1pe12.4))
!    nrow=meqrec%nstph
!-------------------------------------------------------------------
! step 2.2 equations due to user conditions on extensive/normalizzed properties
! nz2 is number of columns, last column is right hand side (rhs)
! nrow is number of nows already filled (G for stable ph)
!    nz2=nz1+1
!
! >>>>>>>>>>> THIS IS UNFINISHED, ONLY A FEW STATE VARIABLES ALLOWED
!
    nrow=meqrec%nstph
    lastcond=>ceq%lastcondition
    condition=>lastcond
    allocate(mamu(meqrec%nrel))
350 continue
    cmode=0
    cmix=0
    condition=>condition%next
! This is the prescribed value of the condition
    call apply_condition_value(condition,cmode,cvalue,cmix,ceq)
    if(gx%bmperr.ne.0) goto 1000
! Only cmix(1)=5 is interesting here
    if(cmix(1).ne.5) then
! loop if not the last condition
!       write(*,*)'Taking next condition: ',cmix(1)
       if(.not.associated(condition,lastcond)) goto 350
       goto 380
    endif
! do something with the condition ... it can be N=1, x(A)=.1, VM(GAS)=1e-6 etc.
! THE MASTER VERSION OF THIS TABLE in PMOD25C.F90
! symb cmix(2) indices                   irrelevant Property
! U       10   (phase#set)                    6     Internal energy (J)
! UM      11    "                             6     per mole components
! UW      12    "                             6     per kg
! UV      13    "                             6     per m3
! UF      14    "                             6     per formula unit
! S       2x    "                             7     entropy
! V       3x    "                             8     volume
! H       4x    "                             9     enthalpy
! A       5x    "                            10     Helmholtz energy
! G       6x    "                            11     Gibbs energy
! NP      7x    "                            12     moles of phase
! BP      8x    "                            13     mass of moles
! DG      9x    "                            15     Driving force
! Q       19x   "                            14     Internal stability
! N       11x  (component/phase#set,component) 16  moles of components
! X       111   "                            17     mole fraction of components
! B       12x   "                            18     mass of components
! W       122   "                            19     mass fraction of components
! Y       13    phase#set,constituent#subl   20     constituent fraction
!----- model variables <<<< these now treated differently
    stvix=cmix(2)/10
    stvnorm=mod(cmix(2),10)
    select case(stvix)
    case default
       write(*,*)'not a condition:',stvix,stvnorm,cmix(1),cmix(2),cmix(3)
       gx%bmperr=4208; goto 1000
    case(1:2,5) 
! stvix=1..6: U, S, V, H, A, G, some conditions not implemented
!             1  2  3  4  5  6
       write(*,*)'Not implemented yet: ',stvix,stvnorm
       gx%bmperr=4207; goto 1000
!------------------------------------------------------------------
    case(3) ! V volume condition
       write(*,*)'Not implemented yet: ',stvix,stvnorm
       gx%bmperr=4207; goto 1000
!------------------------------------------------------------------
    case(4) ! Heat balance condition
! Enthalpy for system or phase, normallized or not
!       gx%bmperr=4207; goto 1000
       if(stvnorm.eq.0) then
! not normallized
          if(cmix(3).eq.0) then
! condition is H=value
             sph=0
          else
! condition is H(phase#set)=value, not implemented yet
             gx%bmperr=4207; goto 1000
             sph=cmix(3); scs=cmix(4)
          endif
! dH=\sum_alpha FU(alpha)(dG/y_i-Td2G/dTdy_i)c_iA\mu_A + 
!   (-Td2G/dT2 + \sum_i (dG/dy_i - Td2G/dTdY_i)c_iT)dT + ...
!   +\sum_alpha (G-TdG/dT)\delta FU(alpha) =
!    \sum_alpha FU(alpha)\sum_i(dG/dy_i-Td2G/dTdy_i)c_iG + H-\tilde H
!          write(*,*)'Condition on H: ',pmi%ncc,dncol
          allocate(xcol(nz2))
          xcol=zero
          totam=zero
          notf=0
          check1=zero
          check2=zero
          hallph: do jph=1,meqrec%nstph
! sum over all stable phases
             jj=meqrec%stphl(jph)
             pmi=>phr(jj)
! if phase is not fixed there is a column in xcol for variable amount
! This has to be done before loop of elements
             if(pmi%phasestatus.ne.PHFIXED) notf=notf+1
! moles formula unit of phase
             pham=pmi%curd%amfu
             allocate(hval(pmi%ncc))
! calculate the terms dG/dy_i - T*d2G/dTdy_i for all constituents
             do ie=1,pmi%ncc
                hval(ie)=pmi%curd%dgval(1,ie,1)-&
                     ceq%tpval(1)*pmi%curd%dgval(2,ie,1)
             enddo
!             write(*,75)'hval: ',hval
!             write(*,75)'cmuvamanyl: ',(ceq%cmuval(ie),ie=1,meqrec%nrel)
! calculate the terms to be multiplied with the unknown mu(ie)
             hallel: do ie=1,meqrec%nrel
! multiply terms with the inverse phase matrix and hval
                call calc_dgdytermsh(meqrec%nrel,ie,meqrec%tpindep,hval,&
                     mamu,mag,mat,map,pmi,ceq%cmuval,meqrec%noofits)
                if(gx%bmperr.ne.0) goto 1000
!                write(*,99)'hfix: ',ceq%tpval(1),mag,mat,map,mamu
99              format(a,6(1pe12.4))
                ncol=ie
! calculate a term for each column to be multiplied with chemical potential
! if the potential is fixed add the term to the rhs
                do ke=1,meqrec%nfixmu
                   if(meqrec%mufixel(ke).eq.ie) then
! components with fix chemical potential added to rhs, do not increment ncol!!!
!                      xcol(nz2)=xcol(nz2) - pham*meqrec%mufixval(ke)*mamu(ie)
                      xcol(nz2)=xcol(nz2) + pham*meqrec%mufixval(ke)*mamu(ie)
                   endif
                   cycle hallel
                enddo
! mamu(ie) = \sum_i hval(i) \sum_j \sum_B dM^a_B/dy_j z^a_ij
! sign here may be wrong, should be opposite to that for xcol(nz2) 7 lines up
!                xcol(ncol)=xcol(ncol) + pham*mamu(ie)
                xcol(ncol)=xcol(ncol) - pham*mamu(ie)
                ncol=ncol+1
                check1=check1-pham*mamu(ie)*ceq%cmuval(ie)
!                write(*,76)'check1: ',ie,check1,pham*mamu(ie)*ceq%cmuval(ie)
76              format(a,i3,5(1pe12.4))
             enddo hallel
! hval no longer needed
             deallocate(hval)
! If T or P are variable, mat and map include \sum_j hval(j)
             if(tcol.gt.0) then
                xxx=xcol(tcol)
! gval(2,1) is dG/dT, gval(4,1) is d2G/dT2, sign????
!                xcol(tcol)=xcol(tcol)+pham*(mat-&
!                     ceq%tpval(1)*pmi%curd%gval(4,1))
                xcol(tcol)=xcol(tcol)-pham*(mat-&
                     ceq%tpval(1)*pmi%curd%gval(4,1))
!>>                xcol(tcol)=xcol(tcol)-pham*(mat-&
!                   pmi%curd%gval(2,1) + ceq%tpval(1)*pmi%curd%gval(4,1))
!                write(*,363)'d2G/dTdy H: ',nrow+1,ie,tcol,&
!                     xxx,xcol(tcol),pham,mat
             endif
             if(pcol.gt.0) then
                xxx=xcol(pcol)
! gval(3,1) is dG/dP, gval(5,1) is d2G/dTdP, sign???
                   xcol(pcol)=xcol(pcol)+pham*(map-&
                     pmi%curd%gval(3,1)-ceq%tpval(1)*pmi%curd%gval(5,1))
!>>                xcol(pcol)=xcol(pcol)-pham*(map-&
!                     pmi%curd%gval(3,1)+ceq%tpval(1)*pmi%curd%gval(5,1))
!                write(*,363)'d2G/dPdy: H',nrow+1,ie,pcol,&
!                     xxx,xcol(pcol),pham,mat
             endif
!             enddo hallel
! Sum the total enthalpy
             totam=totam+pham*(pmi%curd%gval(1,1)-&
                  ceq%tpval(1)*pmi%curd%gval(2,1))
!             write(*,74)'pham:  ',jj,pham,totam,ceq%cmuval(1),ceq%cmuval(2)
! Now the term multipled with change of the amount of the phase
             if(pmi%phasestatus.ne.PHFIXED) then
                xcol(dncol+notf)=pmi%curd%gval(1,1)-&
                     ceq%tpval(1)*pmi%curd%gval(2,1)
             endif
! term to the RHS, sign???
!             xcol(nz2)=xcol(nz2)-pham*mag
             xcol(nz2)=xcol(nz2)+pham*mag
!             write(*,76)'Check2: ',jj,pham,mag,pham*mag
!             deallocate(hval)
          enddo hallph
! Add difference to the RHS.  Totam is summed above, cvalue is prescribed value
!          write(*,74)'Enthalpy: ',nrow+1,ceq%tpval(1),ceq%rtn,&
!               xcol(nz2),totam,cvalue/ceq%rtn
          xcol(nz2)=xcol(nz2)+totam-cvalue/ceq%rtn
! test if condition converged, use relative error 
          if(abs(totam-cvalue/ceq%rtn).gt.ceq%xconv*abs(cvalue)) then
             if(vbug) write(*,75)'Unconverged enthalpy: ',ceq%tpval(1),&
                  totam,cvalue/ceq%rtn,totam-cvalue/ceq%rtn
             if(converged.lt.5) converged=5
          endif
! we have one more equation to add to the equilibrium matrix
          nrow=nrow+1
          if(nrow.gt.nz1) stop 'too many equations 7A'
          do ncol=1,nz2
             smat(nrow,ncol)=xcol(ncol)
          enddo
!          write(*,*)'H conv: ',ceq%tpval(1)
!          write(*,74)'hline: ',nrow,xcol
75        format(a,6(1pe12.4))
74        format(a,i2,6(1pe11.3))
! check1 and check2 should be equal if we set H as current value and release T
!          write(*,75)'Check: ',check1,check2
          deallocate(xcol)
! unfinished
! ..........................................................
       else
! normallizing can be M (per mole, 1), W (per mass, 2) or V (per volume, 3)
          gx%bmperr=4207; goto 1000
       endif
!------------------------------------------------------------------
    case(6) ! G
! Gibbs energy, for system or a phase
       gx%bmperr=4207; goto 1000
       if(stvnorm.eq.0) then
! not normallized
          if(cmix(3).eq.0) then
! condition is G=value
             sph=0
          else
! condition is G(phase#set)=value
             gx%bmperr=4207; goto 1000
             sph=cmix(3); scs=cmix(4)
          endif
! current value of dG=\sum_A dM_A \mu_A + G -\tilde G=0
          allocate(xcol(nz2))
          xcol=zero
!...unfinished
          nrow=nrow+1
          if(nrow.gt.nz1) stop 'too many equations 7A'
          do ncol=1,nz2
             smat(nrow,ncol)=xcol(ncol)
          enddo
! set rhs to G^prescribed - G^current 
!          smat(nrow,nz2)=cvalue
          deallocate(xcol)
       else
! normallizing can be M (per mole, 1), W (per mass, 2) or V (per volume, 3?)
          gx%bmperr=4207; goto 1000
       endif
!------------------------------------------------------------------
    case(7) ! NP
! Amount of phase in moles, use fix phase instead
       write(*,352)stvix,stvnorm
352    format('Not implemented yet, use set status phase=fix: ',2i5)
       gx%bmperr=4207; goto 1000
       nrow=nrow+1
       if(nrow.gt.nz1) stop 'too many equations 7A'
!------------------------------------------------------------------
    case(8) ! BP
! Amount of phase in mass, use fix phase instead
       write(*,352)stvix,stvnorm
       gx%bmperr=4207; goto 1000
       nrow=nrow+1
       if(nrow.gt.nz1) stop 'too many equations 8A'
!------------------------------------------------------------------
! 9 and 10 (DG and Q) not allowed as conditions
!------------------------------------------------------------------
    case(11) ! N or X with or without indices and normalization
       if(stvnorm.eq.0) then
          if(cmix(3).eq.0) then
! condition is N=fix
             sel=0; sph=0
          elseif(cmix(4).eq.0) then
! condition is N(A)=fix
             sel=cmix(3); sph=0
          else
! condition is N(phase#set,A)=fix;  how to handle if phase#set not stable?
             write(*,*)'Condition N(phase#set,A)=fix not allowed'
             gx%bmperr=4208; goto 1000
             sel=cmix(5); sph=cmix(3); scs=cmix(4)
          endif
!          write(*,*)'Condition on N, N(A) or N(phase,A)',sph,sel
! Formulate equation for total amount N:
! rhs:  N-N+\sum_alpha N^a + \sum_i \sum_j dM^a_A/dy_i z^a_ij dG/dy_j
! \sum_B \sum_alpha N^a \sum_i \sum_j dM^_A/dy_i dM^a_B/dy_j*z^a_ij  *mu(B)
!        \sum_alpha N^a \sum_i d2M^a_A/dTdy_i z^a_ij d2G/dTdy_j      *deltaT
!        \sum_alpha N^a \sum_i d2M^a_A/dPdy_i z^a_ij d2G/dPdy_j      *deltaP
!        \sum_A M^a_A                                    *deltaN^a
          allocate(xcol(nz2))
          xcol=zero
          totam=zero
!          if(.not.allocated(xxmm)) then
! just for debugging, not needed for N= or N(A)=
! this call returns the current fractions and total amounts.  We need
! to do it only once inside this subroutine. xxmm are deallocated at exit
!             allocate(xxmm(meqrec%nrel))
!             allocate(wwnn(meqrec%nrel))
!             call calc_molmass(xxmm,wwnn,totalmol,totalmass,ceq)
!             if(gx%bmperr.ne.0) goto 1000
!          endif
! notf keeps track on entered non-fixed phases with variable amount
          notf=0
! THE CALCULATION FOR N= and N(A)= seems OK
          nallph: do jph=1,meqrec%nstph
! sum over all stable phases
             jj=meqrec%stphl(jph)
             pmi=>phr(jj)
! if phase is not fixed there is a column in xcol for variable amount
! This has to be done before loop of elements
             if(pmi%phasestatus.ne.PHFIXED) notf=notf+1
! moles formulat unit of phase
             pham=pmi%curd%amfu
             nallel: do ie=1,meqrec%nrel
! if sel=/=0 then skip all components except sel
                if(sel.gt.0 .and. ie.ne.sel) cycle nallel
! multiply terms with the inverse phase matrix
                call calc_dgdyterms1(meqrec%nrel,ie,meqrec%tpindep,&
                     mamu,mag,mat,map,pmi,ceq%cmuval,meqrec%noofits)
                if(gx%bmperr.ne.0) goto 1000
! the call above calculates (A is "ie", z_ij is the inverted phase matrix): 
! mamu_A(B=1..nrel) = \sum_i \sum_j dM^a_A/dy_i dM^a_B/dy_j z^a_ij
! mag_A             = \sum_i \sum_j dM^a_A/dy_i z^a_ij dG/dy_j
! mat_A             = \sum_i \sum_j d2M^a_A/dTdy_i z^a_ij d2G/dTdy_j
! map_A             = \sum_i \sum_j d2M^a_A/dPdy_i z^a_ij d2G/dPdy_j
                ncol=1
! calculate a term for each column to be multiplied with chemical potential
! if the potential is fixed add the term to the rhs
                nloop1: do je=1,meqrec%nrel
                   do ke=1,meqrec%nfixmu
                      if(meqrec%mufixel(ke).eq.je) then
! components with fix chemical potential added to rhs, do not increment ncol!!!
                         xcol(nz2)=xcol(nz2)+pham*mamu(je)*meqrec%mufixval(ke)
                         cycle nloop1
                      endif
                   enddo
! mamu(B) = \sum_i \sum_j \sum_A dM^a_B/dy_i dM^a_A z^a_ij
                   xcol(ncol)=xcol(ncol)-pham*mamu(je)
                   ncol=ncol+1
                enddo nloop1
! If T or P are variable
                if(tcol.gt.0) then
                   xxx=xcol(tcol)
                   xcol(tcol)=xcol(tcol)+pham*mat
!                   write(*,363)'d2G/dTdy 2: ',nrow+1,ie,tcol,&
!                        xxx,xcol(tcol),pham,mat
                endif
                if(pcol.gt.0) then
                   xxx=xcol(pcol)
                   xcol(pcol)=xcol(pcol)+pham*map
!                   write(*,363)'d2G/dPdy: ',nrow+1,ie,pcol,&
!                        xxx,xcol(pcol),pham,mat
                endif
! last columns on lhs are amounts of element ie for all stable non-fix phases
! dncol should indicate last column with potential, can be different for
! derivative, notf is set above
                if(pmi%phasestatus.ne.PHFIXED) then
! notf indicates the column for amount of a component in stable nonfixed phase
! sum of moles in phase will be multiplied with delta-phase_amount
                   if(sel.gt.0 .and. sel.eq.ie) then
                      xcol(dncol+notf)=pmi%xmol(ie)
                   else
                      xcol(dncol+notf)=xcol(dncol+notf)+pmi%xmol(ie)
                   endif
                endif
! Maybe this should be included also for fixed phases ....?? YES
! right hand side (rhs) contribution is
! - NP(phase)*\sum_i \sum_j dM(ie)/dy_i * dG/dy_j * z_ij
                xxx=xcol(nz2)
                xcol(nz2)=xcol(nz2)-pham*mag
             enddo nallel
! this is to used on the RHS for compare with prescribed value
             if(sel.gt.0) then
                totam=totam+pham*pmi%xmol(sel)
             else
                totam=totam+pham*pmi%sumxmol
             endif
! tafidbug
!             write(*,665)xxx,pham,mag,cvalue,totam,&
!                  xxx-pham*mag+cvalue-totam
665          format('RHS: ',6(1pe12.4))
          enddo nallph
!
! in xcol are values summed over all phases and components
! then copy summed columns to row nrow in matrix smat
          nrow=nrow+1
          if(nrow.gt.nz1) then
             write(*,*)'too many equations 11A',nrow
             gx%bmperr=6543; goto 1000
          endif
          do ncol=1,nz2
             smat(nrow,ncol)=xcol(ncol)
          enddo
! add N^prescribed - N^current to rhs (right hand side)
          xxx=smat(nrow,nz2)
! convergence problems using condition fix phase with amount >0, change sign ...
          smat(nrow,nz2)=smat(nrow,nz2)-cvalue+totam
! tafidbug
!          smat(nrow,nz2)=smat(nrow,nz2)+cvalue-totam
!          write(*,363)'RHSN: ',nrow,nz2,0,smat(nrow,nz2),xxx,cvalue,totam,&
!               cvalue-totam
          deallocate(xcol)
! relative check for convergence if cvalue>1.0
          if(abs(totam-cvalue).gt.ceq%xconv*max(1.0d0,abs(cvalue))) then
             if(converged.lt.5) converged=5
             if(vbug) then
                if(sel.eq.0) then
                   write(*,266)'Unconverged condition N or N(A): ',sel,&
                        cvalue,totam,totalmol
                else
! value of xxmm(sel) only reasonable of N=1 or N(A)+.. = 1
                   write(*,266)'Unconverged condition N or N(A): ',sel,&
                        cvalue,totam
                endif
             endif
          endif
!----------------------------------------------------------
       elseif(stvnorm.gt.1) then
! only normallizing of N with respect to amount of moles (M) is allowed
          write(*,*)'N can only be normalled with M',stvix,stvnorm,cmix(2)
          gx%bmperr=4208; goto 1000
       else
!------------------------------------------------------------
! N=fix and N(A)=fix treated above as they have a "simple" summation, 
! Now handle all other cases like x(A)=fix, x(phase#set,A)=fix
! We must sum over all phases and constituents for the normallizing factor
! definition: X(A)=N(A)/N; 
! derivative: dX(A)=dN(A)/N - N(A)/N**2 *dN
! sum dN(A) and dN at the same time and multiply the sums with 1/N 
! and -N(A)/N**2 in the end.
          if(cmix(3).eq.0) then
             write(*,*)'Condition NM=fix is illegal'
             gx%bmperr=4208; goto 1000
          elseif(cmix(4).eq.0) then
! condition is x(A)=fix
             sel=cmix(3); sph=0
          else
! condition is x(phase#set,A)=fix
!             write(*,*)'Condition x(phase#set,A)=fix not yet allowed'
!             gx%bmperr=9898; goto 1000
             sel=cmix(5); sph=cmix(3); scs=cmix(4)
          endif
          if(.not.allocated(xxmm)) then
! this call returns the current fractions and total amounts.  We need
! to do it only once inside this subroutine. xxmm are deallocated at exit
             allocate(xxmm(meqrec%nrel))
             allocate(wwnn(meqrec%nrel))
             call calc_molmass(xxmm,wwnn,totalmol,totalmass,ceq)
             if(gx%bmperr.ne.0) goto 1000
          endif
! two summations, zcol sums the term dN(A); xcol sums dN (as above)
          allocate(xcol(nz2))
          allocate(zcol(nz2))
          xcol=zero
          zcol=zero
          totam=zero
          zval=zero
          xval=zero
! LOOP FOR ALL PHASES (why not all stable??)
! dncol+notf indicate column for the amount of phases with variable amount
          notf=0
!          xallph: do jph=1,meqrec%nstph
!             jj=meqrec%stphl(jph)
! sum over all phases to handle conditions like x(phase#set,A)=fix
! as the phase#set may not be stable
          xallph: do jj=1,meqrec%nphase
             if(sph.eq.0) then
! skip this phase if not stable and condition not on a specific phase (sph)
! WOW COMPLICATION, I have another test for stability ... suck
                if(phr(jj)%stable.eq.0) cycle xallph
             else
! condition on specific phase, skip this phase if not the right one
                if(phr(jj)%iph.ne.sph .or. &
                     phr(jj)%ics.ne.scs) cycle xallph
             endif
             pmi=>phr(jj)
! notf indicates the column for the variable amount of the phase
             if(pmi%phasestatus.ne.PHFIXED) notf=notf+1
             pham=pmi%curd%amfu
             xallel: do ie=1,meqrec%nrel
! we cannot skip summation over all element as that is needed for normallizing
! calculate a term for each column to be multiplied with chemical potential
! we must sum xcol for all elemenets and add to zcol for element sel
! if sel=/=0 then we sum also zcol(sel) for all phases
                call calc_dgdyterms1(meqrec%nrel,ie,meqrec%tpindep,&
                     mamu,mag,mat,map,pmi,ceq%cmuval,meqrec%noofits)
                if(gx%bmperr.ne.0) goto 1000
                ncol=1
                xloop2: do je=1,meqrec%nrel
! Calculate one column for each component to be multiplied with chem.pot.
! components with fix chemical potential added to rhs, do not increment ncol!!!
                   do ke=1,meqrec%nfixmu
! check for elements with fixed chemical potentials, they go to RHS
                      if(meqrec%mufixel(ke).eq.je) then
                         xcol(nz2)=xcol(nz2)+pham*mamu(je)*meqrec%mufixval(ke)
                         if(sel.eq.je) then
! negative sign as it is on the RHS
                            zcol(nz2)=zcol(nz2)-&
                                 pham*mamu(je)*meqrec%mufixval(ke)
                         endif
                         cycle xloop2
                      endif
                   enddo
! mamu(B) = \sum_i \sum_j dM^a_B/dy_i dM^a_A z^a_ij
! sum over all elements for normallizing
                   xcol(ncol)=xcol(ncol)-pham*mamu(je)
                   if(sel.eq.ie) then
! if this is the specified element sum to zcol
                      zcol(ncol)=zcol(ncol)-pham*mamu(je)
                   endif
                   ncol=ncol+1
                enddo xloop2
! If T or P are variable, mat is \sum_i d2G/dy_idT, map is \sum_i d2G/dy_idP
                if(tcol.gt.0) then
                   xcol(tcol)=xcol(tcol)+pham*mat
                   if(sel.eq.ie) then
                      zcol(tcol)=zcol(tcol)+pham*mat
                   endif
!                   write(*,363)'d2G/dTdy 3: ',nrow+1,ie,tcol,&
!                        xxx,xcol(tcol),pham,mat
363                format(a,3i3,6(1pe12.4))
                endif
                if(pcol.gt.0) then
                   xcol(pcol)=xcol(pcol)+pham*map
                   if(sel.eq.ie) then
                      zcol(pcol)=zcol(pcol)+pham*map
                   endif
                endif
                if(pmi%phasestatus.ne.PHFIXED) then
                   xcol(dncol+notf)=xcol(dncol+notf)+pmi%xmol(ie)
                   if(ie.eq.sel) then
                      zcol(dncol+notf)=zcol(dncol+notf)+pmi%xmol(ie)
                   endif
                endif
! right hand side (rhs) contribution is (normallized below)
! - NP(phase)*\sum_i \sum_j dM(ie)/dy_i * dG/dy_j * z_ij 
                xcol(nz2)=xcol(nz2)-pham*mag
                if(sel.eq.ie) then
                   zcol(nz2)=zcol(nz2)-pham*mag
                endif
             enddo xallel
             totam=totam+pham*pmi%sumxmol
! UNFINISHED: if sph=/=0 next line must be changed and just be for sph
             zval=zval+pham*pmi%xmol(sel)
          enddo xallph
! in xcol is dN and in zcol dN(A) summed over all phases and components
! calculate the normallized values now
! xmat=dN(A)/N - N(A)*dN/N**2
          nrow=nrow+1
          if(nrow.gt.nz1) then
             write(*,*)'too many equations 11B: ',nrow,nz1,meqrec%nfixph
             gx%bmperr=4209; goto 1000
          endif
! sum zcol and xcol to nrow in smat multiplying xcol with current amount
! and normallizing with total amount, including the RHS (column nz2)
          do ncol=1,nz2
             smat(nrow,ncol)=(zcol(ncol)-xcol(ncol)*xxmm(sel))/totalmol
          enddo
! add N^prescribed - N^current to rhs (right hand side)
          smat(nrow,nz2)=smat(nrow,nz2)-cvalue+xxmm(sel)
          deallocate(xcol)
          deallocate(zcol)
! check on convergence
          if(abs(xxmm(sel)-cvalue).gt.ceq%xconv) then
             if(converged.lt.5) converged=5
             if(vbug) write(*,266)'Unconverged condition x(A): ',sel,&
                  cvalue,xxmm(sel)
          endif
       endif
!
!------------------------------------------------------------------
    case(12) ! B or W
! Amount of component in mass, can have indices and normallization
! code copied from the case(11) for N and X and modified for mass
       if(stvnorm.eq.0) then
          if(cmix(3).eq.0) then
! condition is B=fix
             sel=0; sph=0
          elseif(cmix(4).eq.0) then
! condition is B(A)=fix
             sel=cmix(3); sph=0
          else
! condition is B(phase#set,A)=fix;  how to handle if phase#set not stable?
!             write(*,*)'Condition B(phase#set,A)=fix not allowed'
             gx%bmperr=4208; goto 1000
             sel=cmix(5); sph=cmix(3); scs=cmix(4)
          endif
! Formulate equation for total amount B: each M_A multiplied with mass_A
! rhs:  B-B+\sum_alpha N^a + \sum_i \sum_j dM^a_A/dy_i z^a_ij dG/dy_j 
! \sum_B \sum_alpha N^a \sum_i \sum_j dM^_A/dy_i dM^a_B/dy_j*z^a_ij  *mu(B)
!        \sum_alpha N^a \sum_i d2M^a_A/dTdy_i z^a_ij d2G/dTdy_j      *deltaT
!        \sum_alpha N^a \sum_i d2M^a_A/dPdy_i z^a_ij d2G/dPdy_j      *deltaP
!        \sum_A M^a_A                                    *deltaN^a
          allocate(xcol(nz2))
          xcol=zero
          totam=zero
! notf keeps track on entered non-fixed phases with variable amount
          notf=0
! not used          zval=zero
          ballph: do jph=1,meqrec%nstph
! sum over all stable phases
             jj=meqrec%stphl(jph)
             pmi=>phr(jj)
! if phase is not fixed there is a column in xcol for variable amount
             if(pmi%phasestatus.ne.PHFIXED) notf=notf+1
! amount of phase, amfu is moles formula units, abnorm(2) is mass per form.un
             pham=pmi%curd%amfu
             ballel: do ie=1,meqrec%nrel
! if sel=/=0 then skip all components except sel
                if(sel.gt.0 .and. ie.ne.sel) cycle
! multiply terms with the inverse phase matrix
                call calc_dgdyterms1(meqrec%nrel,ie,meqrec%tpindep,&
                     mamu,mag,mat,map,pmi,ceq%cmuval,meqrec%noofits)
                if(gx%bmperr.ne.0) goto 1000
!                write(*,*)'Calculated dgdyterms 3: ',mat
! the call above calculates (A is "ie", z_ij is the inverted phase matrix): 
! mamu_A(B=1..nrel) = \sum_i \sum_j dM^a_A/dy_i dM^a_B/dy_j z^a_ij
! mag_A             = \sum_i \sum_j dM^a_A/dy_i z^a_ij dG/dy_j
! mat_A             = \sum_i \sum_j d2M^a_A/dTdy_i z^a_ij d2G/dTdy_j
! map_A             = \sum_i \sum_j d2M^a_A/dPdy_i z^a_ij d2G/dPdy_j
                ncol=1
! calculate a term for each column to be multiplied with chemical potential
! if the potential is fixed add the term to the rhs
                bloop1: do je=1,meqrec%nrel
                   do ke=1,meqrec%nfixmu
                      if(meqrec%mufixel(ke).eq.je) then
! components with fix chemical potential added to rhs, do not increment ncol!!!
! NOTE: mamu includes summation of two components, multiply with two masses!!!
                         xcol(nz2)=xcol(nz2)+&
                              pham*mamu(je)*meqrec%mufixval(ke)*mass_of(ie,ceq)
                         cycle bloop1
                      endif
                   enddo
! mamu(B) = \sum_i \sum_j \sum_A dM^a_B/dy_i dM^a_A z^a_ij mass_A mass_B
                   xcol(ncol)=xcol(ncol)-pham*mamu(je)*mass_of(ie,ceq)
!                   write(*,363)'xcola: ',ncol,ie,je,xcol(ncol),pham,mamu(je),&
!                        mass_of(ie,ceq)
                   ncol=ncol+1
                enddo bloop1
! If T or P are variable
                if(tcol.gt.0) then
!                   xxx=xcol(tcol)
                   xcol(tcol)=xcol(tcol)+pham*mat*mass_of(ie,ceq)
!                   write(*,363)'d2G/dTdy 4: ',nrow-1,ie,tcol,&
!                        xxx,xcol(tcol),pham,mat
                endif
                if(pcol.gt.0) then
!                   xxx=xcol(pcol)
                   xcol(pcol)=xcol(pcol)+pham*map*mass_of(ie,ceq)
!                   write(*,363)'d2G/dPdy: ',nrow-1,ie,pcol,&
!                        xxx,xcol(pcol),pham,mat
                endif
! last columns are amounts of element ie for all stable non-fix phases
! for all stable (non fixed) phases we have the mass multiplied with deltaaleph
                if(pmi%phasestatus.ne.PHFIXED) then
! ??                    zval=zval+pmi%xmol(ie)*mass_of(ie,ceq)
                   if(sel.gt.0 .and. sel.eq.ie) then
                      xcol(dncol+notf)=&
                           pmi%xmol(ie)*mass_of(ie,ceq)
!                     write(*,363)'xcola: ',ncol,ie,0,xcol(ncol),mass_of(ie,ceq)
                   else
                      xcol(dncol+notf)=xcol(dncol+notf)+&
                           pham*pmi%xmol(ie)*mass_of(ie,ceq)
                   endif
                endif
! right hand side (rhs) contribution is
! - BP(phase)*\sum_i \sum_j dM(ie)/dy_i * dG/dy_j * z_ij
                xcol(nz2)=xcol(nz2)-pham*mag*mass_of(ie,ceq)
             enddo ballel
! sum of mass in phase will be multiplied with delta-phase_amount
!             write(*,202)'sumxmol mm:  ',sel,pham,pmi%sumxmol,pmi%sumwmol
             if(sel.gt.0) then
                totam=totam+pham*pmi%xmol(sel)*mass_of(sel,ceq)
             else
                totam=totam+pham*pmi%sumwmol
             endif
          enddo ballph
!......debug
          if(.not.allocated(xxmm)) then
! this call returns the current fractions and total amounts.  We need
! to do it only once inside this subroutine. xxmm are deallocated at exit
             allocate(xxmm(meqrec%nrel))
             allocate(wwnn(meqrec%nrel))
             call calc_molmass(xxmm,wwnn,totalmol,totalmass,ceq)
             if(gx%bmperr.ne.0) goto 1000
          endif
!          if(sel.eq.0) write(*,*)'totalmass: ',totalmass,totam
!
! in xcol are values summed over all phases and components
! copy summed columns to smat nrow
          nrow=nrow+1
          if(nrow.gt.nz1) then
             write(*,*)'too many equations 12A',nrow
             gx%bmperr=4209; goto 1000
          endif
          do ncol=1,nz2
             smat(nrow,ncol)=xcol(ncol)
          enddo
! add B^prescribed - B^current to rhs (right hand side)
          xxx=smat(nrow,nz2)
          smat(nrow,nz2)=smat(nrow,nz2)-cvalue+totam
!          write(*,363)'RHSB: ',nrow,nz2,0,smat(nrow,nz2),xxx,cvalue,totam,&
!               cvalue-totam
          deallocate(xcol)
! check convergence
          if(abs(totam-cvalue).gt.ceq%xconv) then
!            write(*,266)'Unconverged condition B(A): ',sel,&
!                  cvalue,zval
             if(converged.lt.5) converged=5
          endif
          if(vbug) then
             if(sel.eq.0) then
                write(*,363)'Condition B=fix',0,0,0,cvalue,totam
             else
                write(*,363)'Condition B(a)=fix',sel,0,0,cvalue,totam
             endif
          endif
       elseif(stvnorm.ne.2) then
! only normallizing of B with respect to mass (W) is allowed
          write(*,*)'Allowed normallizing with W only',stvix,stvnorm,cmix(2)
          gx%bmperr=4208; goto 1000
       else
!-------------------------------
! B=fix and B(A)=fix treated above as they have a "simple" summation, 
! Now handle all other cases like w(A)=fix, w(phase#set,A)=fix
! We must sum over all phases and constituents for the normallizing factor
! definition: W(A)=B(A)/B; 
! derivative: dW(A)=dB(A)/B - B(A)/N**2 *dB
! sum dB(A) and dB at the same time and multiply the sums with 1/B
! and -B(A)/B**2 in the end.
          if(cmix(3).eq.0) then
             write(*,*)'Condition BW=fix is illegal'
             gx%bmperr=4208; goto 1000
          elseif(cmix(4).eq.0) then
! condition is x(A)=fix
             sel=cmix(3); sph=0
          else
! condition is w(phase#set,A)=fix;  how to handle if phase#set not stable?
!             write(*,*)'Condition w(phase#set,A)=fix not yet allowed'
!             gx%bmperr=9898; goto 1000
             sel=cmix(5); sph=cmix(3); scs=cmix(4)
          endif
          if(.not.allocated(xxmm)) then
! this call returns the current fractions and total amounts.  We need
! to do it only once inside this subroutine. xxmm are deallocated at exit
             allocate(xxmm(meqrec%nrel))
             allocate(wwnn(meqrec%nrel))
             call calc_molmass(xxmm,wwnn,totalmol,totalmass,ceq)
             if(gx%bmperr.ne.0) goto 1000
          endif
!          write(*,267)'wwnn: ',(wwnn(ncol),ncol=1,noel())
!          write(*,267)'xxmm: ',(xxmm(ncol),ncol=1,noel())
! two summations, zcol sums the term dN(A); xcol sums dN (as above)
          allocate(xcol(nz2))
          allocate(zcol(nz2))
          xcol=zero
          zcol=zero
          totam=zero
          zval=zero
          xval=zero
          notf=0
!          wallph: do jph=1,meqrec%nstph
!             jj=meqrec%stphl(jph)
! sum over all phases to handle conditions like x(phase#set,A)=fix
! as the phase#set may not be stable
          wallph: do jj=1,meqrec%nphase
             if(sph.eq.0) then
! skip this phase if not stable and condition not on a specific phase
                if(phr(jj)%stable.eq.0) cycle wallph
             elseif(sph.gt.0) then
                if(phr(jj)%iph.ne.sph .or. &
                     phr(jj)%ics.ne.scs) cycle wallph
             endif
             pmi=>phr(jj)
! amount formula units of phase
             pham=pmi%curd%amfu
             if(pmi%phasestatus.ne.PHFIXED) notf=notf+1
!             pham=pmi%curd%abnorm(2)
             wallel: do ie=1,meqrec%nrel
! calculate a term for each column to be multiplied with chemical potential
! we must sum xcol for all elemenets and add to zcol for element sel
! if sel=/=0 then we sum also zcol(sel) for all phases
                call calc_dgdyterms1(meqrec%nrel,ie,meqrec%tpindep,&
                     mamu,mag,mat,map,pmi,ceq%cmuval,meqrec%noofits)
                if(gx%bmperr.ne.0) goto 1000
!                write(*,*)'Calculated dgdyterms 4: ',mat
                ncol=1
                wloop2: do je=1,meqrec%nrel
! Calculate one column for each component to be multiplied with chem.pot.
! components with fix chemical potential added to rhs, do not increment ncol!!!
                   do ke=1,meqrec%nfixmu
                      if(meqrec%mufixel(ke).eq.je) then
                         xcol(nz2)=xcol(nz2)+&
                              pham*mamu(je)*meqrec%mufixval(ke)*mass_of(je,ceq)
                         if(sel.eq.je) then
! negative sign as it is on the RHS
                            zcol(nz2)=zcol(nz2)-&
                                 pham*mamu(je)*meqrec%mufixval(ke)*&
                                 mass_of(je,ceq)
                         endif
                         cycle wloop2
                      endif
                   enddo
! mamu(B) = \sum_i \sum_j dM^a_B/dy_i dM^a_A z^a_ij
                   xcol(ncol)=xcol(ncol)-pham*mamu(je)*mass_of(ie,ceq)
                   if(sel.eq.ie) then
                      zcol(ncol)=zcol(ncol)-pham*mamu(je)*mass_of(ie,ceq)
                   endif
                   ncol=ncol+1
                enddo wloop2
! If T or P are variable
                if(tcol.gt.0) then
                   xcol(tcol)=xcol(tcol)+pham*mat*mass_of(ie,ceq)
                   if(sel.eq.ie) then
                      zcol(tcol)=zcol(tcol)+pham*mat*mass_of(ie,ceq)
                   endif
!                   write(*,363)'d2G/dTdy 5: ',nrow-1,ie,tcol,&
!                        xxx,xcol(tcol),pham,mat
                endif
                if(pcol.gt.0) then
                   xcol(pcol)=xcol(pcol)+pham*map*mass_of(ie,ceq)
                   if(sel.eq.ie) then
                      zcol(pcol)=zcol(pcol)+pham*map*mass_of(ie,ceq)
                   endif
                endif
! last columns are amounts of element ie for all stable non-fix phase,
                if(pmi%phasestatus.ne.PHFIXED) then
! all phases with variable amount, sum over all components
                   xcol(dncol+notf)=xcol(dncol+notf)+&
                        pmi%xmol(ie)*mass_of(ie,ceq)
                   if(ie.eq.sel) then
                      zcol(dncol+notf)=zcol(dncol+notf)+&
                           pmi%xmol(ie)*mass_of(ie,ceq)
                   endif
                endif
! right hand side (rhs) contribution is
! - NP(phase)*\sum_i \sum_j dM(ie)/dy_i * dG/dy_j * z_ij * mass_ie
                xcol(nz2)=xcol(nz2)-pham*mag*mass_of(ie,ceq)
                if(sel.eq.ie) then
                   zcol(nz2)=zcol(nz2)-pham*mag*mass_of(ie,ceq)
                endif
             enddo wallel
             totam=totam+pham*pmi%sumwmol
! UNFINISHED: if sph=/=0 next line must be changed
!             zval=zval+pham*pmi%xmol(sel)*mass_of(sel,ceq)
          enddo wallph
! in xcol is dB and in zcol dB(A) summed over all phases and components
! calculate the normallized values now
! xmat=dB(A)/B - B(A)*dB/B**2
          nrow=nrow+1
          if(nrow.gt.nz1) then
             write(*,*)'too many equations 12B',nrow,nz1
             gx%bmperr=4209; goto 1000
          endif
! copy to smat row nrow
          do ncol=1,nz2
             smat(nrow,ncol)=(zcol(ncol)-xcol(ncol)*wwnn(sel))/totalmass
          enddo
! add W^prescribed - W^current to rhs (right hand side)
          smat(nrow,nz2)=smat(nrow,nz2)-cvalue+wwnn(sel)
          deallocate(xcol)
          deallocate(zcol)
! check on convergence
!          write(*,266)'massbalance condition w(A): ',sel,cvalue,wwnn(sel)
          if(abs(wwnn(sel)-cvalue).gt.ceq%xconv) then
             if(converged.lt.5) converged=5
!             write(*,266)'Unconverged condition w(A): ',sel,cvalue,wwnn(sel)
266          format(a,i3,3(1pe14.6))
!             write(*,267)'wwnn: ',(wwnn(ncol),ncol=1,noel())
!             write(*,267)'xxmm: ',(xxmm(ncol),ncol=1,noel())
!267          format(a,8F9.5)
          endif
!          if(sph.eq.0) then
!             write(*,363)'Condition w(A)=fix',sel,0,0,cvalue,wwnn(sel)
!          else
! this is not implemented yet
!             write(*,363)'Condition w(phase#set,A)=fix',sph,sel,0,cvalue,zval
!          endif
       endif
!
!------------------------------------------------------------------
    case(13) ! Y
! Constituent fraction: phase#set, (subl.,) constituent index (over all subl)
       write(*,*)'Not implemented yet: ',stvix,stvnorm,cmix(2),cmix(3),cmix(4)
       gx%bmperr=4207; goto 1000
       nrow=nrow+1
       if(nrow.gt.nz1) stop 'too many equations 13A'
    end select
!
! loop if not the last condition
!    write(*,*)'Taking next condition',cmix(1)
    if(.not.associated(condition,lastcond)) goto 350
!=====================================================================
380 continue
! write smat
!    do jz=1,nz1
!       write(*,390)jz,(smat(jz,kjj),kjj=1,nz2)
!    enddo
!390 format('#:',i2,6(1pe12.4),6(4x,1pe12.4))
1000 continue
    return
  end subroutine setup_equilmatrix

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine meq_onephase(meqrec,pmi,ceq)
! this subroutine calculates new constituent fractions for a phase iph+ics
! with given T, P and chemical potentials for the components 
! For ionic liquids the sites on the sublattices varies with composition
! THIS IS A FIRST VERSION WITHOUT ANY TRICKS FOR SPEED
    implicit none
    TYPE(meq_phase), pointer :: pmi
    TYPE(gtp_equilibrium_data), pointer :: ceq
    TYPE(meq_setup) :: meqrec
!\end{verbatim}
    integer nrel,i2sly(2)
    integer ik,iph,ics,jz,iz,jk,ierr,kk,kkk,ll,lokcs,ncc,loksp,ncl
    integer nd1,nd2,neq,nochange,nsl,nspel,nv,ncon,icon
! needed for call to get_phase_data
    integer, dimension(maxsubl) ::  nkl
    integer, dimension(maxconst) :: knr
    double precision, dimension(5) :: qq
    double precision, dimension(maxsubl) :: sites
! needed for call to get_species_data
    integer, dimension(maxspel) :: ielno
    double precision, dimension(maxspel) :: stoi
! minimal y, charge
    double precision, parameter :: ymin=1.0D-12,ymingas=1.0D-30,qeps=1.0D-30
! derivative of moles of component wrt y_ks
    double precision, dimension(maxel) :: addmol
! for mass balance and charge
    double precision, dimension(maxconst) :: yarr,dqsum
! phase matrix, its inverse is returned as part of pmi
    double precision, dimension(:,:), allocatable :: pmat
    double precision qsp,sumsit,ykvot,ysum,qsum,spmass,yva,fion
    double precision, dimension(:,:), allocatable :: sumion
!
!    write(*,*)'in meq_onephase: '
    iph=pmi%iph
    ics=pmi%ics
    nrel=meqrec%nrel
! extract phase structure
!    write(*,*)'calling get_phase_data: ',iph
    call get_phase_data(iph,ics,nsl,nkl,knr,yarr,sites,qq,ceq)
    if(gx%bmperr.ne.0) then
       write(*,*)'get_phase_data error in meq_onephase',iph,ics,gx%bmperr
       goto 1000
    endif
! make sure all fractions >ymin and sums in all sublattices are equal to unity
    nochange=0
    ncc=0
    do ll=1,nsl
       ysum=zero
       ncl=ncc
       do ik=1,nkl(ll)
          ncc=ncc+1
          if(yarr(ncc).lt.ymin) then
             if(test_phase_status_bit(iph,PHGAS)) then
                if(yarr(ncc).lt.ymingas) then
                   yarr(ncc)=ymingas
                   nochange=1
                endif
             else
                nochange=1
                yarr(ncc)=ymin
             endif
          endif
          ysum=ysum+yarr(ncc)
       enddo
       ykvot=one/ysum
       if(abs(ykvot-one).gt.ymingas) then
          nochange=1
          do ik=1,nkl(ll)
             yarr(ncl+ik)=yarr(ncl+ik)*ykvot
          enddo
       endif
    enddo
    if(nochange.ne.0) then
! if constitution changed save it. qq will be updated automatically
!       write(*,*)'mm Calling set_constitution'
       call set_constitution(iph,ics,yarr,qq,ceq)
       if(gx%bmperr.ne.0) then
          write(*,*)'never never error 17'
          goto 1000
       endif
    endif
    if(test_phase_status_bit(iph,PHEXCB)) then
! If external charge balance phase matrix has one more line+column
       pmi%chargebal=1
       nd1=ncc+1
!       pmi%charge=qq(2)
       pmi%curd%netcharge=qq(2)
!       write(*,*)'Calculated qq(2): ',iph,ics,qq(2)
    else
       pmi%chargebal=0
       nd1=ncc
!       pmi%charge=zero
       pmi%curd%netcharge=zero
    endif
!--------------------------
! sublattice rows, nd2=nd1+1 because I use Lukas matrix inverter
    nd1=nd1+nsl
    nd2=nd1+1
! Allocate phase matrix, one extra dimension if external charge balance
! last column of pmat is left hand side ?? (reminicent from Lukas program)
    allocate(pmat(nd1,nd2))
! return dimension of pmi%invmat
    if(pmi%idim.eq.0) then
       pmi%idim=nd1
       pmi%ncc=ncc
       allocate(pmi%invmat(nd1,nd1))
       pmi%invmat=zero
!       write(*,*)'Allocated invmat: ',nd1,ncc
! meqrec is not available in this routine but meqrec%nrel passed in call
       allocate(pmi%xmol(nrel))
       allocate(pmi%dxmol(nrel,ncc))
!       write(*,*)'Allocated phase matrix: ',nd2,noel(),ncc
    endif
! value of RT
    ceq%rtn=globaldata%rgas*ceq%tpval(1)
!--------------------------------------------------
! now treat different phase types
    call get_phase_variance(iph,nv)
    if(nv.eq.0) then
!------------------------------------- stoichiometric phase, fixed composition
! For stoichiometric phases calculate just G with T and P derivatives
! and driving force.  All pmi%dxmol=zero but one must also calculate 
! pmi%xmol and save it for all future iterations
! It must also be saved in curd%abnorm(1) ?? done in set_constitution ??
       if(pmi%xdone.eq.1) goto 90
! we must call set_constitution once to have correct abnorm etc
       call set_constitution(iph,ics,yarr,qq,ceq)
       pmi%xmol=zero
       pmi%dxmol=zero
       pmi%sumxmol=zero
       pmi%sumwmol=zero
       sumsit=zero
       do ll=1,nsl
          sumsit=sumsit+sites(ll)
       enddo
       kkk=0
       sublatt: do ll=1,nsl
          allconst: do ik=1,nkl(ll)
             kkk=kkk+1
             loksp=knr(kkk)
             call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
             if(gx%bmperr.ne.0) goto 1000
             addmol=zero
             do jz=1,nspel
                addmol(jz)=stoi(jz)
             enddo
             dqsum(kkk)=qsp
             qsum=qsum+qsp
             do jz=1,nspel
                if(ielno(jz).gt.0) then
! ignore vacancies, taken care of by using sumsit=qq(1) above
                   pmi%dxmol(ielno(jz),kkk)=zero
                   pmi%xmol(ielno(jz))=pmi%xmol(ielno(jz))+&
                        sites(ll)*addmol(jz)
                endif
             enddo
          enddo allconst
       enddo sublatt
! meqrec is not available in this routine
       do iz=1,nrel
          pmi%sumxmol=pmi%sumxmol+pmi%xmol(iz)
          pmi%sumwmol=pmi%sumwmol+pmi%xmol(iz)*mass_of(iz,ceq)
       enddo
! phase_varres(lokcs)%abnorm already set by set_constitution
       pmi%xdone=1
!
90     continue
       call calcg(iph,ics,2,lokcs,ceq)
       if (gx%bmperr.ne.0) then
          write(*,*),'calcg error in meq_onephase ',iph,gx%bmperr
          goto 1000
       endif
! set the inverted phase matrix to zero !!!
       pmi%invmat=zero
!       do ik=1,ncc
!          pmi%invmat(ik,ik)=one
!       enddo
! maybe some common ending
       goto 900
    endif
!--------------------------------------------- zero some arrays, ideal phase
    pmi%xmol=zero
    pmi%dxmol=zero
    pmi%sumxmol=zero
    pmi%sumwmol=zero
    pmi%xdone=-1
!    if(phase_model(iph,ics,PHID,ceq)) then
!    if(test_phase_status_bit(iph,PHID,ceq)) then
    if(test_phase_status_bit(iph,PHID)) then
!--------------------------------------------- ideal phase (subst, no excess)
!       write(*,*)'Phase is ideal'
! special treatment of ideal phase (gas), sites assumed to be unity
! 1. Calculate M_i and dM_i/dy^s_k and the net charge charge Q and dQ/dy^s_k
       pmi%xmol=zero
       pmi%dxmol=zero
       qsum=zero
       dqsum=zero
       ncon=0
       do ik=1,nkl(1)
          loksp=knr(ik)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
          if(gx%bmperr.ne.0) goto 1000
          addmol=zero
          do jk=1,nspel
             addmol(jk)=stoi(jk)
          enddo
          dqsum(ik)=qsp
          qsum=qsum+qsp*yarr(ik)
! It seems dxmol(element,constituent) is equal to the stoichiometry
! i.e. for a molecule H2O dM_H/dy_H2O=2; dM_O/dy_H2O=1, not 2/3 and 1/3
          do jk=1,nspel
             pmi%dxmol(ielno(jk),ik)=addmol(jk)
             pmi%xmol(ielno(jk))=pmi%xmol(ielno(jk))+addmol(jk)*yarr(ik)
          enddo
          ncon=ncon+1
       enddo
! meqrec is not available in this routine
       do ik=1,nrel
          pmi%sumxmol=pmi%sumxmol+pmi%xmol(ik)
!          write(*,*)'sumwmol 2: ',pmi%xmol(ik),mass_of(ik,ceq)
          pmi%sumwmol=pmi%sumwmol+pmi%xmol(ik)*mass_of(ik,ceq)
       enddo
! now calculate G and all 1st and 2nd derivatives
! This can be speeded up as all 2nd derivatives of constituents are RT/y
! The calculated values are used also in other parts of the code 
      call calcg(iph,ics,2,lokcs,ceq)
       if(gx%bmperr.ne.0) then
          write(*,*)'Error calculating ideal gas',gx%bmperr,iph,ics
          goto 1000
       endif
! calculate phase matrix elements
! temporarely ignore that the phase matrix is symmetric
! ceq%phase_varres(lokcs)%...
! gval(1:6,1) are G, G.T, G.P, G.T.T, G.T.P, G.P.P
! dgval(1,1:N,1) are first derivatives of G wrt constituent 1:N
! dgval(2,1:N,1) are second derivatives of G wrt constituent 1:N and T
! dgval(3,1:N,1) are second derivatives of G wrt constituent 1:N and P
! d2gval(ixsym(N*(N+1)/2),1) are 2nd derivatives of G wrt constituents N and M
! Last index is other properties than G like TC, BMAGN etc.
       pmat=zero
       do ik=1,nkl(1)
          do jk=ik,nkl(1)
             pmat(ik,jk)=ceq%phase_varres(lokcs)%d2gval(ixsym(ik,jk),1)
             if(jk.gt.ik) pmat(jk,ik)=pmat(ik,jk)
          enddo
       enddo
       neq=nkl(1)
!       write(*,770)(yarr(ik),ik=1,nkl(1))
!770    format('yfrac: ',4(1pe16.8))
! add one column and row for each sublattice (here only one)
       neq=neq+1
       do jk=1,neq-1
          pmat(jk,neq)=one
          pmat(neq,jk)=one
       enddo
       if(pmi%chargebal.eq.1) then
! if external charge balance add one column and one row
          neq=neq+1
          do jk=1,nkl(1)
! this is the row
             pmat(jk,neq)=dqsum(jk)
! this is the column
             pmat(neq,jk)=dqsum(jk)
          enddo
       endif
! invert the phase matrix (faster routine should be used) IDEAL PHASE
       call mdinv(nd1,nd2,pmat,pmi%invmat,neq,ierr)
       if(ierr.eq.0) then
          write(*,*)'Phase matrix singular 1:',pmi%iph,pmi%ics,pmi%ncc,ierr
          do jk=1,neq
             write(*,73)(pmat(ik,jk),ik=1,neq)
          enddo
73        format(1x,6(1pe12.4))
          gx%bmperr=4205; goto 1000
       endif
!       do jk=1,neq
!          write(*,18)'im: ',(pmi%invmat(ik,jk),ik=1,neq)
!       enddo
!       pmi%invmat=zero
! maybe some common ending
       goto 900
    endif
!---------------------------------------------- no analythical 2nd derivatives
! phases with models with no analythical second derivatives ....
!    if(phase_model(iph,ics,PHNODGDY2,ceq)) then
!    if(test_phase_status_bit(iph,PHNODGDY2,ceq)) then
    if(test_phase_status_bit(iph,PHNODGDY2)) then
!       write(*,*)'Models without 2nd derivatives not implemented'
       gx%bmperr=4206; goto 1000
    endif
!----------------------------------------------- ionic liquid phase
    ionliq: if(test_phase_status_bit(iph,PHIONLIQ)) then
!       write(*,*)'Warning; ionic liquid model not fully implemented'
! Calculate M_A and dM_A/dy_i taking into account that P and Q varies 
!   call get_phase_data(iph,ics,nsl,nkl,knr,yarr,sites,qq,ceq)
       pmi%ionliq=nkl(1)
       pmi%xmol=zero
       pmi%dxmol=zero
       qsum=zero
       dqsum=zero
       pmi%sumxmol=zero
       pmi%sumwmol=zero
       allocate(sumion(nrel,2))
!       pmi%sumiliq=zero
! end extra
       ncon=0
       sumion=zero
       yva=zero
!       write(*,217)'y:  ',ncc,(yarr(ik),ik=1,ncc)
       i2sly=nkl(1)+nkl(2)+1
       do ll=1,nsl
          do ik=1,nkl(ll)
             ncon=ncon+1
             loksp=knr(ncon)
!             pmi%ikon(ncon)=loksp
! if only neutrals we can have a single wildcard in first sublattice ...
             if(loksp.lt.0) then
                if(ll.eq.1 .and. nkl(1).eq.1) cycle
                write(*,*)'Illegal wildcard constituent in ionic liquid'
                gx%bmperr=7777; goto 1000
             endif
             if(btest(pmi%curd%constat(ncon),CONVA)) then
! This is the nypothetical vacancy .... its charge is sites(2) = Q
                yva=yarr(ncon)
! save its index in isly(1), otherwise that is number of constit+1
                i2sly(1)=ncon
!                pmi%valency(ncon)=sites(2)
!                write(*,*)'Va: ',ncon,yva
             else
                call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
                if(gx%bmperr.ne.0) goto 1000
! i2sly is index of first neutral (if any) otherwise number of constit+1
                if(qsp.eq.zero .and. i2sly(2).gt.ncon) i2sly(2)=ncon
!                write(*,*)'Species: ',ncon,i2sly,qsp
!                if(qsp.eq.zero .and. i2sly(2).eq.0) i2sly(2)=ncon
!                pmi%valency(ncon)=abs(qsp)
!                write(*,*)'charge: ',ncon,qsp
                do jk=1,nspel
                   notva: if(ielno(jk).gt.0) then
! ignore vacancies in species
                      qsp=sites(ll)*stoi(jk)
                      pmi%dxmol(ielno(jk),ncon)=qsp
                      pmi%xmol(ielno(jk))=pmi%xmol(ielno(jk))+qsp*yarr(ncon)
                      sumion(ielno(jk),ll)=sumion(ielno(jk),ll)+&
                           stoi(jk)*yarr(ncon)
! take into account that the site ratios depend on constitition in corrion_..
!                      write(*,21)'ddMA:',jk,ielno(jk),ncon,ll,&
!                           pmi%dxmol(ielno(jk),ncon),qsp,sites(ll),stoi(jk)
!21                    format(a,4i3,4(1pe12.4))
! sums used in calc_dgdyterms1 to handle that sites(ll) depend on constitition
!                      pmi%sumiliq(ielno(jk),ll)=pmi%sumiliq(ielno(jk),ll)+&
!                              stoi(jk)*yarr(ncon)
! Hm, the statement above not necessary as below it is already included ....
                   endif notva
                enddo
             endif
          enddo
       enddo
! save these as needed in calc_dgdyterms
! i2sly(1) is index of vacancy, if no vacancy equal to #of constituents+1
! i2sly(2) is index if first neutral, if no neutal equal to #of constituents+1
       pmi%i2sly=i2sly
       pmi%yva=yva
! zero matrix
       pmat=zero
!...........................................
!       goto 261
! now handle that site ratios depend on constituent fractions
! (maybe also that the formula unit depend on composition)
! phlista(lokph)%i2slx; lokph=pmi%curd%phlink
! BUT: phlista is private ....
! M_A = P*M'_A + Q*M"_A           M'_A and M"_A are in sumion(A,1:2))
! P=\sum_j (-v_j)y_j + Qy_Va      j is anion
! Q=\sum_i v_iy_i                 i is cation
       icon=0
       do ik=1,nkl(1)
          icon=icon+1
          do jk=1,nrel
! for cations: extra dM_A/dyi = v_i*y_Va*M'_A + v_i*M"_A where i is cation
             qsp=pmi%curd%dpqdy(icon)*(yva*sumion(jk,1)+sumion(jk,2))
! note dxmol(jk,icon) has been multiplied with sites(1) above ....
             pmi%dxmol(jk,icon)=pmi%dxmol(jk,icon)+qsp
          enddo
       enddo
! i2sly(1) is index of vacancy, i2sly(2) index of first neutral
! If no vacancy or no neutral the corresponding i2sly is ncc+1
       do ik=1,nkl(2)
          icon=icon+1
          if(icon.lt.min(i2sly(1),i2sly(2))) then
             do jk=1,nrel
! for anions: extra dM_A/dyj = (-v_j)*M'_A where j is anion
                qsp=pmi%curd%dpqdy(icon)*sumion(jk,1)
                pmi%dxmol(jk,icon)=pmi%dxmol(jk,icon)+qsp
!              write(*,654)'Extra term anjon:  ',jk,icon,pmi%dxmol(jk,icon),qsp
             enddo
          else
! note icon not updated correctly if neutrals, use ncon below
             exit
          endif
       enddo
! take care of a vacancy
       if(icon.eq.i2sly(1)) then
          do jk=1,nrel
! for Va: extra dM_A/dyi = Q*M'_A where i is vacancy
             pmi%dxmol(jk,icon)=sites(2)*sumion(jk,1)
!             write(*,654)'Extra term for Va: ',jk,icon,&
!                  pmi%dxmol(jk,icon),sites(2)*sumion(jk,1)
          enddo
       endif
! Derivatives with respect to neutrals have no extra term
!       do jk=1,nrel
!          write(*,217)'dMA2:',jk,(pmi%dxmol(jk,ik),ik=1,ncc)
!       enddo
! one may exit loop above with different values of ncon and icon, 
! ncon is the total number of constituents
       icon=ncon
!......................................... end handling P and Q variation
261    continue
! meqrec is not available in this routine
       do ik=1,nrel
          pmi%sumxmol=pmi%sumxmol+pmi%xmol(ik)
          pmi%sumwmol=pmi%sumwmol+pmi%xmol(ik)*mass_of(ik,ceq)
       enddo
! now calculate G and all 1st and 2nd derivatives
! The calculated values are used also in other parts of the code 
       call calcg(iph,ics,2,lokcs,ceq)
       if(gx%bmperr.ne.0) then
          write(*,*)'Error calculating G'
          goto 1000
       endif
! correction of second derivatives due to variation of P and Q
       if(meqrec%noofits.gt.1) then
! NOTE pmat is dimensioned pmat(nd1,nd2)
          call corriliq_d2gdyidyj(nkl,knr,ceq%cmuval,pmi,ncon,nd1,pmat,ceq)
          if(gx%bmperr.ne.0) goto 1000
       endif
!       write(*,17)'pots: ',(ceq%cmuval(ik),ik=1,3)
!       do ll=1,nd1
!          write(*,17)'cion: ',(pmat(ll,ik),ik=1,nd1)
!       enddo
! calculate phase matrix elements, the second derivatives
! note pmat has some contributions above ??
       neq=icon
       fion=one
       do ik=1,icon
          do jk=ik,icon
             pmat(ik,jk)=fion*pmat(ik,jk)+&
                  ceq%phase_varres(lokcs)%d2gval(ixsym(ik,jk),1)
! remove next line when using a routine inverting a symmetric matrix
             if(jk.gt.ik) pmat(jk,ik)=pmat(ik,jk)
          enddo
       enddo
! Then set the sublattice elements
       kk=0
       do ll=1,nsl
          do ik=1,nkl(ll)
! set the sublattice columns and rows
             kk=kk+1
             pmat(kk,neq+ll)=one
             pmat(neq+ll,kk)=one
          enddo
       enddo
       neq=neq+nsl
!       write(*,65)'pdim: ',nd1,nd2,neq,ncon,icon,nsl,(nkl(ll),ll=1,nsl)
!65     format(a,6i4,10i3)
!       do ll=1,nd1
!          write(*,17)'pmat: ',(pmat(ll,ik),ik=1,nd1)
17        format(a,6(1pe12.4))
!       enddo
! invert the phase matrix (faster routine should be used) IONIC LIQUID MODEL
       call mdinv(nd1,nd2,pmat,pmi%invmat,nd1,ierr)
       if(ierr.eq.0) then
          write(*,*)'Phase matrix singular 2:',pmi%iph,pmi%ics,pmi%ncc,ierr
          do jk=1,neq
             write(*,73)(pmat(ik,jk),ik=1,neq)
          enddo
          gx%bmperr=4205; goto 1000
       endif
!       do ll=1,nd1
!          write(*,17)'pinv: ',(pmi%invmat(ll,ik),ik=1,nd1)
!       enddo
! maybe some common ending
       goto 900
    endif ionliq
!------------------------------------------------- all other phase models (CEF)
! For all other phases calculate G and all first and second derivatives
! for current composition
300 continue
! Calculate M_i and dM_i/dy^s_k and the net charge charge Q and dQ/dy^s_k
!   call get_phase_data(iph,ics,nsl,nkl,knr,yarr,sites,qq,ceq)
! how to normalize xmol?  use qq(1)!!, it handels vacancies .... ????
    sumsit=one
    pmi%xmol=zero
    pmi%dxmol=zero
    qsum=zero
    dqsum=zero
    ncon=0
    pmi%sumxmol=zero
    pmi%sumwmol=zero
    subll: do ll=1,nsl
       constll: do ik=1,nkl(ll)
          ncon=ncon+1
          loksp=knr(ncon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
          if(gx%bmperr.ne.0) goto 1000
          addmol=zero
          do jk=1,nspel
             addmol(jk)=stoi(jk)
          enddo
          dqsum(ncon)=sites(ll)*qsp
          qsum=qsum+sites(ll)*qsp*yarr(ncon)
          do jk=1,nspel
!             write(*,*)'xmol: ',ncon,ik,jk,ielno(j)
             if(ielno(jk).gt.0) then
! ignore vacancies
! addmol(jk) can be replaced by stoi(jk) when I know it works ....
                pmi%dxmol(ielno(jk),ncon)=sites(ll)*addmol(jk)
                pmi%xmol(ielno(jk))=pmi%xmol(ielno(jk))+&
                     sites(ll)*addmol(jk)*yarr(ncon)
             endif
          enddo
       enddo constll
    enddo subll
! meqrec is not available in this routine
    do ik=1,nrel
       pmi%sumxmol=pmi%sumxmol+pmi%xmol(ik)
!       write(*,*)'sumwmol 3:',pmi%xmol(ik),mass_of(ik,ceq)
       pmi%sumwmol=pmi%sumwmol+pmi%xmol(ik)*mass_of(ik,ceq)
    enddo
!    write(*,92)'onephase 3: ',pmi%iph,nsl,pmi%xdone,pmi%sumxmol,&
!         pmi%sumnmol,qq(1)
!    write(*,17)'Vacanies: ',qq
!       do i=1,noel()
!          write(*,17)'xm: ',pmi%xmol(i)
!          write(*,17)'dxm: ',(pmi%dxmol(i,j),j=1,ncon)
!       enddo
! now calculate G and all 1st and 2nd derivatives
! The calculated values are used also in other parts of the code 
    call calcg(iph,ics,2,lokcs,ceq)
    if(gx%bmperr.ne.0) then
       write(*,*)'Error calculating G'
       goto 1000
    endif
! calculate phase matrix elements, first second derivatives
    pmat=zero
    neq=ncon
    do ik=1,ncon
       do jk=ik,ncon
          pmat(ik,jk)=ceq%phase_varres(lokcs)%d2gval(ixsym(ik,jk),1)
! remove next line when using an inversion for symmetric matrix
          if(jk.gt.ik) pmat(jk,ik)=pmat(ik,jk)
       enddo
!       write(*,17)'row2A: ',(pmat(ik,jj),jj=1,nd1)
    enddo
! Then set the sublattice elements
    kk=0
    do ll=1,nsl
       do ik=1,nkl(ll)
! set the sublattice columns and rows
          kk=kk+1
          pmat(kk,neq+ll)=one
          pmat(neq+ll,kk)=one
       enddo
!       write(*,17)'row3: ',(pmat(ncon+ll,jj),jj=1,nd1)
    enddo
    neq=neq+nsl
    if(pmi%chargebal.eq.1) then
! if external charge balance add one column and one row
       neq=neq+1
       do jk=1,ncon
! this is the row
          pmat(jk,neq)=dqsum(jk)
! this is the column
          pmat(neq,jk)=dqsum(jk)
       enddo
    endif
! debug output
!    write(*,*)'Phase matrix',nd1,neq,pmi%chargebal
!    do j=1,neq
!       write(*,17)'pmat: ',(pmat(i,j),i=1,neq)
!    enddo
! invert the phase matrix (faster routine should be used) ALL OTHER MODELS
    call mdinv(nd1,nd2,pmat,pmi%invmat,neq,ierr)
    if(ierr.eq.0) then
       if(ocv()) write(*,556)'Phase matrix singular 3:',meqrec%noofits,&
            pmi%iph,pmi%ics,pmi%ncc,ierr
556    format(a,5i5)
!       do jk=1,neq
!          write(*,73)(pmat(ik,jk),ik=1,neq)
!       enddo
       gx%bmperr=4205; goto 1000
    endif
!    do i=1,neq
!       write(*,17)'pinv: ',(pmi%invmat(i,j),j=1,neq)
!    enddo
! maybe some common ending
    goto 900
!-------------------------------------------
900 continue
    goto 1000
!
1000 continue
    return
  end subroutine meq_onephase
 
!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine corriliq_d2gdyidyj(nkl,knr,curmu,pmi,ncc,nd1,pmat,ceq)
! correction of d2G/dy1dy2 for ionic liquid because the formula unit is
! not fixed.  This contributes ONLY to the second derivaties of G and
! is not really part of the model itself, only needed when minimizing G
    implicit none
    type(gtp_equilibrium_data), pointer :: ceq
    TYPE(meq_phase), pointer :: pmi
    integer ncc,nd1,nkl(*),knr(*)
    double precision curmu(*),pmat(nd1,*)
!\end{verbatim}
! corr = \sum_A \mu_A*d2(N_A)/dy_i/dy_k ; i cation, k cation, anion, Va
! N_A  = P*\sum_i b_Ai y_i + Q(\sum_j b_Aj y_j + ... ) b_Ai stoich.fact. of A
! P    = \sum_j v_j y_j + y_Va Q
! Q    = \sum_i v_i y_i 
!
! Derivativs of P and Q
! dP/dy_i = y_Va v_i;   dP/dy_j = v_j;  dP/dy_Va = Q
! dQ/dy_i = v_i         dQ/dy_j = zero  dQ/dy_Va = zero
! d2P/dy_idy_Va = v_i
! 
! d(N_A\mu_A)/dy_i = dP/dy_i\sum_jb_Aj + v_i
!
    integer i1,i2,icon,jcon,loksp,nspel,ielno(10),el,allions,nobug
    double precision stoi(10),spmass,qsp1,qsp2,add1,add2,yva,sumcat,bug
    double precision bugfix
!tafidbug
!    write(*,*)'Skipping liquid correction'
!    goto 1000
! this correction term affects only second derivatives and thus convergence 
! speed and stability.  But it seems just to mess up everything.
!
! dpqdy(1..ncc) is the absolute value of the charge of the species
! It is not used as we must get species data, better not to use ...
! i2sly(1) is index of vacancy, i2sly(2) is index of first neutral
! If either is missing it is equal to number of constituents+1
    allions=min(pmi%i2sly(1),pmi%i2sly(2))
!    write(*,12)'mu: ',(curmu(i1),i1=1,noel())
12  format(a,6(1pe12.4))
    if(nkl(1).eq.0) then
! no cations (bor anions), only neutrals, no need to calculate anything      
!       write(*,*)'Liquids without cations have fixed stoichiometry 1.0
       goto 1000
    endif
! If there are vacancies we save its fraction here, if not set to zero
!    if(pmi%i2sly(1).lt.ncc) then
    if(pmi%i2sly(1).le.ncc) then
       yva=pmi%curd%yfr(pmi%i2sly(1))
    else
       yva=zero
    endif
!    write(*,11)'corrion 1: ',yva,pmi%i2sly,nkl(1)+nkl(2),allions,ncc
11  format(a,1pe12.4,10i5)
! to simplify testing, 0 means include contribution from pairs of cations
    nobug=0
    bugfix=one
    sumcat=zero
! just loop for all cations here. Inside this loop we step jcon
!  for all constituents up to vacancies or last anion.
    do icon=1,nkl(1)
!    icon=0
!    do i1=1,nkl(1)
!    do i1=1,allions-1
! loop for all cations and anions
!       icon=icon+1
       loksp=knr(icon)
       call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp1)
       if(gx%bmperr.ne.0) goto 1000
       add2=zero
       do el=1,nspel
! skip any vacancy in a species, they have zero chemical potential anyway
          if(ielno(el).gt.0) add2=add2+stoi(el)*curmu(ielno(el))
       enddo
       add1=add2
!       write(*,13)'first cat: ',icon,0,qsp1,add1
13     format(a,2i3,6(1pe12.4))
!-------------------------2nd derivatives wrt two cations
       jcon=icon
       do while(jcon.le.nkl(1))
! loop for all pairs of cations incl twins, nkl(1) is number of cations
! A smart but messy solution is to skip this loop for jcon=icon ...
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp2)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
          bug=add2
! sumcat is used below for derivative wrt cation and vacancy
          if(icon.eq.1) then
             sumcat=sumcat+pmi%curd%yfr(jcon)*add2
!                write(*,13)'sumcat:    ',0,jcon,yva,pmi%curd%yfr(jcon),&
!                     add2,sumcat
          endif
! if there are no vacancies the derivative of P is zero wrt two cations
! this is \sum_A dP/dy_icon*b_Ajcon*mu_A+\sum_A dP/dy_jcon*b_Aicon*mu_A
          if(nobug.eq.0 .and. yva.gt.zero) then
             add2=bugfix*yva*(qsp1*add2+qsp2*add1)
!             if(abs(yva*(add2)).gt.1.0D2) then
! This is a sensitive point for convergence, values of 1.0D+33 found !!!
! But bad converge also when small values, less than 100
!                add2=-1.0D2
!             endif
!             write(*,13)'pmat caca: ',icon,jcon,qsp1,yva,bug,add2
! store value in pmat as correction to d2G/dyidyj
             pmat(icon,jcon)=-add2
! tafidbug 2
!             pmat(icon,jcon)=add2
          endif
          jcon=jcon+1
       enddo
! ------------------------ 2nd derivative wrt to cation and anion
       do while(jcon.lt.allions)
! loop for all anions, allions-1 is last anion
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp2)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
          bug=add2
! This is \sum_A dP/dy_jcon*b_Aicon*mu_A+\sum_A dQ/dy_icon*b_Ajcon*mu_A
! Note dP/dy = -qsp2 as qsp2 is negative
          add2=qsp1*add2-qsp2*add1
!          write(*,13)'pmat caan: ',icon,jcon,qsp2,bug,add2
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-add2
! tafidbug 2
!          pmat(icon,jcon)=add2
          jcon=jcon+1
       enddo
!------------- second derivative wrt cation and vacancy
!       if(icon.le.nkl(1) .and. jcon.eq.pmi%i2sly(1)) then
       if(jcon.le.ncc .and. jcon.eq.pmi%i2sly(1)) then
! if no vacancy then i2sly(1)=ncc+1
! This is \sum_A d2P/dy_icon dy_Va*\sum_k y_k*b_Ak*\mu_A + Q * b_Aicon*\mu_A
          add2=qsp1*sumcat+pmi%curd%sites(2)*add1
! It think the line above is correct but the one below works better ...
!          add2=qsp1*sumcat
!          write(*,13)'pmat cava: ',icon,jcon,qsp1,&
!               sumcat,pmi%curd%sites(2),add1,add2
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-add2
! tafidbug 2
!          pmat(icon,jcon)=add2
          jcon=jcon+1
       endif
!------------- second derivative wrt cation and neutral
! is this really correct??
       do while(jcon.le.ncc)
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp2)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
          bug=add2
! This is \sum_A dQ/dy_icon * b_Ajcon * mu_A, icon is cation and jcon neutal
          add2=qsp1*add2
!          write(*,13)'pmat cane: ',icon,jcon,qsp1,bug,add2
          pmat(icon,jcon)=-add2
! tafidbug 2
!          pmat(icon,jcon)=add2
          jcon=jcon+1
       enddo
!------------- no other terms
    enddo
!    write(*,*)'Correction to phase matrix from corriliq: ',&
!         pmi%curd%phtupx,nobug
!    do icon=1,ncc
!       write(*,1100)(pmat(icon,jcon),jcon=1,ncc)
!    enddo
1100 format(6(1pe12.4))
1000 continue
    return
  end subroutine corriliq_d2gdyidyj

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!-\begin{verbatim}
  subroutine corriliq_d2gdyidyj_old(nkl,knr,curmu,yva,pmi,ncc,pmat,ceq)
! correction of d2G/dy1dy2 for ionic liquid because the formula unit is
! not fixed.  This contributes ONLY to the second derivaties of G and
! is not really part of the model itself, only needed when minimizing G
    implicit none
    type(gtp_equilibrium_data), pointer :: ceq
    TYPE(meq_phase), pointer :: pmi
    integer ncc,nkl(*),knr(*)
    double precision curmu(*),pmat(ncc,*),yva
!-\end{verbatim}
! corr = \sum_A \mu_A * d2 N_A/dy_i dy_k ; i cation, j anion, Va vacancy, k meu
! N_A  = P*\sum_i b_Ai y_i + Q(\sum_j b_Aj y_j) + Q(\sum_j b_Ak y_k)
! P    = \sum_j v_j y_j + y_Va \sum_i v_i y_i
! Q    = \sum_i v_i y_i 
! N_A  = (\sum_j v_jy_j + y_Va\sum_i v_iy_i)\sum_i b_Aiy_i +
!         \sum_i v_iy_i\sum_j b_Ajy_j
!
! Derivate wrt to a cation k:
! dN_A/dy_k=(\sum_j v_jy_j+y_Va\sum_i v_iy_i) b_Ak + y_Va v_k\sum_i b_Aiy_i
!         v_k\sum_j b_Ajy_j
! Derivate wrt to another cation m:
! d2N_A/dy_kdy_m = y_Va v_m b_Ak + y_Va v_k b_Am
! 
    integer i1,i2,icon,jcon,loksp,nspel,ielno(10),el,allions
    double precision stoi(10),spmass,qsp,qsp1,add1,add2,add3,bcat,bani,bneu
!
! dpqdy(1..ncc) is the absolute value of the charge of the species
! It is not used as we must get species data, better not to use ...
! i2sly(1) is index of vacancy, i2sly(2) is index of first neutral
! If either is missing it is equal to number of constituents+1
    allions=min(pmi%i2sly(1),pmi%i2sly(2))
!    write(*,11)'corrion 2: ',pmi%i2sly,nkl(1)+nkl(2),allions,ncc
11  format(a,10i5)
    icon=0
    write(*,12)'mu: ',(curmu(i1),i1=1,noel())
12  format(a,6(1pe12.4))
!    do i1=1,nkl(1)+nkl(2)
! loop for all constituents
    if(nkl(1).eq.0) then
!       write(*,*)'Liquids without cations have fixed stoichiometry 1.0
!       gx%bmperr=9876
       goto 1000
    endif
    do i1=1,nkl(1)
! loop for all cations, one derivative must be for a cation
       icon=icon+1
       loksp=knr(icon)
       call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp1)
       if(gx%bmperr.ne.0) goto 1000
       add2=zero
       do el=1,nspel
! skip any vacancy in a species, they have zero chemical potential anyway
          if(ielno(el).gt.0) add2=add2+stoi(el)*curmu(ielno(el))
       enddo
       add1=add2
       write(*,13)'cation: ',icon,0,qsp1,add1
13     format(a,2i3,6(1pe12.4))
!-------------------------2nd derivatives wrt two cations
       jcon=icon
       do while(jcon.le.nkl(1))
! loop for all pairs of cations incl twins, nkl(1) is number of cations
! A smart and messy solution is to skip this loop for jcon=icon ...
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
          add2=add1*qsp+add2*qsp1
          write(*,13)'pmat caca: ',icon,jcon,add2,qsp,yva,yva*add2
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-yva*add2
          jcon=jcon+1
       enddo
! ------------------------ 2nd derivative wrt cation and anion
       do while(jcon.lt.allions)
! loop for all anions, allions-1 is last anion
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
! anions have negative charge
!          add2=add2*qsp1-add1*qsp
          add2=add2*qsp1+add1*qsp
          write(*,13)'pmat caan: ',icon,jcon,qsp,add2
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-add2
          jcon=jcon+1
       enddo
!-------------second derivative wrt cation and vacancy
       if(jcon.eq.pmi%i2sly(1)) then
          write(*,13)'pmat cava: ',icon,jcon,add1,pmi%curd%sites(2),&
               add1*pmi%curd%sites(2)
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-add1*pmi%curd%sites(2)
       endif
       jcon=jcon+1
!-------------second derivative wrt cation and neutral
       do while(jcon.le.ncc)
          loksp=knr(jcon)
          call get_species_data(loksp,nspel,ielno,stoi,spmass,qsp)
          if(gx%bmperr.ne.0) goto 1000
          add2=zero
          do el=1,nspel
             if(ielno(el).ne.0) add2=add2+stoi(el)*curmu(ielno(el))
          enddo
          write(*,13)'pmat cane: ',icon,jcon,add2,qsp1,qsp1*add2
! store value in pmat as correction to d2G/dyidyj
          pmat(icon,jcon)=-qsp1*add2
          jcon=jcon+1
       enddo
    enddo
1000 continue
    return
  end subroutine corriliq_d2gdyidyj_old

!/!\!/!\!/!\!/!\!/\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

! subroutine
!\begin{verbatim}
  logical function same_composition(jj,phr,meqrec,ceq,dgm)
! returns .TRUE. if phase phr(jj) has almost exactly the same composition
! as another composition set of the same phase that is stable
! dgm just for debug output
! =============================================================
! The composition of the phases are compared as ordered phases one can have
! the same constitution but distributed on different sets of sublattices ....
! ==============================================================
    implicit none
    integer jj
    double precision dgm
    TYPE(meq_phase), dimension(*) :: phr
    TYPE(meq_setup) :: meqrec
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    integer jp,jy
! If the difference is larger than xdiff then the compositions are not the same
!    double precision, parameter :: xdiff=0.01D0
! FINETUNING: a large value of xdiff may mean you miss a miscibility gap
! a small value may create bad convergence
    double precision, parameter :: xdiff=0.05D0
    double precision, dimension(maxel) :: xmol1,xmol2,wmass
    double precision amount,totmol,totmass,xdiffm,xdiffc
! check if any other compset of the phase stable with same composition
    call calc_phase_molmass(phr(jj)%iph,phr(jj)%ics,xmol1,wmass,&
         totmol,totmass,amount,ceq)
    if(gx%bmperr.ne.0) goto 1000
    xdiffm=one
! ?? strange loop limits ??
!    do jp=jj-1,1,-1
    do jp=1,meqrec%nphase
       if(phr(jp)%iph.eq.phr(jj)%iph) then
          if(phr(jp)%stable.eq.1) then
             call calc_phase_molmass(phr(jp)%iph,phr(jp)%ics,xmol2,wmass,&
                  totmol,totmass,amount,ceq)
             if(gx%bmperr.ne.0) goto 1000
             do jy=1,meqrec%nrel
                xdiffc=abs(xmol1(jy)-xmol2(jy))
                if(xdiffc.lt.xdiffm) then
                   xdiffm=xdiffc
                endif
                if(xdiffc.gt.xdiff) goto 110
!                if(abs(xmol1(jy)-xmol2(jy)).gt.xdiff) goto 110
             enddo
! we have found another stable composition set with same composition
             goto 300
          endif
       elseif(phr(jp)%iph.lt.phr(jj)%iph) then
          cycle
       else
          exit
       endif
110    continue
    enddo
! check if any with higher index is same phase as jj
!    do jp=jj+1,meqrec%nphase
!       if(phr(jp)%iph.eq.phr(jj)%iph) then
!          if(phr(jp)%stable.eq.1) then
!             call calc_phase_molmass(phr(jp)%iph,phr(jp)%ics,xmol2,wmass,&
!                  totmol,totmass,amount,ceq)
!             if(gx%bmperr.ne.0) goto 1000
!             write(*,118)phr(jj)%ics,dgm,(xmol1(j),j=1,noel())
!             write(*,118)phr(jp)%ics,zero,(xmol2(j),j=1,noel())
!             do jy=1,meqrec%nrel
!                if(abs(xmol1(jy)-xmol2(jy)).gt.xdiff) goto 120
!             enddo
! we have found another stable composition set with same composition
!             goto 300
!          endif
!       else
!          exit
!       endif
!120    continue
!    enddo
! no composition set of same phase with same constitution
    same_composition=.FALSE.
    goto 1000
!--------------------------------------------------------
! we found a stable composition set with the same composition
300 continue
    same_composition=.TRUE.
    if(ocv()) write(*,117)'Not added comp.set phase: ',phr(jj)%iph,&
         phr(jj)%ics,phr(jp)%ics,xdiffm
117 format(a,i3,2i4,2x,1pe12.4)
! One cannot have two composition sets with same composition.
! try to reset this composition set to default constition
    call set_default_constitution(phr(jj)%iph,phr(jj)%ics,ceq)
    if(gx%bmperr.ne.0) goto 1000
    goto 1000
!
1000 continue
    return
  end function same_composition

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine calc_dgdyterms1(nrel,ia,tpindep,mamu,mag,mat,map,pmi,&
       curmux,noofits)
! any change must also be made in subroutine calc_dyterms2 and calc_dgdytermsh
! calculate the terms in the deltay expression for amounts of component ia
!
! DM_A = \sum_B mu_B*MAMU(B) - MAG - MAT*dt - MAP*dp
!
! where MAMU=\sum_i dM_A/dy_i*\sum_j invmat(i,j)*dM_B/dy_j
!       c_iB=\sum_j invmat(i,j)*dM_B/dy_j etc etc
!
! it may not be very efficient but first get it right ....
! tpindep(1) is TRUE if T variable, tpindep(2) is TRUE if P are variable
    implicit none
    integer ia,nrel,noofits
    logical tpindep(2)
    double precision, dimension(*) :: mamu
    double precision mag,mat,map
    double precision curmux(*)
! pmi is the phase data record for this phase
    type(meq_phase), pointer :: pmi
!\end{verbatim} %+
! THIS IS THE ONE CURRENTLY USED IN THE MINIMIZATIONS
! these are to be multiplied with mu(ib), nothing, deltaT, deltaP
    integer iy,jy,ib
    double precision sum,cig,cit,cip,cib
    double precision morr,curmu(maxel)
!
!    write(*,*)'entering calc_dgdyterms: ',ia
    mag=zero
    do ib=1,nrel
       sum=zero
       do jy=1,pmi%ncc
          cib=zero
! for ionic liquid the inverted phase matrix is strange when neutrals included
          do iy=1,pmi%ncc
             cib=cib+pmi%invmat(iy,jy)*pmi%dxmol(ib,iy)
          enddo
          sum=sum+cib*pmi%dxmol(ia,jy)
       enddo
       mamu(ib)=sum
! tafid bug
!       mamu(ib)=-sum
    enddo
!-----------
!    if(noofits.eq.1) then
!       curmu=zero
!    else
    do iy=1,nrel
       curmu(iy)=curmux(iy)
    enddo
!    endif
!-----------
! \sum_i \sum_j e_ij*dM_A/dy_i dG/dy_j
    mag=zero
    mat=zero
    map=zero
    do iy=1,pmi%ncc
       cig=zero
       cit=zero
       cip=zero
       do jy=1,pmi%ncc
! I inversed order of iy, jy, does it still converge??
          cig=cig+pmi%invmat(jy,iy)*pmi%curd%dgval(1,jy,1)
! always calculate cit because cp debug!!
          if(tpindep(1)) cit=cit+pmi%invmat(jy,iy)*pmi%curd%dgval(2,jy,1)
          if(tpindep(2)) cip=cip+pmi%invmat(jy,iy)*pmi%curd%dgval(3,jy,1)
       enddo
       morr=pmi%dxmol(ia,iy)
! tafid bug
!       morr=-pmi%dxmol(ia,iy)
       mag=mag+morr*cig
       mat=mat+morr*cit
       map=map+morr*cip
    enddo
1000 continue
    return
  end subroutine calc_dgdyterms1

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim} %+
  subroutine calc_dgdyterms2(iy,nrel,mamu,mag,mat,map,pmi)
! it should be similar to calc_dgdyterms1
    implicit none
    integer iy,nrel
    double precision mag,mat,map,mamu(*)
    type(meq_phase), pointer :: pmi
!\end{verbatim} %-
! these are to be multiplied with mu(ib), nothing, deltaT, deltaP
! I am not sure if this is used ...
    integer jy,ib
    double precision sum,cig,cit,cip
!
!    write(*,*)'entering calc_dgdyterms2: ',ia,nrel
    mag=zero
    do ib=1,nrel
       sum=zero
       do jy=1,pmi%ncc
          sum=sum+pmi%invmat(iy,jy)*pmi%dxmol(ib,jy)
       enddo
       mamu(ib)=sum
    enddo
!-----------
!    if(noofits.eq.1) then
!       curmu=zero
!    else
!    do iy=1,nrel
!       curmu(iy)=curmux(iy)
!    enddo
!    endif
!-----------
! \sum_i \sum_j e_ij*dM_A/dy_i dG/dy_j
    cig=zero
    cit=zero
    cip=zero
    do jy=1,pmi%ncc
       cig=cig+pmi%invmat(jy,iy)*pmi%curd%dgval(1,jy,1)
       cit=cit+pmi%invmat(jy,iy)*pmi%curd%dgval(2,jy,1)
       cip=cip+pmi%invmat(jy,iy)*pmi%curd%dgval(3,jy,1)
    enddo
    mag=cig
    mat=cit
    map=cip
1000 continue
    return
  end subroutine calc_dgdyterms2

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim} %+
  subroutine calc_dgdytermsh(nrel,ia,tpindep,hval,mamu,mag,mat,map,pmi,&
       curmux,noofits)
! This is a variant of dgdyterms1 including a term multiplied with each
! term (hval) in the summation over the comstituents as needed when calculating
! an equation for fix V or H.  If hval(i)=1.0 it should give the same
! results as dgdyterms1
!
! calculate the terms in the deltay expression for amounts of component ia
!
! DM_A = \sum_B mu_B*MAMU(B) - MAG - MAT*dt - MAP*dp
!
! where MAMU=\sum_i dM_A/dy_i*\sum_j invmat(i,j)*dM_B/dy_j
!       c_iB=\sum_j invmat(i,j)*dM_B/dy_j etc etc
!
! it may not be very efficient but first get it right ....
! tpindep(1) is TRUE if T variable, tpindep(2) is TRUE if P are variable
    implicit none
    integer ia,nrel,noofits
    logical tpindep(2)
    double precision, dimension(*) :: hval,mamu
    double precision mag,mat,map
    double precision curmux(*)
! pmi is the phase data record for this phase
    type(meq_phase), pointer :: pmi
!\end{verbatim}
! THIS IS MODIFIED FOR CONDITIONS ON H and related properties
! these are to be multiplied with mu(ib), nothing, deltaT, deltaP
    integer iy,jy,ib
    double precision sum,cig,cit,cip,cib
    double precision morr,curmu(maxel)
!
!    write(*,11)'in termsh: ',ia,0,0,pmi%invmat
    mag=zero
    do ib=1,nrel
       sum=zero
       do iy=1,pmi%ncc
          cib=zero
          do jy=1,pmi%ncc
             cib=cib+pmi%invmat(iy,jy)*pmi%dxmol(ib,jy)
          enddo
          sum=sum+cib*hval(iy)
!          write(*,11)'termsh mu: ',ib,iy,0,hval(iy),sum
11        format(a,3i2,6(1pe12.4))
       enddo
       mamu(ib)=sum
    enddo
!-----------
!    if(noofits.eq.1) then
!       curmu=zero
!    else
    do iy=1,nrel
       curmu(iy)=curmux(iy)
    enddo
!    endif
!-----------
! \sum_i \sum_j e_ij*dM_A/dy_i dG/dy_j
    mag=zero
    mat=zero
    map=zero
    do iy=1,pmi%ncc
       cig=zero
       cit=zero
       cip=zero
       do jy=1,pmi%ncc
! I inversed order of iy, jy, does it still converge??
          cig=cig-pmi%invmat(jy,iy)*pmi%curd%dgval(1,jy,1)
!          write(*,11)'termsh g: ',ia,iy,jy,pmi%invmat(jy,iy),&
!               pmi%curd%dgval(1,jy,1),cig
! always calculate cit because cp debug!!
! hval(j)=dG/dy_j-Td2G/dTdy_j or something similar
          if(tpindep(1)) then
             cit=cit-pmi%invmat(jy,iy)*pmi%curd%dgval(2,jy,1)
!             write(*,11)'termsh t: ',ia,iy,jy,pmi%curd%dgval(2,jy,1),cit
          endif
          if(tpindep(2)) cip=cip-pmi%invmat(jy,iy)*pmi%curd%dgval(3,jy,1)
       enddo
!       morr=pmi%dxmol(ia,iy)
       morr=hval(iy)
       mag=mag+morr*cig
       mat=mat+morr*cit
       map=map+morr*cip
    enddo
!    write(*,11)'termsh: ',ia,0,0,mag,mat,map,(mamu(jy),jy=1,nrel)
1000 continue
    return
  end subroutine calc_dgdytermsh

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine meq_evaluate_all_svfun(kou,ceq)
! evaluate and list values of all state variable functions
   implicit none
   integer kou
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
! THIS SUBROUTINE MOVED FROM pmod25D
   character actual_arg(10)*24
   integer kf,nsvfun
   double precision val
   nsvfun=nosvf()
   if(kou.gt.0) write(kou,75)
75 format('No  Name ',12x,'Value')
   do kf=1,nsvfun
! actual arguments needed if svflista(kf)%nactarg>0
      val=meq_evaluate_svfun(kf,actual_arg,0,ceq)
      if(gx%bmperr.ne.0) goto 1000
      if(kou.gt.0) write(kou,77)kf,svflista(kf)%name,val
77    format(i3,1x,a,1x,1PE15.8)
   enddo
1000 continue
   return
 end subroutine meq_evaluate_all_svfun

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine meq_get_state_varorfun_value(statevar,value,dummy,ceq)
! used in OCPLOT to extact value of state variable of symbol
! NOTE if a specific function is given only this function evaluated
   implicit none
   character statevar*(*),dummy*(*)
   double precision value
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character encoded*64,actual_arg(2)*16
   integer lrot,mode
!
!   write(*,*)'In meq_get_state_varofun: ',statevar(1:16)
! if not derivative this will work
   call get_state_var_value(statevar,value,encoded,ceq)
   if(gx%bmperr.ne.0) then
! if error try using meq_evaluate_svfun try calling meq_evaluate_svfun
!      write(*,*)'In meq_get_state_varofun 2: ',gx%bmperr
      lrot=gx%bmperr
      gx%bmperr=0
      encoded=statevar
      call capson(encoded)
      call find_svfun(encoded,lrot,ceq)
      if(gx%bmperr.ne.0) then
! if error here return previous error code
!         write(*,*)'In meq_get_state_varofun 3: ',gx%bmperr
         value=zero
         gx%bmperr=lrot; goto 1000
      else
         mode=1
         actual_arg=' '
         value=meq_evaluate_svfun(lrot,actual_arg,mode,ceq)
      endif
   else
      dummy=encoded
   endif
1000 continue
   return
 end subroutine meq_get_state_varorfun_value

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

! subroutine
!\begin{verbatim}
 double precision function meq_evaluate_svfun(lrot,actual_arg,mode,ceq)
! envaluate all funtions as they may depend on each other
! actual_arg are names of phases, components or species as @Pi, @Ci and @Si
! needed in some deferred formal parameters  (NOT IMPLEMENTED YET)
! if mode=1 always evaluate, if mode=0 several options
   implicit none
   integer lrot,mode
   character actual_arg(*)*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
! THIS SUBROUTINE MOVED FROM pmod25D
   character encoded*60
   double precision argval(20)
   type(gtp_state_variable), pointer :: svr,svr2
   integer jv,jt,istv,ieq,nsvfun
   double precision value
!
   value=zero
   argval=zero
   nsvfun=nosvf()
!   write(*,*)'in meq_evaluate_svfun 1',lrot,nsvfun,mode
! locate function
   if(lrot.le.0 .or. lrot.gt.nsvfun) then
      gx%bmperr=4140; goto 1000
   endif
!   write(*,*)'in meq_evaluate_svfun 2',svflista(lrot)%narg
   if(svflista(lrot)%narg.eq.0) goto 300
! get values of arguments
   jv=0
   jt=0
100 continue
      jt=jt+1
      istv=svflista(lrot)%formal_arguments(1,jt)
!      write(*,*)'in meq_evaluate_svfun 3A',jt,istv
      if(istv.lt.0) then
! if eqnoval nonzero it indicates from which equilibrium to get its value
         ieq=svflista(lrot)%eqnoval
!********************************************************************
! Note!! it should be evaluated!! Not implemented ...
!********************************************************************
         if(ieq.eq.0) then
            value=ceq%svfunres(-istv)
         else
            value=eqlista(ieq)%svfunres(-istv)
         endif
!         write(*,*)'in meq_evaluate_svfun 3X',ieq,istv,value
      else
! the need for 1:10 was a new bug discovered in GNU fortran 4.7 and later
         call make_stvrec(svr,svflista(lrot)%formal_arguments(1:10,jt))
         if(gx%bmperr.ne.0) goto 1000
         if(svflista(lrot)%formal_arguments(10,jt).eq.0) then
! get state variable or symbol value
!            write(*,*)'In meq_evaluate_svfun 3D: ',svr
            call state_variable_val(svr,value,ceq)
! error check at the end of if...
         else
! state variable derivative, the denominator is the next variable
            jt=jt+1
            call make_stvrec(svr2,svflista(lrot)%formal_arguments(1:10,jt))
!            write(*,77)'meq_eval: ',&
!                 (svflista(lrot)%formal_arguments(ii,jt),ii=1,10)
! This routine need access to the subroutines in the minimizer
            call meq_state_var_value_derivative(svr,svr2,value,ceq)
         endif
      endif
      if(gx%bmperr.ne.0) goto 1000
      jv=jv+1
      argval(jv)=value
!      write(*,*)'in meq_evaluate_svfun 3B: ',jv,jt,argval(jv)
      if(jt.lt.svflista(lrot)%narg) goto 100
! all arguments evaluated (or no arguments needed)
300 continue
   modeval: if(mode.eq.0 .and. btest(svflista(lrot)%status,SVFVAL)) then
! If mode=0 and SVFVAL set return the stored value
      value=ceq%svfunres(lrot)
!      write(*,350)'evaluate svfun 2: ',0,lrot,value
350   format(a,2i4,1pe12.4)
   elseif(mode.eq.0 .and. btest(svflista(lrot)%status,SVFEXT)) then
! if mode=0 and SVFEXT set use value from equilibrium eqno
      ieq=svflista(lrot)%eqnoval
      if(ceq%eqno.eq.ieq) then
         value=evalf(svflista(lrot)%linkpnode,argval)
         if(pfnerr.ne.0) then
            write(*,*)'evaluate_svfun putfunerror ',pfnerr
            gx%bmperr=4141; goto 1000
         endif
         ceq%svfunres(lrot)=value
!         write(*,350)'evaluate svfun 3: ',ieq,lrot,value
      else
         value=eqlista(ieq)%svfunres(lrot)
      endif
   else
! if mode=1 always evaluate
!      write(*,*)'in meq_evaluate_svfun 5',argval(1)
      value=evalf(svflista(lrot)%linkpnode,argval)
      if(pfnerr.ne.0) then
         write(*,*)'evaluate_svfun putfunerror ',pfnerr
         gx%bmperr=4141; goto 1000
      endif
   endif modeval
! save value in current equilibrium
   ceq%svfunres(lrot)=value
1000 continue
   meq_evaluate_svfun=value
   return
 end function meq_evaluate_svfun

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine initiate_meqrec(svr,svar,meqrec,ceq)
! this is to setup data for a state var derivative calculation
! taken from the normal initialization of an equilibrium calculation
! it also solves a modified equil matrix once to get delta-amounts and mu
    TYPE(meq_setup), pointer :: meqrec
    TYPE(gtp_state_variable), pointer :: svr
    double precision, allocatable :: svar(:)
    TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
    TYPE(meq_phase), pointer :: pmi
    integer iph,ics,kst,ie,mph,lokph,lokcs,nz1,tcol,pcol,dncol,converged
    integer ierr,nz2,jel
    double precision, allocatable :: smat(:,:)
    double precision xxx
!
!    write(*,*)'Entering initiate_meqrec'
    if(btest(ceq%status,EQNOEQCAL)) then
! error if no sucessful equilibrium calculation or a failed one
       write(*,*)'No equilibrium calculated, no derivatives'
       gx%bmperr=8888; goto 1000
    elseif(btest(ceq%status,EQFAIL)) then
       write(*,*)'Last equilibrium calculation failed, no derivatives'
       gx%bmperr=8888; goto 1000
    elseif(btest(ceq%status,EQINCON)) then
! give warning if conditions have changed
       write(*,15)
15     format('Warning: conditions changed since last equilibrium calc,',&
            ' derivatives may be wrong.')
! EQNOACS is not used at present but means probably "no automatic comp.set"
    endif
    allocate(meqrec)
! we must enter data into meqrec here, some set outside ...
!    meqrec%typesofcond=2
    meqrec%nrel=noel()
    meqrec%maxsph=noel()+2
    meqrec%nfixph=ceq%nfixph
    meqrec%nfixmu=ceq%nfixmu
! this returns total number of phases including composition sets
!    call sumofphcs(meqrec%nphase,ceq)
!    meqrec%nphase=totalphcs(ceq)
    meqrec%nphase=nonsusphcs(ceq)
    if(gx%bmperr.ne.0) goto 1000
    allocate(meqrec%phr(meqrec%nphase))
! this means T and P are fixed (not independent)
    meqrec%tpindep=.FALSE.
    mph=0
! loop for all phases, we must set values of phase number etc
! meqrec%phr is later called "pmi"
    meqrec%nstph=0
    do iph=1,noph()
       do ics=1,noofcs(iph)
          kst=test_phase_status(iph,ics,xxx,ceq)
!          meqrec%nv=meqrec%nv+1
          if(kst.ge.PHDORM) then
             mph=mph+1
             meqrec%phr(mph)%iph=iph
!             write(*,*)'phases: ',mph,iph
             meqrec%phr(mph)%ics=ics
             meqrec%phr(mph)%phasestatus=kst
             meqrec%phr(mph)%ionliq=-1
             meqrec%phr(mph)%i2sly=0
             if(test_phase_status_bit(iph,PHIONLIQ)) meqrec%phr(mph)%ionliq=1
! set link to calculated values of G etc.
             call get_phase_compset(iph,ics,lokph,lokcs)
             meqrec%phr(mph)%curd=>ceq%phase_varres(lokcs)
!             if(btest(ceq%phase_varres(lokcs)%status2,CSSTABLE)) then
             if(kst.ge.PHENTSTAB) then
! this phase has the stable bit set
                meqrec%phr(mph)%stable=1
                meqrec%nstph=meqrec%nstph+1
! store the index of the phase in phr, not the phase number 
                meqrec%stphl(meqrec%nstph)=mph
             else
! unstable phase
                meqrec%phr(mph)%stable=0
             endif
             meqrec%phr(mph)%idim=0
!          else
! nothing to do for suspended or hidden phase
          endif
       enddo
    enddo
    meqrec%nphase=mph
! copy current values of ceq%complist%chempot(1) to ceq%cmuval, why??
    do ie=1,meqrec%nrel
       ceq%cmuval(ie)=ceq%complist(ie)%chempot(1)/ceq%rtn
    enddo
    meqrec%dormlink=0
    do mph=1,meqrec%nphase
! loop to calculte and invert the phase matrices
       pmi=>meqrec%phr(mph)
!       write(*,*)'Inverting phase matrix ',mph
! This will calculate all G, dG/dZ1 and d2G/dZ1dZ2 and the inverted phase matrix
!       write(*,*)'calling meq_onephase: ',mph
       call meq_onephase(meqrec,pmi,ceq)
       if(gx%bmperr.ne.0) then
          write(*,*)'Error calculating phase matrix'
          gx%bmperr=8888; goto 1000
       endif
    enddo
! now we will solve a modified phase matrix and calculate svar
! copy part of it from ceq%savesmat, copy also any fix mu and phase
! no problem to allocate as meqrec just allocated
    if(ceq%nfixmu.gt.0) then
       meqrec%nfixmu=ceq%nfixmu
       allocate(meqrec%mufixel(meqrec%nfixmu))
       do mph=1,ceq%nfixmu
          meqrec%mufixel(mph)=ceq%fixmu(mph)
       enddo
    endif
    if(ceq%nfixph.gt.0) then
       meqrec%nfixph=ceq%nfixph
       allocate(meqrec%fixph(2,meqrec%nfixph))
       do mph=1,ceq%nfixph
          meqrec%fixph(1,mph)=ceq%fixph(1,mph)
          meqrec%fixph(2,mph)=ceq%fixph(2,mph)
       enddo
    endif
! negative value of ceq%sysmatdim means no matrix saved
    nz1=abs(ceq%sysmatdim)+1
    allocate(smat(nz1,nz1+1))
    smat=zero
    allocate(svar(nz1))
! savesysmat not used, all equations calculated again
!    do mph=1,nz1-1
!       do ie=1,nz1-1
!          smat(mph,ie)=ceq%savesysmat(mph,ie)
!       enddo
!    enddo  
!    write(*,*)'Saved equil matrix',nz1
!    do jel=1,nz1
!       write(*,86)(smat(jel,nz2),nz2=1,nz1+1)
!    enddo
!86  format(6(1pe12.4))
    tcol=0
    pcol=0
! dncol is number of variable potentials (including T or P if variable)
    dncol=meqrec%nrel-meqrec%nfixmu
    converged=-1
    if(svr%statevarid.eq.1) then
       tcol=nz1
       meqrec%tpindep(1)=.TRUE.
    elseif(svr%statevarid.eq.2) then
       pcol=nz1
       meqrec%tpindep(2)=.TRUE.
    else
       write(*,*)'Derivatives with respect to T and P allowed only'
       gx%bmperr=8888; goto 1000
    endif
!-------------------------------------------------------------------
!    write(*,854)'dncol mm: ',tcol,pcol,dncol,converged,nz1
854 format(a,10i5)
    call setup_equilmatrix(meqrec,meqrec%phr,nz1,smat,tcol,pcol,&
         dncol,converged,ceq)
! set all terms in the RHS to zero
    nz2=nz1+1
    do mph=1,nz1
       smat(mph,nz2)=zero
    enddo
!
! Add extra variable Delta-T for all stable phases: this is dG/dT
! This is redundant now??
    do mph=1,meqrec%nstph
       jel=meqrec%stphl(mph)
       smat(mph,nz1)=-meqrec%phr(jel)%curd%gval(2,1)
    enddo
! this is the line for Delta T or Delta P, all terms zero except last
    
    smat(nz1,nz1)=one
    smat(nz1,nz2)=one
! check matrix and rhs
!    write(*,*)'Equil matrix and solution in initiate_meqrec'
!    do jel=1,nz1
!       write(*,89)jel,(smat(jel,nz2),nz2=1,nz1+1)
!    enddo
89  format('q ',i2,6(1pe12.4))
! solve equil matrix 
    call lingld(nz1,nz1+1,smat,svar,nz1,ierr)
    if(ierr.ne.0) then
       write(*,*)'initiate_meqrec error in lingld',ierr,nz1
!       do jel=1,nz1
!          write(*,89)jel,(smat(jel,nz2),nz2=1,nz1+1)
!       enddo
       gx%bmperr=8888; goto 1000
!    else
    endif
!    write(*,89)0,(svar(jel),jel=1,nz1)
1000 continue
    return
  end subroutine initiate_meqrec

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
  subroutine meq_state_var_value_derivative(svr1,svr2,value,ceq)
! calculates a state variable value derivative (in some cases)
! svr1 and svr2 identifies the state variables in (dstv1/dstv2)
! check that svr2 2 is a condition
! value is calculated value
! ceq is current equilibrium
!
    implicit none
    TYPE(gtp_equilibrium_data), pointer :: ceq
    TYPE(gtp_state_variable), pointer :: svr1,svr2
    double precision value
!\end{verbatim}
! variables needed to calculate phase inverse
    TYPE(meq_setup), pointer :: meqrec
    TYPE(meq_phase), pointer :: pmi
    TYPE(gtp_condition), pointer :: pcond
    integer iel,mph,jj,nterm
    double precision xxx
    double precision, allocatable :: svar(:)
!
    value=zero
!    write(*,*)'In meq_state_var_value_derivative: ',svr2%statevarid
! we must check if there is a condition on svr2
    pcond=>ceq%lastcondition
    if(.not.associated(pcond)) then
       write(*,*)'There are no conditions at all!'
       gx%bmperr=8888; goto 1000
    endif
! all conditions have just one term at present
    nterm=1
    call get_condition(nterm,svr2,pcond)
    if(gx%bmperr.ne.0) then
       write(*,71)
71     format('To calculate a derivative the state variable after the dot',&
            ' must be a condition')
       goto 1000
    elseif(pcond%active.eq.1) then
! active=1 means not active
       write(*,71)
       goto 1000
    endif
! Currently only implemented H.T 
    if(.NOT.(svr2%statevarid.eq.1 .or. svr2%statevarid.eq.2)) then
       write(*,*)'Derivatives with respect to T and P only'
       gx%bmperr=8888; goto 1000
    endif
!------------
!    write(*,17)'minimzer: meq_state_var_value_derivative: ',&
!         svr1%statevarid,svr1%oldstv,svr1%argtyp,&
!         svr2%statevarid,svr2%oldstv,svr2%argtyp
!17 format(a,10i4)
! meqrec creates the data structure for the equilibrium data
! this routine also calculated Delta-amount of phases and delta-mu
    call initiate_meqrec(svr2,svar,meqrec,ceq)
    if(gx%bmperr.ne.0) goto 1000
    iel=size(svar)
!    write(*,18)(svar(jj),jj=1,iel)
18  format('svar: ',6(1pe12.4)(6x,6e12.4))
!---------------
!100 continue
! if no phase specified loop over all stable phases
!    write(*,*)'We have initiad meqrec: ',svr1%statevarid
!    if(svr1%statevarid.eq.9) then
    if(svr1%statevarid.ge.6 .and. svr2%statevarid.lt.15) then
! This is derivatives of U, S, etc, H has svr1%statevarid=9, oldstv=40
! TO BE DONE: implement H(phase).T and normalizing 
       iel=0
       jj=1
       do mph=1,meqrec%nphase
! ignore phases with zero amount
          if(meqrec%phr(mph)%curd%amfu.gt.zero) then
! the hope is that the phase amounts in svar are in the same order as
! in svar as ordered in meqrec%phr ...
             call meq_calc_phase_derivative(svr1,svr2,meqrec,mph,iel,&
                  svar,jj,xxx,ceq)
             if(gx%bmperr.ne.0) goto 1000
             jj=jj+1
!             write(*,69)'MM der: ',mph,ceq%tpval(1),value,xxx
69           format(a,i3,6(1pe14.6))
          else
             xxx=zero
          endif
          value=value+xxx
       enddo
    elseif(svr1%statevarid.eq.17) then
! This should be x(phase,element).T
       do mph=1,meqrec%nphase
          if(svr1%phase.eq.meqrec%phr(mph)%iph .and. &
               svr1%compset.eq.meqrec%phr(mph)%ics) then
             call meq_slope(mph,svr1,meqrec,value,ceq)
             goto 1000
          endif
       enddo
       write(*,*)'No such phase'
       gx%bmperr=8888
    else
       write(*,*)'Sorry, derivates of this variable not implemented'
       gx%bmperr=8888; goto 1000
    endif
! meqrec automatically deallocated when this routine terminates
!    deallocate(meqrec)
!    gx%bmperr=4078
1000 continue
    return
  end subroutine meq_state_var_value_derivative

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\
    
!\begin{verbatim}
  subroutine meq_calc_phase_derivative(svr1,svr2,meqrec,iph,iel,&
       svar,jj,value,ceq)
! Calculate contribution for one phase, one or all elements
! svr1 and svr2 identifies the state variables in (dstv1/dstv2)
! value is calculated value returned
! iph and iel indicate possible phase or element
! svar is solution to equil matrix, potentials and phase amounts
! jj is an attempt to index phases in svar, starting with 1
! ceq is current equilibrium
!
! THIS IS UNFINISHED can only handle H.T
!
    implicit none
    TYPE(gtp_equilibrium_data), pointer :: ceq
    TYPE(gtp_state_variable), target :: svr1,svr2
    TYPE(meq_setup), pointer :: meqrec
    integer iph,iel,jj
    double precision value,svar(*)
!\end{verbatim}
! variables needed to calculate phase inverse
    TYPE(meq_phase), pointer :: pmi
    integer jy,jel,jz
    double precision x1,x2,x3
    double precision mag,mat,map,dmsum,dpham,dhdy,musum,dy,hconfig
    double precision, allocatable :: mamu(:)
!
! THE MASTER VERSION OF THIS TABLE in PMOD25C.F90
! symb cmix(2) indices                   statevarid Property
! U       10   (phase#set)                    6     Internal energy (J)
! UM      11    "                             6     per mole components
! UW      12    "                             6     per kg
! UV      13    "                             6     per m3
! UF      14    "                             6     per formula unit
! S       2x    "                             7     entropy
! V       3x    "                             8     volume
! H       4x    "                             9     enthalpy
! A       5x    "                            10     Helmholtz energy
! G       6x    "                            11     Gibbs energy
! NP      7x    "                            12     moles of phase
! BP      8x    "                            13     mass of moles
! DG      9x    "                            15 ?   Driving force
! Q       19x   "                            14 ?   Internal stability
! N       11x  (component/phase#set,component) 16  moles of components
! X       111   "                            17     mole fraction of components
! B       12x   "                            18     mass of components
! W       122   "                            19     mass fraction of components
! Y       13    phase#set,constituent#subl   20     constituent fraction
! statevarid=1 is T, 2 is P, 3 is MU, 4 is AC, 5 is LNAC
!------------------------------------------------------------
    allocate(mamu(meqrec%nrel))
    pmi=>meqrec%phr(iph)
    value=zero
    if(iel.lt.0) then
! sum for all elements
       write(*,*)'sum over elements not implemented'
       gx%bmperr=8888
    elseif(iel.eq.0) then
! independent of element, return for phase
       musum=zero
       do jy=1,pmi%ncc
          dy=zero
          call calc_dgdyterms2(jy,meqrec%nrel,mamu,mag,mat,map,pmi)
          if(gx%bmperr.ne.0) goto 1000
          jz=1
          if(meqrec%nfixmu.gt.0) then
! if there are fixed potentials such elements should be ignored here
! as there is no value in svar (value is zero as fixed)
             write(*,*)'Dot derivatives and potential condition not implemented'
             goto 1000
          endif
! sum the contribution for the potentials
          do jel=1,meqrec%nrel
             jz=jz+1
             dy=dy+mamu(jel)*svar(jel)
!             write(*,666)'dy: ',mamu(jel),svar(1),dy
          enddo
          dy=dy-mat
!          write(*,666)'dy: ',mat,dy
! here we check which state variable we take derivative of, H is 9
!          write(*,*)svr1%statevarid
          select case(svr1%statevarid)
          case default
! state variables 1..5 are potentials, 14-15 not possible to derivate
             write(*,*)'Illegal state variable id:',svr1%statevarid
             gx%bmperr=8888; goto 1000
          case(6) !U = G + TS - PV = G - T G.T - P G.P
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(7) !S = -G.T
             hconfig=-pmi%curd%dgval(2,jy,1)
          case(8) !V = G.P
             write(*,*)'Not implemeneted yet: ',svr1%statevarid
          case(9) !H = G + TS = G - T G.T
             hconfig=pmi%curd%dgval(1,jy,1)-ceq%tpval(1)*pmi%curd%dgval(2,jy,1)
          case(10) !A = G - PV = G - P G.P
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(11) !G itself, dG/dy
             hconfig=pmi%curd%dgval(1,jy,1)
          case(12) !NP phase amount
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(13) !BP phase mass
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(16) !N
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(17) !X
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(18) !B
             write(*,*)'Not implemeneted yet: ',svr1%statevarid
          case(19) !W
             write(*,*)'Not implemented yet: ',svr1%statevarid
          case(20) !Y
             write(*,*)'Not implemented yet: ',svr1%statevarid
          end select
!          if(svr1%statevarid.eq.9) then
!             hconfig=pmi%curd%dgval(1,jy,1)-ceq%tpval(1)*pmi%curd%dgval(2,jy,1)
!          endif
          musum=musum+hconfig*dy
!          write(*,*)'musum: ',musum,dy
       enddo
       x3=ceq%rtn*pmi%curd%amfu*musum
!       write(*,765)'x3= ',ceq%rtn,pmi%curd%amfu,musum
! we have to take care of fixed chemical potentials, the number of
! elements+1-(#fixed mu) should be the index of dpham
! The way of indexing with jj is dangerous ...
       dpham=svar(meqrec%nrel+jj)
!       write(*,665)'dpham: ',meqrec%nrel,jj,svar(meqrec%nrel+jj-1),&
!            svar(meqrec%nrel+jj)
665    format(a,2i3,6(1pe14.6))
! here we check which state variable we take derivative of
       select case(svr1%statevarid)
       case default
! state variables 1..5 are potentials, 14-15 not possible to derivate
          write(*,*)'Illegal state variable id:',svr1%statevarid
          gx%bmperr=8888; goto 1000
       case(6) !U = G + TS - PV
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(7) !S = -dG/dT
          x1=-ceq%rtn*dpham*pmi%curd%gval(2,1)
          x2=-ceq%rtn*pmi%curd%amfu*ceq%tpval(1)*pmi%curd%gval(4,1)
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(8) !V = dG/dP
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(9) !H = G + TS = G - T G.T
! x1 is change in phase amount times H
          x1=-ceq%rtn*dpham*(pmi%curd%gval(1,1)-ceq%tpval(1)*pmi%curd%gval(2,1))
!          write(*,666)'x1: ',ceq%rtn,dpham,pmi%curd%gval(1,1),&
!               ceq%tpval(1)*pmi%curd%gval(2,1),x1
! x2 is phase_amount * dH/dT = .. -T*d2G/dT2 = -T
          x2=-ceq%rtn*pmi%curd%amfu*ceq%tpval(1)*pmi%curd%gval(4,1)
       case(10) !A = G - PV
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(11) !G itself
          x1=-ceq%rtn*dpham*pmi%curd%gval(1,1)
          x2=ceq%rtn*pmi%curd%amfu*pmi%curd%gval(2,1)
          write(*,*)'G.T: ',x1,x2
       case(12) !NP phase amount
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(13) !BP phase mass
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(16) !N moles
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(17) !X mole fraction
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(18) !B mass
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(19) !W mass fraction
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       case(20) !Y constituent fraction
          write(*,*)'Not implemeneted yet: ',svr1%statevarid
       end select
!       if(svr1%statevarid.eq.9) then
! x1 is change in phase amount times H
!         x1=-ceq%rtn*dpham*(pmi%curd%gval(1,1)-ceq%tpval(1)*pmi%curd%gval(2,1))
! x2 is phase_amount * dH/dT = .. -T*d2G/dT2 = -T
!         x2=-ceq%rtn*pmi%curd%amfu*ceq%tpval(1)*pmi%curd%gval(4,1)
!       endif
! x3 is phase amount times change in configuration
!       x3=ceq%rtn*pmi%curd%amfu*musum
!       write(*,666)'CP= ',x1,x2,x3,x1+x2+x3,dpham
666    format(a,6(1pe14.6))
! just to show the error
!       value=x2
       value=x1+x2+x3
   else
! something for a specific element
       write(*,*)'Element specific not implemented'
       gx%bmperr=8888
    endif
!
1000 continue
    return
  end subroutine meq_calc_phase_derivative

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!-\begin{verbatim}
  subroutine meq_slope(mph,svr,meqrec,value,ceq)
! Test subroutine for x(phase,A).T
    TYPE(meq_setup) :: meqrec
    TYPE(gtp_equilibrium_data), pointer :: ceq
    TYPE(gtp_state_variable) :: svr
    double precision value
    integer mph
!-\end{verbatim}
!    TYPE(meq_phase), pointer :: pmi
    integer nsl,nkl(10),knr(maxconst)
    double precision yarr(maxconst),sites(10),qq(5)
!    
    call get_phase_data(svr%phase,svr%compset,nsl,nkl,knr,yarr,sites,qq,ceq)
    if(gx%bmperr.ne.0) goto 1000
!
1000 continue
    return
  end subroutine meq_slope

end MODULE liboceq

